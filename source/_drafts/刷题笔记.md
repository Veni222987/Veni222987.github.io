---
title: 刷题笔记
tags:
  - leetcode
categories: notes
cover: /img/mycover.jpg
highlight_shrink: false
date: 2024-03-31 17:56:03
---

# Go语言基础

## 标准函数

使用Go刷题，总得知道一些内置函数吧：

### 排序函数

在旧的go语言版本中，排序的函数主要在sorts包，而当go在1.18版本加入泛型之后，slices包也可以对切片进行排序，而且根据官方描述，slices包的排序比sorts包的排序更快，这里主要介绍slices包的排序函数。

```go 
// 展示如何使用slices包排序
func usage() {
	arr := []int{5, 7, 3, 8, 2, 1}
	// 默认升序排列
	slices.Sort(arr)
	fmt.Println(arr)
	// 自定义排列函数实现降序排列
	slices.SortFunc(arr, func(i, j int) int { return j - i })
	fmt.Println(arr)
	// 自定义类型排列
	type person struct {
		name string
		age  int
	}
	parr := []person{
		{"momo", 18},
		{"neo", 22},
		{"venii", 15},
	}
	slices.SortFunc(parr, func(a, b person) int { return a.age - b.age })
	fmt.Println(parr)
	// 自定义非数据类型排序，例如按照名字长度排序
	slices.SortFunc(parr, func(a, b person) int { return len(a.name) - len(b.name) })
	fmt.Println(parr)
}
```

要想比较一下这两个包下的排序算法速度，可以使用如下方法：

生成两个一模一样的随机切片，让两个函数分别对其进行排序，比较两个排序算法在不同长度的切片下的耗时：

```go 
func performance(length int) {
	// 随机初始化数组
	arr1, arr2 := make([]int, length), make([]int, length)
	for i := range length {
		randNum := rand.Intn(101)
		arr1[i] = randNum
		arr2[i] = randNum
	}

	start := time.Now()
	sort.Slice(arr1, func(i, j int) bool { return arr1[i] < arr1[j] })
	timeMicroS := time.Since(start).Microseconds()
	fmt.Println("time of arr1:", timeMicroS)

	start = time.Now()
	slices.SortFunc(arr2, func(a, b int) int { return a - b })
	timeMicroS = time.Since(start).Microseconds()
	fmt.Println("time of arr2:", timeMicroS)
}
```

经过实验，方法2（即slices包）的算法确实比sort包的方法略快一些。

# 思想

在这里，说一下

# 实现







# 题外话

## 刷题形式

刷题的平台以leetcode为主，但是leetcode开debug要钱啊，那咋办呢？总不能一出错就不排查，直接看答案，或者看不出来代码问题干瞪眼半天吧。所以我的主要刷题方式是，用vscode写代码，使用单测来debug。

为了能够随时随地刷题，即便在不同的机器上也能无缝衔接，怎么办呢？用开发机+ssh，这样刷题体验就非常丝滑了。
