<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Exp】深入理解Go语言函数与方法</title>
      <link href="/2024/04/11/%E3%80%90Exp%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
      <url>/2024/04/11/%E3%80%90Exp%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言的函数有四个组成部分：函数名、形参列表、返回值列表、函数体。一个最标准的函数形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的前三个组成部分构成了函数的签名，可以使用如下方式查看签名，其中%T是Go语言的占位符，用于打印变量的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := twoSum</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f)</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// func(int, int) int</span></span><br></pre></td></tr></table></figure><p>函数在Go语言中也是一种数据类型，具有地址。可以通过函数名或者<code>&amp;</code>运算符来获取函数的地址，并将其赋值给函数类型的变量。这使得在Go语言中可以像操作其他类型一样操作函数，例如将函数作为参数传递给其他函数或存储函数的地址。所以，可以使用函数作为参数传递实现回调函数，也可以将返回值设置为函数实现闭包，后面会详细讲。在我看来，函数可以<strong>理解成为一个特殊的引用数据类型</strong>，其零值为<code>nil</code>，可以取址、可以作为赋值符号的右操作数。</p><p>接下来文章将按照函数的四个组成部分逐步深入理解函数。</p><h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>参数列表可以简写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以简写成为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是省略的条件是同一类型的形参放在一块。注意形参都是<strong>有序的</strong>，Go语言<strong>没有参数默认值</strong>，在传递实参的时候，必须严格按照形参列表顺序传递。所以，在开发中需要注意入参顺序，写好函数注释。有人会说，没有默认参数值多不方便啊，如果一个函数有十几个参数，没有默认参数怎么办呢？这就是工程架构设计的问题了，需要拆分接口，分步实现，或者采用结构体等形式实现默认操作。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是通过在参数类型前加上省略符<code>...</code>来定义的。这表示该参数可以接受零个或多个值，这些值将被作为<strong>切片（slice）</strong>传递给函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfAll</span><span class="params">(nums ...<span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">res += value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数在一个函数里面只能使用一次，并且必须放在参数列表的最后一个位置。如果使用两次或者不将其放在最后一个位置（其实使用两个可变参数就必然会导致其中一个可变参数不位于最后一个位置），将会无法通过编译：<code>Can only use &#39;...&#39; as the final argument in the list</code>。</p><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>对于Go而言，函数的参数传递方式只有值传递。这对于熟悉Java的人来说比较难以理解，因为对他们而言引用传递可能更深入人心。其实除了基本数据类型以外，函数传递的都是该变量在内存中的地址值，当程序访问变量的时候，都是通过地址访问的，也就是说，引用类型在修改数据的时候都是间接修改了内存中的值，从而使得修改对于所有其他的引用都是可见的。”Go语言圣经“原话是这么说的：</p><blockquote><p>Arguments are passed by value, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affec ted by any modifications the function makes to variables indirectly referred to by the argument.</p></blockquote><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是一种编程模式，其中一个<strong>函数作为参数传递给另一个函数</strong>，并且在<strong>特定的事件发生或条件满足时被调用</strong>。下面的函数展示了Go语言的回调函数的使用方法，其中<code>passingFunc</code>接受一个<code>func(int) int</code>类型的回调函数，然后传入一个numDouble函数将data数据翻倍，最后在主函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passingFunc</span><span class="params">(data []<span class="type">int</span>, callback <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> data &#123;</span><br><span class="line">       fmt.Println(callback(d))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDouble</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> data &#123;</span><br><span class="line">data[i] = i</span><br><span class="line">&#125;</span><br><span class="line">passingFunc(data, numDouble)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果为：<code>0 2 4 6 8</code> 。（空格为换行，为省略空间表示为这种形式）。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>Go不允许函数重载，也就是说，函数名是一个函数的唯一标识，不存在同一个函数名不同参数的情况（C++、Java都有）。</p><h3 id="省略函数名——匿名函数"><a href="#省略函数名——匿名函数" class="headerlink" title="省略函数名——匿名函数"></a>省略函数名——匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个匿名函数并立即调用</span></span><br><span class="line">    result := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;结果:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将匿名函数赋值给变量</span></span><br><span class="line">    subtract := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = subtract(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;结果:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名函数作为参数传递给回调函数会使得代码更加简洁，例如上面回调函数的示例代码中，可以不用定义numDouble函数，而是直接将其作为匿名函数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passingFunc(data, <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="匿名函数与作用域"><a href="#匿名函数与作用域" class="headerlink" title="匿名函数与作用域"></a>匿名函数与作用域</h3><p>匿名函数可以获取作用域外的变量，使用的方法是直接在函数体内声明并使用该匿名函数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x的值为:&quot;</span>, x)</span><br><span class="line">    x += <span class="number">5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;修改后:&quot;</span>, x)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;匿名函数执行后:&quot;</span>, x)</span><br><span class="line"><span class="comment">//执行结果（省略版）： 10 15 15</span></span><br></pre></td></tr></table></figure><p>也可以将匿名函数赋值给一个变量让其多次调用，这里就不举例了。从上述代码看可以看到，匿名函数可以在函数体内部调用，并且在函数作用域内的变量都可以被该匿名函数访问和修改。当返回值为函数时，这种作用域将会被保留称为闭包的引用环境。</p><h3 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h3><p>有这么一个对闭包的总结： <strong>闭包&#x3D;函数+引用环境</strong>。因此闭包的核心就是：<strong>函数</strong>和<strong>引用环境</strong>。<br>[Go语言基础知识 —— Closure(闭包)]: <a href="https://zhuanlan.zhihu.com/p/645853924">https://zhuanlan.zhihu.com/p/645853924</a></p><p>下面先看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">       count++</span><br><span class="line">       <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := newCounter()</span><br><span class="line">    fmt.Println(f()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">//2</span></span><br><span class="line">    f1 := newCounter()</span><br><span class="line">    fmt.Println(f1()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(f1()) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始看到可能会觉得很抽象，但是没关系，接下来会慢慢讲解。首先观察newCounter这个函数的返回值是一个函数类型，意味着什么呢？意味着这段代码使用newCounter创建了一个函数。观察函数体内，可以发现，返回的是一个匿名函数并没有包含count变量。那为什么多次调用count会实现自增功能呢？那是因为在创建函数的时候用到了count，所以每一次执行newCount都会创建一个count的副本和一个匿名函数，实现了将这个匿名函数绑定到当时环境的功能，而被创建出来的函数，就是一个闭包。</p><p>所以，再回顾一下上面那句话：<strong>闭包&#x3D;函数+引用环境</strong>。闭包其实就是一个特殊函数，他可以捕获函数内部变量和参数，并将它们与函数创建的环境绑定在一起。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>函数的单返回值就不多说了，下面重点讲讲多返回值。多返回值常常结合错误处理使用，一般而言，函数的第一个返回值是函数本身具有实际意义的返回结果，最后一个返回值通常是错误，错误的类型往往是error。一般设计上，Go语言的多返回值都是两个，但是Go本身支持两个以上的返回值，例如整数除法就可以同时返回商、余数、近似值等。</p><blockquote><p>error是Go语言内置的类型，以字符串的形式简要报告了错误，提供了灵活的处理方式。</p></blockquote><h3 id="命名返回值的return带操作数会被覆盖吗"><a href="#命名返回值的return带操作数会被覆盖吗" class="headerlink" title="命名返回值的return带操作数会被覆盖吗"></a>命名返回值的return带操作数会被覆盖吗</h3><p>当我们在return语句中显式指定了返回值时，它将覆盖函数体中的命名返回值，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus2</span><span class="params">(x <span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       res++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> res * <span class="number">2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       等价于</span></span><br><span class="line"><span class="comment">       res = res * 2</span></span><br><span class="line"><span class="comment">       return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数中，我们在参数列表预定义了返回结果，按理来说只需要写<code>return</code>就好，后面不需要跟任何操作数。但是如果写了操作数的话就相当于对操作数进行了一次赋值，也就是用后来的结果覆盖了原结果。</p><p>实际上，return语句并不是原子操作，它执行的逻辑是：<strong>保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数</strong>。</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><h3 id="延迟函数调用与defer语句"><a href="#延迟函数调用与defer语句" class="headerlink" title="延迟函数调用与defer语句"></a>延迟函数调用与defer语句</h3><p>defer是一个功能强大的关键字，表示延迟函数调用。从使用形式上看 ，defer就是一个普通的函数或方法调用，注意defer必须跟一个函数或方法调用，如果不是，那么请将其改为匿名函数形式。它将defer后面的代码执行完毕之后再执行defer语句，无论是后面的代码会return还是宕机。当然，如果陷入了死循环是无法执行defer后面的代码的。defer一般用于一对操作，例如打开和关闭文件、加锁和释放锁等等。当同一个函数里面有多个defer的时候，按照栈的顺序执行，即先进后出。使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用defer实现了加锁和释放锁，从而保证了对map的互斥访问。</p><h3 id="在defer后面修改返回值会怎样"><a href="#在defer后面修改返回值会怎样" class="headerlink" title="在defer后面修改返回值会怎样"></a>在defer后面修改返回值会怎样</h3><p>还记得上面说过的return语句执行顺序吗？<strong>保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数</strong>。这个就决定了defer语句是否影响返回值。所以结果就是：<strong>defer语句会修改指针类型和命名返回值的返回结果，而不会影响匿名返回值的结果</strong>。从实现原理来看，匿名返回值在保存返回变量的阶段就已经被保存下来了，后面的操作都会被忽略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       x++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus2</span><span class="params">(x <span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       res++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> res * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus3</span><span class="params">(x *<span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       *x++</span><br><span class="line">    &#125;()</span><br><span class="line">    *x = *x * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    fmt.Println(plus(x))</span><br><span class="line">    fmt.Println(plus2(x))</span><br><span class="line">    fmt.Println(*plus3(&amp;x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：2 3 3</span></span><br></pre></td></tr></table></figure><h3 id="宕机与恢复如何使用"><a href="#宕机与恢复如何使用" class="headerlink" title="宕机与恢复如何使用"></a>宕机与恢复如何使用</h3><p>之所以把它放在函数体这一部分，是因为Go的程序就是由函数组成的，其最外层入口就是main函数，程序的宕机是由函数的宕机造成的。panic和其他语言的运行时异常有点相似，如果不加以处理 ，最终都会导致程序终止执行。在发生panic之后，程序会终止执行，然后运行所有的defer函数，最后在程序退出之前打印调用堆栈。</p><p>panic除了由函数在运行时造成以外，还可以自己生成，因为panic本身就是一个函数，函数原型为：<code>func panic(v any)</code>。其中any代表了panic可以传入任何类型的参数，但是要求能够描述panic的原因，所以一般情况下使用string类参数。自己抛出panic的demo如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ......业务代码</span></span><br><span class="line">    <span class="comment">// 产生panic</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;发生了错误：输入条件无意义&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除了把panic直接抛出以外，还可以从panic中恢复(recover)，并且recover必须放在defer中才有意义，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverFromPanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot;捕获到panic:&quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> recoverFromPanic()</span><br><span class="line">    <span class="comment">// 产生panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;发生了错误：&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recover就相当于异常处理机制的catch语句，recover可以捕获内层函数没有recover的panic。一个合理的做法是将部分可预见的panic封装称为error向上返回，使其不影响程序的执行。但是必须做好错误提醒，因为一旦将panic封装为error之后，将会默认隐藏调用堆栈，从而加大debug难度。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>和函数一样，我们可以把Go语言的方法拆分成五个组成部分：接收者、方法名、形参列表、返回值列表、方法体。方法比函数多了一个接收者，有点类似传统OOP语言的成员函数，声明的时候放在方法名前面，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> distanceTo(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%.2f&quot;</span>, p.distanceTo(Point&#123;<span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go要求自定义接收名，例如<code>p Point</code>，在Go中不使用类似this或者self这种隐式指针或者引用，但可以自己将其命名称为类似的名字，推荐命名尽量简短，因为方法可能需要频繁操作自身变量，推荐使用该类型的首字母小写。</p><h2 id="方法名和成员变量名冲突吗"><a href="#方法名和成员变量名冲突吗" class="headerlink" title="方法名和成员变量名冲突吗"></a>方法名和成员变量名冲突吗</h2><p>Go的方法和类型成员同在一个命名空间内，所以不能起和成员变量一样的方法名，例如，我们在上述代码段中尝试加入一个名称为X的方法，编译器将会报错：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240414172852308.png" alt="image-20240414172852308"></p><p>但是包级别函数名和方法名不冲突，也就是说，可以同时声明<code>func (a TypeA) A()&#123;&#125;</code>和<code>func A()&#123;&#125;</code>。</p><h2 id="哪些类型可以声明方法"><a href="#哪些类型可以声明方法" class="headerlink" title="哪些类型可以声明方法"></a>哪些类型可以声明方法</h2><p>我们可以为<strong>同一个包</strong>内<strong>基本数据类型和引用类型声明方法</strong>，指针类型和接口类型无法增加方法。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型增加方法</span></span><br><span class="line"><span class="keyword">type</span> age <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a age)</span></span> olderThan(b age) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型增加方法</span></span><br><span class="line"><span class="keyword">type</span> myPoint []<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p myPoint)</span></span> distanceTo(q myPoint) <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt((p[<span class="number">0</span>]-q[<span class="number">0</span>])*(p[<span class="number">0</span>]-q[<span class="number">0</span>]) + (p[<span class="number">1</span>]-q[<span class="number">1</span>])*(p[<span class="number">1</span>]-q[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型无法定义方法，（error是内置的接口类型）以下代码将会无法编译：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type myError error</span></span><br><span class="line"><span class="comment">func (e myError) function()&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，指针类型也无法定义方法：下面的代码会报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type pInt *int</span></span><br><span class="line"><span class="comment">func (p pInt) function()&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="指针接收者方法"><a href="#指针接收者方法" class="headerlink" title="指针接收者方法"></a>指针接收者方法</h2><p>接收者分为<strong>值接收者</strong>和<strong>指针接收者</strong>两种。指针接收者方法就是把所属类型的接收对象改为指针的形式，例如，我们为Point类创建指针接收者方法可以写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> distance2(q *Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是把方法绑定的变量改成了该类型的指针形式。如果直接在原来的基础上增加一个指针接收者方法，那编译器将会出现提醒：<code>Struct Point has methods on both value and pointer receivers. Such usage is not recommended by the Go Documentation. </code>也就是说不推荐同时存在两种接收者。所以，<strong>一旦该类型有一个指针接收者方法，那么其余所有方法都应该使用指针作为接收者</strong>。</p><p>由于指针接收者的存在，所以Go语言不允许指针类型定义方法，防止混淆，因为编译器会对两种接收者进行隐式转换，见下面的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收者类型</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> distanceTo(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者类型</span></span><br><span class="line"><span class="keyword">type</span> Point2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point2)</span></span> scaleBy(size <span class="type">float64</span>) &#123;</span><br><span class="line">p.X, p.Y = size*p.X, size*p.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point2)</span></span> distanceTo(q *Point2) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(((*p).X-(*q).X)*((*p).X-(*q).X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动隐式转换示例，看起来可能有点绕，但是记住这个例子是为了证明方法接收者会进行隐式转换，从而不允许为指针定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 变量值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, p.distanceTo(Point&#123;<span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, (&amp;p).distanceTo(Point&#123;<span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line"></span><br><span class="line">p2 := &amp;Point2&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 变量指针</span></span><br><span class="line">p2.scaleBy(<span class="number">2</span>) <span class="comment">// 直接调用</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, p2.distanceTo(&amp;Point2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, (*p2).distanceTo(&amp;Point2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;))</span><br><span class="line"></span><br><span class="line">(*p2).scaleBy(<span class="number">0.5</span>) <span class="comment">// 类型转换后调用</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, p2.distanceTo(&amp;Point2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, (*p2).distanceTo(&amp;Point2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>nil也是一个合法的接收者</strong></li></ul><p>对于常见的OOP语言而言，空指针null是无法调用任何成员函数的。但是在Go中，nil是一个合法的接收者，当调用者的值为nil的时候，也可以有对应操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point2)</span></span> length() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> p==<span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p.X*p.X+p.Y*p.Y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，即使使用一个*Point2类型的空指针作为接收者，也可以调用length，返回长度为0。</p><ul><li><strong>方法变量可以将一个结构体的方法转换成为普通函数使用</strong></li></ul><p>和函数变量类似，方法变量也是将某一个方法赋值到变量中，后面使用变量调用这个方法，可以直接像函数一样使用，但是使用较少，此处就省略了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>函数和方法是Go中最重要的两个概念。Go不是传统意义上的OOP语言，它通常通过包级别来实现封装功能，而包内使用函数式编程，并对外提供服务。本文</p>]]></content>
      
      
      <categories>
          
          <category> Exp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内置集合框架及其线程安全性</title>
      <link href="/2024/02/22/Java%E5%86%85%E7%BD%AE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2024/02/22/Java%E5%86%85%E7%BD%AE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>首先需要了解一下Java的集合框架，主要包含三部分：Collection, Iterator和Map。Collection是集合，包括List, Set, Queue等等。Iterator是迭代器，Map是映射。本文不会讲解他们的基本使用和常用方法，主要针对特性和彼此的异同进行研究。我们先来看一下Java的集合框架的总览图：</p><p><img src="https://pdai.tech/images/java_collections_overview.png"></p><p>这里面的数据结构非常多，一开始可能会一无所措，但是其实慢慢拆解发现也没那么难。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Colletion是最常用的集合工具，下面这张图表现了Collection中的主要接口和类及其特点。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240222215904059.png" alt="image-20240222215904059"></p><h2 id="Collection-Interface"><a href="#Collection-Interface" class="headerlink" title="Collection Interface"></a>Collection Interface</h2><p>先来看一下Collection接口的源码都有哪些函数吧。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240305144742171.png" alt="image-20240305144742171"></p><p>不难发现，Collection的这些操作都是集合的常见操作，尤其是<code>contains, clear, add, remove</code>等等。这些接口在不同的数据结构中有不同的实现，例如对于一个List而言，remove就是直接移除队首元素，而对于一个堆（或者说优先队列）而言，remove就是移除堆顶元素，然后将最后一个元素放上来往下筛。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>先说List。从实现方式上面看，ArrayList和Vector是基于数组的，这两者比较相似，而LinkedList是基于链表的。但是从线程安全性看，Vector又是相对于ArrayList和LinkedList更独特的。Vector的函数中使用了<code>synchronized</code>关键字，例如下面的addElement函数。<code>synchronized</code>关键字确保了在多线程的情况下，Vector的方法是同步的，同一时间只能有一个线程访问Vector的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(obj, elementData, elementCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将写一段代码验证一下Vector的线程安全。首先写一个线程类，实现Runnable接口，并且重写run()函数。构造函数传入一个List。注意List是一个接口，可以实例化为ArrayList，LinkedList和Vector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListThread</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们会创建一个共享的List变量，然后实例化两个线程并将List传进去，每个线程往List中加入10000个元素（这个动作是由上面的run函数决定的，也可以测试其他的函数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个共享的List对象</span></span><br><span class="line">    List&lt;Integer&gt; sharedList = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(); <span class="comment">// 这里可以修改成为ArrayList、LinkedList试一下</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程，分别对共享的List进行操作</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ListThread</span>(sharedList));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ListThread</span>(sharedList));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印最终的List内容</span></span><br><span class="line">    System.out.println(sharedList);</span><br><span class="line">    System.out.println(sharedList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果List是实例化为Vector的话，那么最终的sharedList.size始终是20000的，但是实例化为ArrayList和LinkedList则基本上不可能达到20000。</p><blockquote><p>测试线程安全性的一般步骤是：创建共享对象-&gt;写一个线程类并传入共享对象-&gt;创建多个线程调用对象方法-&gt;观察结果。</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>回到上面的图，常用的Set包括HashSet，TreeSet和LinkedHashSet。很遗憾，这三者都是非线程安全的，后面会讲如何在多线程中安全地使用Set。</p><p>HashSet基于哈希表实现，其增加、查找和删除元素都是O(1)的，并且允许存储null元素。LinkedHashSet是在HashSet的基础上添加了链表实现，使得迭代器迭代顺序和插入顺序一致。而TreeSet是基于红黑树实现的，时间复杂度是O(logn)，不允许存储null元素。</p><ul><li><strong>HashSet是如何保证元素的唯一性的</strong></li></ul><p>使用HashSet存储自定义的类时，一般都要重写hashCode()函数和equals(Object obj)函数。</p><p>先写一个自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.util.Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后new三个对象，其中两个的字段完全一样，将其加入set中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashSet&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    set.add(person1);</span><br><span class="line">    set.add(person2);</span><br><span class="line">    set.add(person3);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;HashSet size: &quot;</span> + set.size()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果，如果重写了equals方法和hashcode方法，那么size将会是2。任何一个没有重写都会是3。</p><blockquote><p>在Java中，equals和hashCode应该是一致的，即equals为true的对象，其hashcode也应该为true。默认情况下，equals比较的是内存地址，而hashCode则是根据地址算出来的一个数。所以上面的例子中不重写的情况下，size为3。</p></blockquote><ul><li><strong>TreeSet是如何保证元素的唯一性的</strong></li></ul><p>TreeSet是基于红黑树的有序集合，它在插入元素时会根据元素的排序规则进行插入，从而保证元素的有序性。使用TreeSet存储自定义的类，也是需要满足一定的规范。在定义类的时候，需要实现<code>Comparable&lt;E&gt;</code>接口，重写<code>compareTo</code>函数，例如一个Person类根据年龄比较大小。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列的使用其实比较简单，在Java中一般使用双端队列Deque，Deque实现了Queue的接口，而LinkedList实现了Deque的接口，所以Deque一般都实例化为LinkedList。注意几对操作：push和pop可以当作stack使用；add和remove，offer和poll可以当作queue使用，后面两组queue操作的区别在于返回类型，remove会抛出错误，而poll会返回布尔值。</p><h2 id="Collections工具"><a href="#Collections工具" class="headerlink" title="Collections工具"></a>Collections工具</h2><p>Java.utils中Collections类包含许多常用的静态工具函数，例如对于List的reverse和sort等等。</p><p>上面我们提到的Set都是非线程安全的，那么想要使用线程安全的Set怎么办呢？那就可以用到Collections里面的synchronizedSet将普通的Set升级为线程安全的Set:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个普通的Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Collections.synchronizedSet()方法创建一个线程安全的Set</span></span><br><span class="line">Set&lt;String&gt; synchronizedSet = Collections.synchronizedSet(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多个线程中同时操作synchronizedSet</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        synchronizedSet.add(<span class="string">&quot;Element &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多个线程并启动</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>无论运行多少次输出size为1000(因为Set过滤相同元素)，表明在多线程中确实所有修改都是同步的。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>讲完了Collection，下面讲讲Map。还是一张图大概了解一下Map家族。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240222233725940.png" alt="image-20240222233725940"></p><p>HashMap比HashTable单机性能要好，但是牺牲了线程安全性。Collections.synchronizedMap也可以将HashMap升级为线程安全的，用法和HashSet一样。</p><blockquote><p>HashMap使用开哈希实现，同位置可以存储多个元素，最初使用链表的形式，在Java8中添加了红黑树，当链表中元素超过8个以后，同一位置的查找速度从O(n)变为O(logn)。</p></blockquote><p>ConcurrentHashMap则弥补了HashMap的缺点，它使用了一个Segment数组来对HashMap实现加锁，从而保证了线程安全，因为分段加锁，也不会牺牲太多的速度。用法如下，直接new实例化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程安全的Map</span></span><br><span class="line">        Map&lt;String, Integer&gt; concurrentMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在多个线程中同时操作concurrentMap</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                concurrentMap.put(<span class="string">&quot;Key &quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap是可排序的，和TreeSet类似，都需要实现Comparable接口。当使用Iterator遍历TreeMap的时候，得到的记录是排过序的。</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器(Iterator)是一个接口，提供了一套遍历集合（这里的集合是广义集合，包括List, Set和Map）元素的方法。遍历List或许是一件比较简单的事情，但是遍历Set和Map则不然。所以迭代器就是在这样的需求下出现的。</p><p>通过调用集合对象的<code>iterator()</code>方法，可以获取到一个实现了<code>Iterator</code>接口的迭代器对象。主要操作包括hasNext和Next。</p><p>以ArrayList为例，其内部包括了一个私有类并且实现了迭代器接口，这里面的逻辑代码可以不必深究，知道迭代器实现的整体框架即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prevent creating a synthetic constructor</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在调用<code>iterator</code>的时候，会new一个Itr并且返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到代码中迭代器可能会抛出两个异常：ConcurrentModificationException和NoSuchElementException。后者容易理解，每次调用next之前用hasNext判断即可。那么ConcurrentModificationException是什么意思呢？这是为了保证在多线程环境下的安全性。expectedModCount就是预期修改的次数，在多线程中，如果一个迭代器正在迭代，此时另一个线程对集合进行了修改，那么就会抛出这个异常。尽管设计是防止多线程的不一致性，在实际应用中，单线程情况下也会出现这个异常，那就是在迭代器迭代的时候修改了集合，例如remove，这样也是不允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (fruit.equals(<span class="string">&quot;Banana&quot;</span>)) &#123;</span><br><span class="line">        fruits.remove(fruit); <span class="comment">// 在迭代过程中修改集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在某些场景需要对List从后往前遍历，并可能删除元素的情况下，不能使用迭代器遍历。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文总结了Java的集合框架的分类和特点。Java迭代至今，每一个类都是有存在的理由的。根据不同的场景使用不同的集合类，可以避免很多隐藏的错误，或者提升程序的运行效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署项目指南</title>
      <link href="/2024/01/24/Docker%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/"/>
      <url>/2024/01/24/Docker%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>这篇文章是新手向的Docker使用文章。所以现在介绍一下Docker吧。根据Docker官方的说法：</p><blockquote><p>Docker helps developers build, share, run, and verify applications anywhere — without tedious environment configuration or management.</p></blockquote><p>简单来说就是一个帮助开发者构建、运行和分享应用的容器，它可以让你无需考虑在不同的机器上运行的时候的环境配置问题。想象一下你自己写好的一个软件，但是到了别人的计算机无法运行，又找不到环境配置哪里没配好，那个情景有多难受。这时候，如果使用了Docker，你就会明白什么叫纵享丝滑部署。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>这里的Docker安装指的是安装Docker-CE(Community Edition)。根据<a href="https://docs.docker.com/engine/install/">Docker官方指导</a>，有四种安装方法，这里介绍两种。</p><ul><li><strong>Docker Desktop</strong></li></ul><p>主要适用于带有桌面的计算机，如Windows，Ubuntu桌面等。安装了DockerDesktop就相当于安装了Docker-CE, Docker-CLI等一系列工具。对于WSL，只需要在Windows主系统安装DockerDesktop并勾选适用WSL。</p><ul><li><strong>安装包安装(apt、yum等)</strong></li></ul><p>大陆用户推荐使用阿里云镜像安装，根据<a href="https://developer.aliyun.com/mirror/docker-ce">指导</a>执行对应的shell脚本即可。</p><p>如果安装过程出现了任何问题，都可以阅读上面的官方指导链接里面的内容寻找解决方法。</p><h2 id="Docker基本使用"><a href="#Docker基本使用" class="headerlink" title="Docker基本使用"></a>Docker基本使用</h2><p>先搞清楚Docker的三个概念：镜像、容器和进程：</p><ul><li><strong>镜像（Image）：</strong>Docker镜像是一个只读的模板，它包含了运行容器所需的所有文件系统、应用程序代码、依赖项和配置信息。镜像是用于创建Docker容器的基础。</li></ul><p>查看镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;镜像名或<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><p>创建镜像后面详细说。</p><ul><li><strong>容器（Container）：</strong>Docker容器是从Docker镜像创建的运行实例。容器是独立且轻量级的，它包含了运行应用程序所需的所有内容，包括文件系统、代码、依赖项和配置。这一层的操作是最重要的，只有熟悉容器的操作，才能用好Docker。</li></ul><p>查看容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看容器端口映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port &lt;容器名&gt;</span><br></pre></td></tr></table></figure><p>从镜像创建容器并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;镜像名&gt;</span><br><span class="line"><span class="comment"># 运行时指定端口映射</span></span><br><span class="line">docker run -p &lt;主机端口&gt;:&lt;容器端口&gt; &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure><p>删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;容器名字或<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><p>重启容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器名或<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><p>进入容器内部：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器ID或名称&gt; /bin/bash</span><br></pre></td></tr></table></figure><ul><li><strong>进程（Process）：</strong>在Docker容器中运行的应用程序被视为一个或多个进程。容器内部的进程与宿主机的进程隔离，它们在自己的命名空间中运行，并且只能访问容器内部的资源。</li></ul><h1 id="部署Docker镜像"><a href="#部署Docker镜像" class="headerlink" title="部署Docker镜像"></a>部署Docker镜像</h1><h2 id="部署Docker-Hub镜像"><a href="#部署Docker-Hub镜像" class="headerlink" title="部署Docker Hub镜像"></a>部署Docker Hub镜像</h2><p>Docker Hub是一个面向Docker开发者和用户的公共注册表服务。它是一个集中存储、分享和管理Docker镜像的平台。我们可以从Docker Hub中拉取镜像，也可以上传自己的创建的镜像。</p><p>下面将以部署Redis为例，讲一下如何部署他人已经上传的镜像。上文说到过，要创建一个容器必须要有镜像，所以第一步就是将容器镜像从docker hub上拉下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>具体的指令一般都会在镜像对应页面的右上角：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240224143645281.png" alt="image-20240224143645281"></p><p>执行完成之后，可以用<code>docker images</code>指令查看本地镜像。如果有对应的镜像，那就可以run了。一般来说，Docker hub上有对应的启动和配置教程，细心阅读即可。按照默认运行，设置端口映射可以执行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis</span><br></pre></td></tr></table></figure><p>然后ps一下看看有没有成功运行就可以了。总的来说，部署他人的容器镜像比较简单，耐心阅读指导就可以了。</p><h2 id="自己创建镜像部署"><a href="#自己创建镜像部署" class="headerlink" title="自己创建镜像部署"></a>自己创建镜像部署</h2><p>自己创建镜像需要编写Dockerfile，定义和描述如何创建Docker镜像。例如，创建一个Spring boot镜像的Dockerfile可以写成如下形式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /vshop</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /vshop</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/vshop/vshop.jar&quot;</span>,<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&quot;/vshop/log.log&quot;</span>,<span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>下面是Dockerfile中的一些常见配置：</p><ul><li><p>FROM：定义基础镜像，确定构建的起点</p></li><li><p>WORKDIR：容器中的工作目录</p></li><li><p>RUN、ADD、COPY：安装软件包，依赖项和文件到镜像中</p></li><li><p>EXPOSE：配置端口</p></li><li><p>ENV：配置容器中的环境变量</p></li><li><p>CMD：启动容器时执行的指令</p></li></ul><p>编写完Dockerfile之后，将Dockerfile和打包完成的jar包放在新建目录下，然后执行如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t vshop .</span><br></pre></td></tr></table></figure><p>-t指定了打包的名字和标签，. 表示在当前目录下寻找Dockerfile并且打包。打包完成之后，使用<code>docker images</code>查看镜像即可。上面的案例仅作一个简单的示例，事实上Dockerfile大部分都是不通用的，例如将Spring boot项目打包成为war包然后运行在Tomcat容器中，则需要进行两层构建，第一层基于Tomcat构建基础镜像，第二层构建最终的镜像。当需要打包不同类型的项目的时候，可以查阅官方文档或者自行Google一下。</p><h1 id="发布Docker镜像"><a href="#发布Docker镜像" class="headerlink" title="发布Docker镜像"></a>发布Docker镜像</h1><p>前面介绍过Docker Hub了，现在讲讲如何将自己构建的Docker项目发布到Docker Hub上。首先需要自己注册一个Docker账号并且执行一下<code>docker login</code>登录Docker。然后的操作就和Git推送到GitHub差不多。</p><p>使用<code>docker tag</code>给镜像添加标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;镜像ID&gt; &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>然后直接push到Docker Hub即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>当push完成以后，在另外一台电脑（如服务器）上运行这个项目就回到了部署那一部分的内容了。现在你已经掌握了Docker构建和部署项目的基本流程了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/2023/12/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><h3 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h3><p><strong>软件</strong>（<strong>Software</strong>）是一系列按照特定顺序组织的计算机数据和指令的集合。</p><blockquote><p>一般来讲软件被划分为编程语言、系统软件、应用软件和中间件四种。</p></blockquote><ul><li>软件生存周期：软件定义、软件开发和运行维护</li></ul><p>问可需，概详编测，维</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291103482.webp" alt="image-20231229110324336"></p><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA">软件危机</a>是指在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC">软件开发</a>及维护的过程中所遇到的一系列严重问题，这些问题皆可能导致<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>产品的寿命缩短、甚至夭折。</p><p>表现为以下七点：简记为&#x3D;&#x3D;五个不（估成质软文），速度和成本&#x3D;&#x3D;。</p><ol><li>对软件开发成本和进度的估计常常很不准确。——估计不准确</li><li>用户对“已完成的”软件系统不满意的现象经常发生。——成品不满意</li><li>软件产品的质量往往靠不住。——质量靠不住</li><li>软件常常是不可维护的。——软件不可维护</li><li>软件文档资料不足。——文档资料不足</li><li>软件成本在计算机系统总成本中所占的比例逐年上升。——软件成本上升</li><li>软件开发生产率提高的速度，跟不上硬件的发展速度，跟不上计算机应用迅速普及深入的趋势。——软件发展速度跟不上</li></ol><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><ul><li><strong>什么是软件工程</strong></li></ul><p>概括地说，软件工程是指导计算机软件开发和维护的工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把正确的管理技术和最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><ul><li><strong>软件工程的目标</strong></li></ul><p>软件工程的总目标是运用先进的软件开发技术和管理方法提高软件的&#x3D;&#x3D;质量和生产率&#x3D;&#x3D;。</p><p>ISO给出六个软件的质量特性，也就是软件工程的具体目标：&#x3D;&#x3D;功可易效维移&#x3D;&#x3D;</p><ol><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>维护性</li><li>移植性</li></ol><p>一个好的软件有多种评价标准，下面介绍McCall质量模型：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291118697.webp" alt="image-20231229111857357"></p><ul><li><strong>软件工程的组成部分</strong></li></ul><p>一种组成方法如下，分为技术和管理两部分。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291051253.webp" alt="image-20231229105133068"></p><p>另外一种组成：<strong>方法、工具和过程</strong>。</p><ul><li><strong>软件工程的方法</strong></li></ul><p>通常将软件开发全过程中使用的<strong>一整套技术方法的集合</strong>称为方法学(methedology)，也称为范型(paradigm)。</p><p>目前使用最广泛的软件工程方法学是<strong>传统方法学（结构化方法学）</strong>和<strong>面向对象方法学</strong>。</p><p>结构化方法学将软件生命周期的全过程依次划分为若干个阶段，采用结构化技术来完成每个阶段的任务。要么是面向行为的，要么是面向数据的，缺乏二者的有机统一。</p><p>面向对象方法学将数据和对数据的操作紧密地结合起来的方法，对于大型、复杂以及交互性比较强的系统，使用面向对象方法学更有优势。</p><ul><li><strong>软件工程的工具</strong></li></ul><p>支持<strong>软件开发过程</strong>的工具：主要有需求分析工具、设计工具(通常还可以分为概要设计工具和详细设计工具)、编码工具、排错工具、测试工具等。</p><p>支持<strong>软件维护过程</strong>的工具：主要有版本控制工具、文档分析工具、信息库开发工具、逆向工程工具、再工程工具等。</p><p>支持<strong>软件管理过程和支持过程</strong>的工具：主要有项目管理工具、配置管理工具、软件评价工具等。</p><h2 id="软件过程和生命周期建模"><a href="#软件过程和生命周期建模" class="headerlink" title="软件过程和生命周期建模"></a>软件过程和生命周期建模</h2><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401031943469.webp" alt="image-20240103194258800"></p><p>软件的生命周期如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291103482.webp" alt="image-20231229110324336"></p><blockquote><ol><li>软件生存周期可以分为几个阶段，每个阶段的重点工作及相应的输出物是什么？</li></ol><p> 答：软件生存期由软件定义、软件开发和软件维护三个时期组成。</p><p>软件定义通常分成三个阶段：问题定义、可行性研究、需求分析。问题定义和可行性研究的输出物是开发任务的实施计划和可行性研究报告。需求分析的输出物是软件需求规格说明或系统功能规格说明、测试计划以及初步的用户手册。</p><p>软件开发通常由四个阶段组成：概要设计、详细设计、编码和测试。概要设计的输出物是概要设计说明书，详细设计的输出物是详细设计说明书，编码的输出物是正确的、可维护的程序代码，测试的输出物是软件测试计划。</p><p>软件维护通常有四类维护活动：改正性维护、适应性维护、完善性维护、预防性维护。主要制品：版本更新的软件产品</p></blockquote><h3 id="可行性研究和需求分析"><a href="#可行性研究和需求分析" class="headerlink" title="可行性研究和需求分析"></a>可行性研究和需求分析</h3><p>可行性研究就是用最小的代价在尽可能短的时间内确定问题是否能够解决。</p><p>需求分析：软件定义时期的最后一步，基本任务是准确回答“系统必须做什么”这个问题，深入描述软件的功能和性能需求确定软件设计的约束和软件同其他系统元素的接口细节，定义软件的其他有效性需求。</p><p>需求分析需要遵循以下原则：深入浅出的原则和以流程为主线的原则。</p><p>软件需求分析四个阶段：获取需求、分析需求、定义需求、验证需求。</p><h3 id="典型的软件过程模型"><a href="#典型的软件过程模型" class="headerlink" title="典型的软件过程模型"></a>典型的软件过程模型</h3><p>软件生存期模型，又叫软件过程模型，是从软件项目的需求定义直至软件的运行维护为止，所实施的全部过程、活动和任务的结构框架。</p><h4 id="原型法模型"><a href="#原型法模型" class="headerlink" title="原型法模型"></a>原型法模型</h4><p>原型方法被定义为一种软件开发模型，在该模型中构建，测试原型，然后在需要时进行重新加工，直到获得可接受的原型。</p><p>分为六个步骤：需求收集和分析、快速设计、建立原型、使用者评估、精制原型、实施产品并进行维护。</p><p><img src="https://img.kancloud.cn/aa/6e/aa6ecfb26e3505358fbffbd3ae50cd39_920x227.png"></p><p>原型法最大的特点是允许需求或设计反复调查，减少开发中的风险和不确定性。</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>瀑布模型是软件过程模型的第一个模型。每个主要阶段都有相关的<strong>里程碑和可交付产品</strong>。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301153726.webp" alt="image-20231230115321545"></p><p>实际使用的瀑布模型是带反馈环的瀑布模型。</p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>该模型将瀑布模型和快速原型模型结合起来，并且加入了两种模型均忽略了的风险分析。有多少圈代表有多少个迭代原型，每一次迭代都会进行风险分析，然后做下一步工作。</p><p>基本思想是：使用原型及其他方法来尽量<strong>降低风险</strong>。</p><p>螺旋模型的示意图如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301157175.webp" alt="image-20231230115737004"></p><p>从左上角开始，分别是决定目标、风险评价、开发验证、测试评审。</p><h4 id="增量和迭代"><a href="#增量和迭代" class="headerlink" title="增量和迭代"></a>增量和迭代</h4><p>将软件产品分解成为一系列的增量构件，在增量开发中逐步加入。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301200410.webp" alt="image-20231230120039291"></p><p>在增量模型中，每一个构件都是可以交付的。</p><h4 id="敏捷开发方法和极限编程"><a href="#敏捷开发方法和极限编程" class="headerlink" title="敏捷开发方法和极限编程"></a>敏捷开发方法和极限编程</h4><p>敏捷开发认为：个体和交互胜过过程和工具；可工作软件胜过宽泛的文档；客户合作胜过合同谈判；响应变更胜过遵循计划。</p><p>12条敏捷原则：</p><ol><li>开发人员最优先要做的是通过尽早且持续地交付有价值的软件从而使客户满意。</li><li>即使到了开发的后期，也欢迎改变需求，敏捷过程利用变化为客户创造竞争优势。</li><li>经常性地交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。</li><li>在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。</li><li>围绕被激励起来的个体构建项目为开发人员提供所需的环境和支持，并且信任他们能够完成工作。</li><li>在团队内部，最具有效果并富有效率的传递信息的方法就是面对面的交谈。</li><li>工作的软件是首要的进度度量标准。</li><li>敏捷过程提倡可持续的开发速度，责任人、开发人员和用户应该能够保持一个长期且恒定的开发速度。</li><li>不断地关注优秀的技能和好的设计会增强敏捷能力。</li><li>简单是最根本的。</li><li>最好的构架、需求和设计出自于组织团队。</li><li>每隔一定时间团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。</li></ol><p>极限编程(eXtreme Programming, XP)是敏捷开发方法中最富有成效的几种方法学之一。具有强沟通、简化设计、迅速反馈等特点。</p><p>XP一般适用于规模小、进度紧张、需求不稳定、开发小项目的团队。</p><p>极限编程有四个核心要点：</p><ol><li>交流：都要交流</li><li>简单：设计、编码、测试从简</li><li>反馈：客户对软件、测试对代码的反馈</li><li>勇气：接受任务的勇气</li></ol><p>结对编程：简单来说就是两个程序员在同一台电脑前使用同一个键鼠工作。这样写出来的代码基本上是没有错误的</p><h4 id="能力成熟度模型CMM"><a href="#能力成熟度模型CMM" class="headerlink" title="能力成熟度模型CMM"></a>能力成熟度模型CMM</h4><p>CMM(Capability Maturity Model)共分为五级，CMMI(Capability Maturity Model Integration)是CMM的最新版本。</p><p>五个等级：初重定管优。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301213903.webp" alt="image-20231230121308789"></p><ul><li>初始级：过程无序且不可见。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301213651.webp" alt="image-20231230121355568"></p><ul><li>可重复级：里程碑可见，按计划开发。建立了基本的项目管理过程，对于类似的应用项目，有章可循。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301215773.webp" alt="image-20231230121502668"></p><ul><li>已定义级：每个阶段的内部活动可见，形成了标准化的软件过程。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301215025.webp" alt="image-20231230121556932"></p><ul><li>已管理级：过程可度量，预测值与结果之间的偏差可控。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301216946.webp" alt="image-20231230121647857"></p><ul><li>优化级：过程动态调整，采用最新技术，能够持续地对过程进行改进。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301217575.webp" alt="image-20231230121744464"></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><p>需求工程是指：应用已证实的原理、工具等，系统地描述待开发系统及其行为特征和相关约束。</p><p>需求工程包括：</p><ul><li>需求开发：收集整理需求、是变出需求的过程</li><li>需求管理：对需求的实现，是解决需求的过程</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401031107557.webp" alt="image-20240103110716334"></p><h3 id="需求的类型"><a href="#需求的类型" class="headerlink" title="需求的类型"></a>需求的类型</h3><p><strong>需求通常包含了三个层次：</strong></p><ul><li>业务需求：是需求定义的产物</li><li>用户需求：是需求捕获的产物</li><li>功能需求：是需求分析与建模的产物</li></ul><p><strong>需求的三种类型</strong></p><ul><li>功能需求</li></ul><p>强调从用户的角度，将系统理解为黑盒，从使用的角度整理需求</p><ul><li>非功能需求</li></ul><p>信息传递效率，扩展性等</p><ul><li>设计约束</li></ul><p>技术选型，软硬件环境，预计使用环境等</p><p><strong>两种需求文档</strong></p><p>需求定义：用户想得到的功能的完整列表</p><p>需求规格说明：关于构建的系统如何运转的说明，环境域和系统域的交集</p><blockquote><p>环境域是指系统所处的外部环境，包括与系统进行交互的外部实体、资源和条件。系统域是指规格所应用的系统本身，包括其组成部分、功能和性能。</p></blockquote><h3 id="常用的需求建模表示方法"><a href="#常用的需求建模表示方法" class="headerlink" title="常用的需求建模表示方法"></a>常用的需求建模表示方法</h3><h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><p>记住三种核心结构就好，后续演变成了UML图。</p><ol><li>实体：举行</li><li>关系：菱形</li><li>属性：椭圆</li></ol><h4 id="事件跟踪"><a href="#事件跟踪" class="headerlink" title="事件跟踪"></a>事件跟踪</h4><p>关注的是<strong>行为</strong>，每一个图描述一个跟踪，表示若干可能事件中的一个。</p><p>垂直线：不同实体的时间线，名字出现在顶部</p><p>水平线：两个实体之间的事件或交互</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312310020714.webp" alt="image-20231231002012586"></p><h4 id="消息时序图"><a href="#消息时序图" class="headerlink" title="消息时序图"></a>消息时序图</h4><p>扩充的事件跟踪表示法，功能更强。</p><ul><li>核心图形：竖线、横线箭头、矩形、六边形</li></ul><p>竖线表示参与的实体，一个消息描述为从发送实体到接受实体的箭头，动作表示为位于实体执行线上的带标记的矩形。条件是一个实体演化的重要状态，用有标记的六边形表示。</p><p>读法：找到箭头的起始点，从上到下</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312310024686.webp" alt="image-20231231002408507"></p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>一般的状态机只有两个图形：点和边，表示状态和事件。</p><p>UML中也有状态图，有一个起点，一个终点、圆角矩形，边。</p><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><p>描述了功能本身和功能之间的数据流。</p><p>图形有：</p><ul><li>泡泡：表示一个加工、功能、系统</li><li>箭头：数据流向</li><li>平行线：数据存储的库</li><li>矩形：参与者</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312310033377.webp" alt="image-20231231003311247"></p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>数据流图演变成了UML中的用例图。</p><p>图形：</p><ul><li>大方框：系统边界</li><li>方框外的小人：参与者、系统</li><li>方框内的椭圆：用例，表示必须的功能和变种</li><li>参与者和用力之间的连线：使用关系</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312310036845.webp" alt="image-20231231003621707"></p><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p>UML图主要包括了九种图形：</p><p>类对例列，协状活组部</p><h3 id="程序流图"><a href="#程序流图" class="headerlink" title="程序流图"></a>程序流图</h3><p>程序流图就是程序流程图。</p><ul><li><p>环路复杂度：程序流图中的环路的数量，设E为边数、N为节点数，则环路复杂度计算公式为：<code>C=E-N+2</code>。</p></li><li><p>独立路径：从起点到终点的所有可能路径数量，计算公式为<code>P=E-N+2C</code>。</p></li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>系统设计的两个阶段划分：（实际上就是软件生命周期的八大周期的两部分，问可需，概详编测维）</p><ul><li>概要设计</li></ul><p>任务：把需求分析得到的系统扩展用例图转换成为软件结构和数据结构，设计软件的结构、模块和调用关系。</p><p>产物：软件的架构图</p><ul><li>详细设计</li></ul><p>任务：对概要设计的一个细化，设计每个模块的算法、局部结构</p><p>产物：精确的、结构化的过程描述</p><blockquote><p>模块的扇入定义为直接上层模块数；扇出定义为直接下层模块的数目。</p></blockquote><h3 id="系统设计的度量"><a href="#系统设计的度量" class="headerlink" title="系统设计的度量"></a>系统设计的度量</h3><p>一个好的设计主要有三个特征：构件独立性、异常标识和处理、防错和容错技术。</p><p>构建的独立性就包括了耦合度和内聚度两个方面。一个好的软件应该是低耦合、高内聚的。</p><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>耦合度分为三个等级：高度耦合、松散耦合、非耦合。</p><p>构件之间的耦合度取决于：</p><ol><li>构件的引用（被其他构件引用的次数）</li><li>传递的数据量</li><li>控制其他构件的数量（控制和使用其他构件的数量）</li><li>构件之间的接口复杂程度</li></ol><p><strong>耦合的类型：</strong></p><p>数据耦合 &lt; 标记耦合 &lt; 控制耦合 &lt; 公共耦合 &lt; 内容耦合</p><ul><li>内容耦合：</li></ul><p>一个模块直接操作另外一个模块的数据，称为内容耦合。如：模块A有一个方法，直接读取模块B的一个数据变量c进行下一步操作，此时开发模块B的程序员将c变量删除或改名，则模块A直接崩溃。开发软件时绝不允许这种事情发生，但有些新手就能给你写出来，内容耦合也叫病态耦合。</p><ul><li>公共耦合：</li></ul><p>多个模块共同引用一个全局对象称为公共耦合。这个模块无法确定那个模块给全局变量赋了值，降低了程序的可读性。</p><ul><li>控制耦合：</li></ul><p>一个模块通过接口向另一个模块传递一个控制信号，即根据控制信号产生分支语句。如A类调用B类的方法，B类根据A类传入的参数值，决定执行那部分代码，则B依赖A，AB两个类产生控制耦合关系。</p><ul><li>标记耦合：</li></ul><p>标记耦合指两个模块之间传递的是数据结构，如高级语言的数组名、记录名、文件名等这些名字即为标记，其实传递的是这个数据结构的地址。</p><ul><li>数据耦合：</li></ul><p>两个模块之间有调用关系，传递的是简单数据值，是值传递。耦合度低，模块独立性好，模块间的影响最小。</p><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><p>构件的所有元素都是直接面向执行同一个任务并且是必须的，那么该构件是内聚的。</p><p>软件的内聚性是指模块内部各个元素之间的联系紧密程度。一个计算器程序中，所有与计算器相关的功能，如加减乘除，应该放在同一个模块中，而不应该与其他功能混在一起。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="测试的目标和衡量标准"><a href="#测试的目标和衡量标准" class="headerlink" title="测试的目标和衡量标准"></a>测试的目标和衡量标准</h3><p>测试的目标是发现错误。衡量标准就是有没有发现错误。。。</p><h3 id="测试的分类（组织）"><a href="#测试的分类（组织）" class="headerlink" title="测试的分类（组织）"></a>测试的分类（组织）</h3><p>测试的分类：</p><ol><li>单元测试(其中单元测试有七种)：又称模块测试，是针对软件设计的最小单位—-程序模块或功能模块，进行正确性检验的测试工作。其目的在于检验程序各模块是否存在各种差错，是否能正确地实现了其功能，满足其性能和接口要求。</li><li>集成测试(六种)：旨在检验软件单元之间的接口关系，以期望通过测试发现各软件单元接口之间存在的问题，最终把经过测试的单元组成符合设计要求的软件。</li><li>确认测试：验证软件的功能和性能及其它特性是否与用户的要求一致。</li><li>系统测试：与计算机硬件、外设、某些支持软件、人员、数据等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行一系列的组装测试和确认测试。</li><li>验收测试：以用户为主的测试，软件开发人员和质量保证人员参加，由用户设计测试用例。</li><li>回归测试：是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</li></ol><p>另有：</p><p>Alpha测试：用户在接近正式环境下的测试，开发人员在用户旁记录错误情况和使用中的问题。</p><p>Beta测试：多个用户在实际使用环境下的测试，开发人员不在测试现场，用户通过发送报告的形式把发现的问题反馈给开发人员。</p><p>(Alpha测试和Beta测试应该属于验收测试)</p><p><a href="https://zhuanlan.zhihu.com/p/628068059">冒烟测试</a>通常只测试软件的核心功能和主要功能点，不涉及细节。存在于测试中的每个阶段。</p><h3 id="黑盒-白盒测试"><a href="#黑盒-白盒测试" class="headerlink" title="黑盒&#x2F;白盒测试"></a>黑盒&#x2F;白盒测试</h3><p>又叫闭盒&#x2F;开盒测试。</p><ul><li>黑盒测试</li></ul><p>测试对象的功能；优点是免于测试对象受到内部逻辑的约束；缺点是不可能总是进行完备的测试。</p><ul><li>白盒测试</li></ul><p>测试对象的结构；包括<strong>代码覆盖率测试，路径覆盖测试和边界值测试等等</strong>，注重测试程序的逻辑结构。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试的主要内容有：</p><ol><li>语句测试</li><li>分支测试</li><li>路径测试</li><li>定义使用的路径测试</li><li>所有使用的测试</li><li>所有谓词使用&#x2F;部分计算使用的测试</li><li>所有计算使用&#x2F;部分谓词使用的测试</li></ol><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><ol><li>自底向上的测试</li><li>自顶向下的测试</li><li>一次性测试</li><li>三明治测试</li><li>改进的自顶向下测试</li><li>改进的三明治测试</li></ol><h2 id="系统维护"><a href="#系统维护" class="headerlink" title="系统维护"></a>系统维护</h2><h3 id="维护活动的类型"><a href="#维护活动的类型" class="headerlink" title="维护活动的类型"></a>维护活动的类型</h3><p>四种系统维护类型：</p><ul><li><p>改正性：维护日常功能</p></li><li><p>适应性：系统修改</p></li><li><p>完善性：完善已有系统</p></li><li><p>预防性：方式系统性能下降到不可接受的程度</p></li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401031654621.webp" alt="image-20240103165430461"></p><p>一个软件系统维护的工作量中，占比最大的是完善性维护。</p><h3 id="软件再生"><a href="#软件再生" class="headerlink" title="软件再生"></a>软件再生</h3><p>软件再生是一个重大工程，主要分为四个部分：重重工工</p><ul><li>文档重构：对源代码进行静态分析，给出更多信息到文档</li><li>重组：（重构）改变代码结构，但是不改变外部使用</li><li>逆向工程：对一项目标产品进行逆向分析及研究，得到规格说明书和设计等</li><li>再工程：对现有工程进行逆向工程，修改得到的规格说明书和设计，重新生成新的系统</li></ul><h2 id="UML图形"><a href="#UML图形" class="headerlink" title="UML图形"></a>UML图形</h2><p>UML是为软件系统的制品进行描述（<strong>specifying</strong>）、可视化（<strong>visualizing</strong>）、构造（<strong>constructing</strong>）、文档化（<strong>documenting</strong>）的一种语言。</p><h3 id="UML的4-1视图"><a href="#UML的4-1视图" class="headerlink" title="UML的4+1视图"></a>UML的4+1视图</h3><p>用例视图、设计视图、进程视图、实现视图、分布视图。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312311317390.webp" alt="image-20231231131702157"></p><ul><li>用例视图</li></ul><p>它定义系统的边界，关注的是使用者如何与系统交互。</p><ul><li>逻辑视图</li></ul><p>定义系统的实现逻辑设计词汇的逻辑结构、存在于他们之间的语义联系。</p><blockquote><p>对软件系统进行设计时，所产生的设计概念称为软件系统的设计词汇。设计词汇包括系统的类&#x2F;协同&#x2F;接口及其关系。</p></blockquote><ul><li>实现视图：</li></ul><p>描述组成一个软件系统的各个物理部件，以各种方式组合起来，构成了一个可实际运行的系统。</p><ul><li>部署试图：</li></ul><p>描述软件产品在计算机硬件系统和网络系统上的安装、分发、分布。</p><p>4+1视图与九种UML图形的对应关系：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401031207337.webp" alt="image-20240103120707088"></p><h3 id="UML九种图形"><a href="#UML九种图形" class="headerlink" title="UML九种图形"></a>UML九种图形</h3><p>多画多练多理解。&#x3D;&#x3D;类象例列，同状活组部&#x3D;&#x3D;。</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图中的所有元素如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011141411.webp" alt="image-20240101114120238"></p><ul><li>类的组成：2类元素(方形表示类，原型表示接口)，4种关系</li><li><ol><li>实线实箭头：泛化关系；</li><li>虚线实箭头：实现关系；</li><li>虚线虚箭头：依赖关系；</li><li>实线：关联关系(分为两种，无箭头的是双向关联，有箭头的是单向关联)</li></ol></li><li>&#x3D;&#x3D;实实泛化、虚实实现、虚虚依赖、实线关联&#x3D;&#x3D;</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011404254.webp" alt="image-20240101140331144"></p><p>类图包括类名、属性、操作三部分。</p><blockquote><p>在类图中, +表示public, -表示private, #表示protected</p><p>使用斜体字表示抽象元素的名称。</p></blockquote><p>关联关系：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011518185.webp" alt="image-20240101151829990"></p><p>泛化（继承或派生）关系的示例：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011509448.webp" alt="image-20240101150912308"></p><p>依赖关系：用到了就是依赖</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011517303.webp" alt="image-20240101151736107"></p><h4 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h4><p>对象图可以看成是类图的实例，比如下面这样的：</p><p>只需要写明属性值，不需要写方法值。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011525249.webp" alt="image-20240101152547128"></p><h4 id="用例图-1"><a href="#用例图-1" class="headerlink" title="用例图"></a>用例图</h4><p>用例图用于从外部使用者描述系统的功能，不包含内部实现。</p><p>用例图常用形状如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011640899.webp" alt="image-20240101164041793"></p><p>一个用例图demo如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011658142.webp" alt="image-20240101165843034"></p><p>用例图包括系统边界、执行者和用例三部分。用例一般是一个动词或动作，表示一个功能。</p><p>两个用例之间，一个用例的行为包含了另外一个用例，用&lt;&lt;include&gt;&gt;表示。</p><p>扩展用例可以在基础用例之上添加新的行为，使用&lt;&lt;extend&gt;&gt;表示。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401011657784.webp" alt="image-20240101165750565"></p><h4 id="序列图（顺序图）"><a href="#序列图（顺序图）" class="headerlink" title="序列图（顺序图）"></a>序列图（顺序图）</h4><p>元素如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401020937472.webp" alt="image-20240102093743302"></p><p>顺序图demo:</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401020938499.webp" alt="image-20240102093810387"></p><p>顺序图的四个组成部分：</p><ol><li>对象：顶部矩形</li><li>生存线：竖直虚线，一般和对象同时出现。当对象消亡的时候，使用一个”X”表示。</li><li>激活期：竖直矩形</li><li>消息：向右是调用，一般会有一个(pwd String)表示参数（实线，不同的箭头有不同的含义），向左是返回（虚线）。</li></ol><h4 id="协同图（协作图、通信图）"><a href="#协同图（协作图、通信图）" class="headerlink" title="协同图（协作图、通信图）"></a>协同图（协作图、通信图）</h4><p>通信图是顺序图的另外一种表现形式，用于描述相互协作的对象的交互关系和链接关系。</p><p>协作图的元素非常简单：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021018840.webp" alt="image-20240102101804755"></p><p>例如，一个银行取款用例的顺序图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021008935.webp" alt="image-20240102100807727"></p><p>可以改成如下图所示的协作图（通信图）</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021010741.webp" alt="image-20240102101023556"></p><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>元素有：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021017164.webp" alt="image-20240102101715069"></p><p>状态图用于描述一个特定的对象的所有可能状态及引发状态转换的事件，描述生命周期的行为。</p><p>例如，一个电梯对象的状态图如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021016416.webp" alt="image-20240102101608279"></p><h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><p>用来捕捉<strong>用例</strong>的活动，用框图的方法显示动作及其结果。</p><p>活动图的起点和终点与状态图相似，而活动图的整体结构又像一个程序流程图。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021023791.webp" alt="image-20240102102350688"></p><p>比如一个取款用例的活动图如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021024482.webp" alt="image-20240102102437307"></p><p><strong>泳道：</strong>用于对活动图中的活动进行分组，用于描述对象之间的合作关系。</p><h4 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h4><p>又叫构件图，用于描述软件的组件之间的关系，显示代码的静态结构。组件图中的文件分为三部分：</p><ol><li>源构件：</li><li>二进制构件：</li><li>可执行构件：</li></ol><p>元素：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021036308.webp" alt="image-20240102103638208"></p><p>组件图demo：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021037367.webp" alt="image-20240102103711208"></p><h4 id="部署图（分布图）"><a href="#部署图（分布图）" class="headerlink" title="部署图（分布图）"></a>部署图（分布图）</h4><p>部署图描述系统硬件的拓扑结构和软件的关系。</p><p>元素有：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021040752.webp" alt="image-20240102104025652"></p><p>部署图demo：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021042820.webp" alt="image-20240102104227685"></p><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>在面向对象的软件开发过程中，抽取和整理用户需求并建立问题域模型的过程叫面向对象分析（Object-Oriented Analysis，OOA）。该过程旨在确定系统的功能需求、性能需求、接口需求等，并使用面向对象的方式表示这些需求。在OOA过程中，通常会建立问题域模型，该模型包括问题域中的实体、关系、行为等。</p><p>七个重要原则：<strong>OCP, LSP, DIP, ISP, SRP, CRP, LoD</strong></p><ul><li><p><strong>LSP(The Liskov Substitution Principle)</strong>: 任意父类出现的地方，子类也可以出现。</p></li><li><p><strong>OCP(The Open-Close Principle)</strong>: 开发扩展、不要修改。在系统需求变化时，能够尽量少地修改已有的代码，而是通过扩展现有代码来满足新的需求。</p></li><li><p><strong>DIP(The Dependency Inversion Principle)</strong>: 针对抽象或者接口编程，高层模块和低层模块都应该依赖于共同的抽象，而不是相互依赖或高层依赖低层。</p></li><li><p><strong>ISP(The Interface Segregation Principle)</strong>: 使用多个专门的接口要优于使用单一的接口。</p></li><li><p><strong>SRP(The Single Responsibility Principle)</strong>: 类的职责单一。</p></li><li><p><strong>C(A)RP(Composite&#x2F;Aggregation Reuse Principle)</strong>: 优先使用组合或聚合关系，不要过度使用继承。</p></li><li><p><strong>LoD(Law of Demeter)</strong>: 迪米特原则(最少知道原则)，一个软件实体应当尽可能少地与其他实体发生相互作用</p></li></ul><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="补充的常用图形"><a href="#补充的常用图形" class="headerlink" title="补充的常用图形"></a>补充的常用图形</h3><ul><li>判定表：分析和表达多逻辑条件下执行不同操作的情况的工具，多用于测试。长这样：</li></ul><p><img src="https://bkimg.cdn.bcebos.com/pic/42166d224f4a20a48dfd6c499a529822730ed059?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto"></p><ul><li>数据流图(Data Flow Diagram, DFD)：用于描述系统中数据的流动、处理和存储。主要有以下元素：</li></ul><ol><li>数据流</li><li>进程</li><li>数据存储</li><li>外部实体</li></ol><ul><li><p>数据字典(Data Dictionary)：数据字典是一个集中的、结构化的文档或数据库，用于定义和描述系统中使用的数据元素。</p></li><li><p>IPO图：IPO是指结构化设计中变换型结构的输入（Input）、加工（Processing）、输出（Output）。IPO图是对每个模块进行详细设计的工具，它是输入加工输出（<code>INPUT PROCESS OUTPUT</code>）图的简称。用于描述输入、处理和输出数据的过程，长这样：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/107ceb7c7bc64e2f8b0216295835ccac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5ZCM5a2m6KaB5Yqq5Yqb,size_18,color_FFFFFF,t_70,g_se,x_16"></p><ul><li><p>PDL(过程设计语言)图：用于描述系统的程序设计逻辑，包括程序结构、数据类型、控制结构和算法等。它可以帮助设计人员和开发人员理解和实现系统的程序逻辑，提高程序的可读性和可维护性。是退化了的流程图。</p></li><li><p>甘特图：其通过条状图来显示项目、进度和其他时间相关的系统进展的内在关系随着时间进展的情况。常用于项目进度管理。</p></li></ul><h3 id="软件质量保证的措施"><a href="#软件质量保证的措施" class="headerlink" title="软件质量保证的措施"></a>软件质量保证的措施</h3><ol><li>应用好的技术方法</li><li>测试软件</li><li>进行正式的技术评审</li><li>标准的实施</li><li>控制变更</li><li>程序正确性证明</li><li>记录、保存和报告软件过程信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tag1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能计算与云计算复习</title>
      <link href="/2023/12/25/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/25/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="高性能计算与云计算复习"><a href="#高性能计算与云计算复习" class="headerlink" title="高性能计算与云计算复习"></a>高性能计算与云计算复习</h1><h2 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h2><p>互联网络分为静态互联网络和动态互联网络。</p><p>静态网络是指各节点之间有固定连接的一类网络。程序执行期间，网络连接不改变。动态网络是用开关单元构成的，可以动态改变连接状态的网络。</p><h3 id="静态互联网络的特征"><a href="#静态互联网络的特征" class="headerlink" title="静态互联网络的特征"></a>静态互联网络的特征</h3><ul><li><p>网络规模：网络的节点个数</p></li><li><p>节点度数：单向网络中，入射和出射边之和称为节点度</p></li><li><p>网络直径：任意两个节点之间的最长距离</p></li><li><p>对剖宽度：将网络对分所必须移除的边的数目，如果是奇数个的话理解成可以把某个点切开，如二叉树，N&#x3D;3的线性阵列</p></li><li><p>对称：从任何一个节点观看网络都一样，称为对称。（有限个网络的场景，网孔、线性阵列是非对称的）</p></li></ul><h3 id="静态互联网络特征比较"><a href="#静态互联网络特征比较" class="headerlink" title="静态互联网络特征比较"></a>静态互联网络特征比较</h3><table><thead><tr><th align="center">网络名</th><th align="center">网络规模</th><th align="center">节点度数</th><th align="center">网络直径</th><th align="center">对剖宽度</th><th align="center">对称</th><th align="center">链路数</th></tr></thead><tbody><tr><td align="center">线性阵列</td><td align="center">N</td><td align="center">2</td><td align="center">N-1</td><td align="center">1</td><td align="center">非</td><td align="center">N-1</td></tr><tr><td align="center">环形</td><td align="center">N</td><td align="center">2</td><td align="center">&#x3D;&#x3D;$\lfloor N&#x2F;2 \rfloor$&#x3D;&#x3D;</td><td align="center">2</td><td align="center">是</td><td align="center">N</td></tr><tr><td align="center">&#x3D;&#x3D;2D网孔&#x3D;&#x3D;</td><td align="center">$N&#x3D;n^2$</td><td align="center">4</td><td align="center">&#x3D;&#x3D;2(n-1)&#x3D;&#x3D;</td><td align="center">n</td><td align="center">非</td><td align="center">&#x3D;&#x3D;$2(N-n)$&#x3D;&#x3D;先补再减</td></tr><tr><td align="center">&#x3D;&#x3D;Illiac网孔&#x3D;&#x3D;</td><td align="center">$N&#x3D;n^2$</td><td align="center">4</td><td align="center">n-1</td><td align="center">2n</td><td align="center">非</td><td align="center">$2n$</td></tr><tr><td align="center">&#x3D;&#x3D;2D环绕&#x3D;&#x3D;</td><td align="center">$N&#x3D;n^2$</td><td align="center">4</td><td align="center">$2 \lfloor n&#x2F;2 \rfloor$</td><td align="center">2n</td><td align="center">是</td><td align="center">$2n$</td></tr><tr><td align="center">二叉树</td><td align="center">N</td><td align="center">3</td><td align="center">$2(\lceil log_2N \rceil-1)$</td><td align="center">1</td><td align="center">非</td><td align="center">N-1</td></tr><tr><td align="center">星型</td><td align="center">N</td><td align="center">n-1或1</td><td align="center">2</td><td align="center">$\lfloor N&#x2F;2 \rfloor$</td><td align="center">非</td><td align="center">N-1</td></tr><tr><td align="center">超立方</td><td align="center">$N&#x3D;2^n$</td><td align="center">$log_2N&#x3D;n$</td><td align="center">n</td><td align="center">N&#x2F;2</td><td align="center">是</td><td align="center">nN&#x2F;2</td></tr><tr><td align="center">k-立方环</td><td align="center">$N&#x3D;k*2^k$</td><td align="center">3</td><td align="center">$2k-1+\lfloor k&#x2F;2 \rfloor$</td><td align="center">N&#x2F;(2k)</td><td align="center">是</td><td align="center">3N&#x2F;2</td></tr></tbody></table><h2 id="并行计算的分类"><a href="#并行计算的分类" class="headerlink" title="并行计算的分类"></a>并行计算的分类</h2><h3 id="Flynn分类"><a href="#Flynn分类" class="headerlink" title="Flynn分类"></a>Flynn分类</h3><p>又叫指令流&#x2F;数据流分类法，即费林(Flynn)分类法。先来看一些概念：</p><ul><li>指令流：机器执行的指令序列</li><li>数据流：指令调用的数据序列，包括输入数据、中间结果等</li><li>多倍性：在系统性能平静部件上同时处于同一执行阶段的指令或数据的最大可能个数。</li></ul><p>于是，根据指令流和数据流的不同组织形式，将计算机系统分为四类：</p><ul><li>单指令单数据流（SISD）：硬件不支持任何形式的并行计算</li><li>单指令多数据流（SIMD）：有多个处理单元，按照同一指令流的要求为他们<strong>分配各不相同的数据流</strong>并进行处理。</li><li>多指令单数据流（MISD）：每个处理单元按照多条不同的指令要求<strong>同时对同一数据流作不同处理</strong>。</li><li>多指令多数据流（MIMD）：能将指令，数据任务等全方面并行计算的系统，将主任务分解成众多子任务以缩短时间。</li></ul><h3 id="MIMD计算机细分"><a href="#MIMD计算机细分" class="headerlink" title="MIMD计算机细分"></a>MIMD计算机细分</h3><p>MIMD计算机的主要分类如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272020214.webp" alt="image-20231227202042036"></p><p>共享内存和分布式内存的系统架构如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271451425.webp" alt="image-20231227145130232"></p><p>共享内存的工作原理：具有一个所有处理器都可以访问的全局物理内存，具备有如下性质：</p><ol><li>对称性：系统中的任何处理器等效访问内存和IO</li><li>单地址：内存中的每个位置都有唯一地址值</li><li>低通信延迟：处理器之间的通信可以利用共享内存来交换数据</li><li>高速缓存及其一致性：多级缓存可以提高速度，&#x3D;&#x3D;一致性由硬件来增强(?)&#x3D;&#x3D;</li></ol><p>两种模型的分类大致如下，下面将会详细介绍这五种内存访问模型：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271721645.webp" alt="image-20231227172148509"></p><h4 id="并行计算机五种访存模型"><a href="#并行计算机五种访存模型" class="headerlink" title="并行计算机五种访存模型"></a>并行计算机五种访存模型</h4><p>并行计算机访存模型主要有以下五种：</p><ul><li>UMA(Uniform Memory Access)：均匀存储访问模型</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271513171.webp" alt="image-20231227151312065"></p><p>共享内存属于一种经典的均匀访问模型。主要特点：**对称多处理(Symmetric Multiprocessing, SMP)**，使用的是微处理器和高速缓存。每台处理器可以带有私有的Cache，外围设备也可以共享。发生访存竞争的时候，仲裁策略对所有节点平等。所以叫做均匀存储访问模型。（就是计算机组成中的经典模型）</p><blockquote><p>在SMP中，内存模块和处理器对称地分布在互联网络的两侧。并且只有单一的操作系统镜像，负责处理各个处理器的负载，动态将进程分配到不同的处理器，保持各处理器之间的负载平衡。</p></blockquote><ul><li>NUMA(Non-Uniform Memory Access)：非均匀存储访问模型</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271528446.webp" alt="image-20231227152813342"></p><p>被共享的存储器在物理上是分布存储在所有处理器中的，其所有本地存储器的集合就组成了全局地址空间。处理器访问存储器的时间是不一样的。</p><blockquote><p>存储器的访问时间是指从发起访问请求到数据可用的时间间隔。简单理解就是，处理器访问离自己比较近的内存速度比其他内存更快。</p></blockquote><p>如果缓存一致性能够得到维护，那么就可以成为CC-NUMA，否则成为NCC-NUMA。</p><ul><li>CC-NUMA(Coherent-Cache Nonuniform Memory Access)：高速缓存一致性 非均匀存储访问模型</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271606334.webp" alt="image-20231227160607209"></p><p>CC-NUMA使用基于目录的高速缓存一致性协议；保留了SMP结构易于编程的优点，改善常规SMP的可扩放性。实际上是一个分布式共享存储的DSM多处理机系统，最显著的优点是程序员无需明确在节点上分配数据，在运行期间，高速缓存一致性硬件会自动将数据迁移到需要用到的地方。</p><ul><li>COMA(Cache-Only Memory Access)：全高速缓存存储访问</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271618283.webp" alt="image-20231227161837118"></p><p>COMA各个处理器节点&#x3D;&#x3D;没有存储层次结构&#x3D;&#x3D;。对比NUMA和CC-NUMA，发现：COMA只有cache，NUMA只有memory，CC-NUMA二者兼有，而UMA则是将内存连接在总线上的。</p><ul><li>NORMA(No-Remote Memory Access)：非远程存储访问模型。属于分布式内存模型。</li></ul><p>架构图如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271625818.webp" alt="image-20231227162538671"></p><p>优点：内存可以随着CPU的数量进行等比例扩展；各个处理器可以无冲突地快速访问自己的内存，不存在维护缓存一致性的开销；可以使用商用、现成的处理器和网络。</p><p>局限性：程序员要负责所有处理器之间的数据通信细节问题；很难从基于全局内存空间建立其分布式内存管理的映射，写一个程序有一个全局的地址空间，程序员需要建立全局地址空间到分布式内存的管理，也就是解决什么数据去哪里取的问题；非一致性的内存访问时间使远程节点访问比本地节点访问需要更长的时间。</p><h4 id="大规模并行处理机-Massively-Parallel-Processor-MPP"><a href="#大规模并行处理机-Massively-Parallel-Processor-MPP" class="headerlink" title="大规模并行处理机(Massively Parallel Processor, MPP)"></a>大规模并行处理机(Massively Parallel Processor, MPP)</h4><p>由大规模的紧密互联的节点组成，内存访问属于非远程存储访问模型(NORMA)，也就是属于分布式存储系统。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271952272.webp" alt="image-20231227195214091"></p><p>每个节点配有局部cache，并通过局部总线与局部内存、局部IO相连，通过互联网络与IO相连。各节点之间的内存模块相互独立，且不存在全局内存单元的统一硬件编址。</p><p>每个节点都有不同的操作系统映像。</p><p>仅支持消息传递等程序设计（如MPI），不支持全局共享的OpenMP并行程序设计模式。</p><h4 id="集群（机群）"><a href="#集群（机群）" class="headerlink" title="集群（机群）"></a>集群（机群）</h4><p>集群是一种松耦合的计算机组成方式，采用分布式存储，每一个节点是完整的计算机。</p><p>集群的优点是：投资风险小、系统结构灵活、能充分利用分散的计算资源</p><p>集群的缺点是：通信性能和并行编程环境不佳</p><p>和MPP的比较如下图，左边是MPP，右边是Cluster，重点关注：有无磁盘、总线类型</p><p>Cluster有磁盘，MPP没有；Cluster各点连接在IO总线(IOB)上，而MPP各点连接在存储总线MB上。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271959198.webp" alt="image-20231227195911973"></p><h4 id="DSM-Distributed-Shared-Memory"><a href="#DSM-Distributed-Shared-Memory" class="headerlink" title="DSM(Distributed Shared Memory)"></a>DSM(Distributed Shared Memory)</h4><p>属于非一致性内存访问模型(NUMA)，<strong>内存模块放在各个节点的内部，并且被所有节点共享</strong>。这样，可以较好改善多处理共享存储并行机的可扩展能力。</p><p>节点之间通过高性能互联网络连接，内存模块分布在各节点中，避免了SMP中的访问总线的带宽瓶颈。具有单一的内存地址空间（硬件统一编址，各个节点可以相互访问）。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272012397.webp" alt="image-20231227201214227"></p><p><code>注意和MPP对比，多了一个DIR：Cache Directory。</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>各种访存模型：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272020214.webp" alt="image-20231227202042036"></p><p>五种结构特性：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272022765.webp" alt="image-20231227202227550"></p><h2 id="并行计算模型-LogP重点"><a href="#并行计算模型-LogP重点" class="headerlink" title="并行计算模型(LogP重点)"></a>并行计算模型(LogP重点)</h2><p>将并行计算机的基本特征抽象出来，形成一个抽象的计算模型，作为并行算法分析、设计和性能预测的基础。</p><p>主要的并行计算模型有：PRAM模型、BSP模型和logP模型。</p><ul><li><strong>PRAM模型</strong>：又称SIMD-SM模型，有一个集中的共享存储器和一个指令器，通过SM的R&#x2F;W交换数据，隐式同步计算。模型的架构图如下：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281427027.webp" alt="image-20231228142714882"></p><p>优点是适合并行算法的表示和复杂性分析，易于使用，隐藏了并行机的通讯、同步等区别。</p><p>缺点是不适合MIMD并行机，忽略了SM的竞争、通讯延迟等因素。</p><ul><li><strong>BSP模型</strong></li></ul><p>“块”同步模型，异步MIMD-DM模型，支持消息传递系统，块内异步并行，块间显式同步。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281435932.webp" alt="image-20231228143521823"></p><ul><li><strong>LogP模型（重点掌握）</strong></li></ul><p>一种分布存储的、点到点通讯的多处理机模型，其中通讯由一组参数描述，实行隐式同步。</p><p>模型参数：</p><ol><li>L: latency网络延迟</li><li>o: 接收和发送时间</li><li>g: gap&#x3D;1&#x2F;bandwidth，两个连续通信的最小间隔</li><li>P: 处理器数量</li></ol><p>前面三个都是表示时间的参数，它们之间的关系如下图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281441216.webp" alt="image-20231228144121112"></p><p>点到点通信事件：L+2o</p><p>读取远程地址：2L+4o</p><h2 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h2><h3 id="算法性能评测"><a href="#算法性能评测" class="headerlink" title="算法性能评测"></a>算法性能评测</h3><ul><li><p>加速比：$S_p&#x3D;\dfrac{串行执行时间}{并行执行时间}$</p></li><li><p>并行效率：$E&#x3D;\dfrac{加速比}{核数}$</p></li></ul><p>由于通信等因素，一般来说并行效率不会超过1。如果超过了1，那就是超线性加速比。那么什么时候会出现超线性加速比呢？</p><p>可能出现超线性加速比的成因主要是不同处理器的高速缓存足以提供计算需要的存储量，属于硬件特性。</p><p>不同约束条件下的加速比：</p><ol><li>固定问题规模</li><li>固定时间</li><li>固定存储</li></ol><h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p><strong>描述了规模固定的加速比。</strong></p><p>该定律指出，系统中对于某一部件采用更快的执行方式所能获得的性能改进程度，取决于这种执行方式被使用的频率。</p><p>$W_s$是串行化部分运行的时间，$W_p$是并行化部分采用串行化的方法需要的时间。<strong>f是使用串行化的任务占比</strong>，p是并行核数。</p><p>$S_{pc}&#x3D;\dfrac{优化前耗时}{优化后耗时}&#x3D;\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}&#x3D;\dfrac{f+(1-f)}{f+\frac{1-f}{p}}&#x3D;\dfrac{p}{1+f(p-1)}$，当p-&gt;$\infin$时，等于$1&#x2F;f$。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281607856.webp" alt="image-20231228160723744"></p><p>例如，上图中，f&#x3D;1&#x2F;3，p&#x3D;2，那么加速比就是：Spc&#x3D;6&#x2F;5，也就是300&#x2F;250。</p><p>增强的Amdahl定律，考虑了并行和通信的开销，推导式如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281628586.webp" alt="image-20231228162841483"></p><p>所以，Amdahl定律用一句话总结就是：&#x3D;&#x3D;并行计算模型的加速比不会超过串行化占比的倒数&#x3D;&#x3D;。</p><h3 id="Gustafson定律"><a href="#Gustafson定律" class="headerlink" title="Gustafson定律"></a>Gustafson定律</h3><p>描述了时间固定的加速比。</p><p>Gustafson定律也表明处理器个数、并行比例和加速比之间的关系。它描述了，<strong>在串行部分比例固定的前提下，加速比会随着处理器个数增加而增加</strong>。</p><p>见公式Amdahl推导式的$\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}$，当p变大的时候，加速比自然变大，但是有渐近线逼近。</p><p>考虑到并行开销的Gustafson定律，了解即可。</p><h3 id="Sun-Ni定律"><a href="#Sun-Ni定律" class="headerlink" title="Sun&amp;Ni定律"></a>Sun&amp;Ni定律</h3><p>描述了存储受限的加速比。</p><p>推导公式：$\begin{aligned}S_{MC}&#x3D;\frac{Work(p)&#x2F;Time(p)}{Work(l)&#x2F;Time(l)}&#x3D;\frac{fW+(1-f)G(p)W}{fW+(1-f)G(p)W&#x2F;p}&#x3D;\frac{f+(1-f)G(p)}{f+(1-f)G(p)&#x2F;p}\end{aligned}$</p><p>当G(p)&#x3D;1的时候就是Amdahl加速定律，G(p)&#x3D;p时变为f+p(1-f)，就是Gustafson加速定律。</p><h3 id="可扩展性评测标准"><a href="#可扩展性评测标准" class="headerlink" title="可扩展性评测标准"></a>可扩展性评测标准</h3><p>增加系统规模（处理器个数）会增大额外开销和降低处理器利用率，所以对于一个特定的并行处理系统（算法或程序），它们能否有效利用不断增加的处理器的能力应是受限的，而度量这种能力的就是可扩展性这一指标。可扩展性更关心在&#x3D;&#x3D;系统规模和数据规模&#x3D;&#x3D;变化时的&#x3D;&#x3D;执行时间&#x3D;&#x3D;，是{性能、系统规模、数据规模}的综合量度。</p><p>可扩展性的三种量化方式：</p><ul><li>等效率&#x3D;$\dfrac{加速比}{处理器数}$，分析简单</li><li>等速度：每秒处理的数据量，便于通过实验数据得到结果。</li><li>平均时延：理想并行时间和实际并行时间的差距，便于通过实验数据得到结果。</li></ul><h4 id="等效率函数"><a href="#等效率函数" class="headerlink" title="等效率函数"></a>等效率函数</h4><p>考虑有并行开销的并行效率，加速比$\begin{aligned}S&#x3D;\dfrac{T_e}{T_p}&#x3D;\dfrac{T_e}{\dfrac{T_e+T_o}p}&#x3D;\dfrac{P}{1+\dfrac{T_o}{T_e}}&#x3D;\dfrac{P}{1+\dfrac{W_o}W}\end{aligned}$，等效率：$\begin{aligned}E&#x3D;\frac{S}{P}&#x3D;\frac{1}{1+\dfrac{T_o}{T_e}}&#x3D;\frac{1}{1+\dfrac{W_o}{W}}\end{aligned}$。</p><p>如果保持问题规模W不变，处理器数目p增加，开销$T_o$增大，$W_o$增大，效率E下降。为了维持等效率，在增加处理器的时候，问题规模W也应该增大。</p><p>下图是等效率曲线。曲线1表示可扩放性较好，曲线2表示算法可以扩放，曲线3表示算法不可扩放。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291508752.webp" alt="image-20231229150855542"></p><p>按照等效率函数的定义，对于某一并行算法(或并行程序),为了维持运行效率保持不变，随着处理器数目的增加，若只需增加较小的工作量(即问题规模),比如说$W$随$P$呈线性或亚线性增长，则表示该算法具有良好的可扩放性；若需增加非常大的问题规模，比如说$W$随$P$呈指数级增长，则表示该算法是不可扩放的。</p><h2 id="PCAM设计方法学"><a href="#PCAM设计方法学" class="headerlink" title="PCAM设计方法学"></a>PCAM设计方法学</h2><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291902876.webp" alt="image-20231229190206700"></p><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>划分可以分为两类划分：<strong>域分解（数据分解）和功能分解</strong>。域分解划分的是数据，功能分解划分的是计算。</p><p>划分之后，研究不同任务所需要的数据。如果这些数据不相交，则划分是成功的，否则需要重新进行域分解。</p><p>划分的标准：</p><ul><li>划分的任务数，是否至少高于目标机上处理器数量一个量级。（灵活性）若否，则后续的设计步骤缺少灵活性。</li><li>是否避免冗余的计算和存储要求（可扩放性）若否，算法的扩放性较差。</li><li>划分的任务尺寸是否大致相当（均衡）若否，分配处理器时难以做到工作量均衡。</li><li>任务数是否与问题尺寸成正比，理想情况下，问题尺寸的增加应该引起任务数的增加而不是任务尺寸的增加。</li></ul><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>功能分解决定了各个任务之间的数据流，各任务是并发执行的，通信则限制了这种并发性。</p><p>四种通信模式：<strong>局结态步</strong></p><ul><li>局部&#x2F;全局通信</li></ul><p>局部通信是指通信限制在一个邻域内，只与较少的几个近邻通信。</p><p>全局通信是指许多任务参与的通信，例如星型，全相联的图。</p><ul><li>结构化&#x2F;非结构化通信</li></ul><p>结构化通信：每个任务的通信模式是相同的。</p><p>非结构化通信：每个任务的通信模式不同，无统一的结构。</p><ul><li>静态&#x2F;动态通信</li></ul><p>静态通信是指通信伙伴的身份不会随着时间的改变而改变的通信。</p><p>动态通信伙伴的身份由计算时的数据决定，并且是可变的。</p><ul><li>同步&#x2F;异步通信</li></ul><p>同步通信：双方知道何时进行通信，发送方显式地发给接收方</p><p>异步通信：接收方明确的从发送方请求数据。</p><p>了解通信的标准。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合是抽象到具体的过程，使得任务在同一类并行机上有效地执行。</p><p>合并小尺寸的任务，减少任务数，如果任务数恰好等于处理器数量，也就完成了映射的过程。</p><blockquote><p>通信量与任务子集的表面成正比，计算量与任务子集的体积成正比。</p></blockquote><p>增加重复计算有可能减少通讯量。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>每个任务需要映射到具体的处理器上，定位到运行机器上，存在负载均衡和任务调度的问题。实际上是一个NP完全问题。</p><p>映射的目标：减少算法的执行时间。主要有两点原则:</p><ol><li>并发的任务：分配到不同的处理器</li><li>高通信的任务：分配到相同的处理器</li></ol><ul><li>负载均衡的算法：</li></ul><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>有三种并行算法，分别是简单分块算法、Cannons算法和DNS算法，主要学习Cannon矩阵乘法。</p><h3 id="Cannon矩阵乘法"><a href="#Cannon矩阵乘法" class="headerlink" title="Cannon矩阵乘法"></a>Cannon矩阵乘法</h3><ul><li><p>起始对准：A矩阵第i行左移i位（i从0开始），B矩阵第i列上移i位（i从0开始）。</p></li><li><p>循环位移：每次A向左移动，B向上移动一个单位，再做一次乘法然后相加。</p></li></ul><h2 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h2><p>OpenMP是&#x3D;&#x3D;共享存储体系&#x3D;&#x3D;上的一个编程模型，应用于unix, Windows等多种平台上。OpenMP的API是基于&#x3D;&#x3D;编译制导&#x3D;&#x3D;，具备简单、移植性好和可扩展等优点，是共享存储系统编程（主要针对SMP平台）的一个工业标准。</p><blockquote><p>编译制导（compiler directive）是一种特殊的注释或指令，用于指导编译器在源代码的编译过程中进行特定的处理或优化。</p></blockquote><p>OpenMP使用FORK-JOIN并行执行模型，所有的OpenMP程序开始于一个单独的主线程，直到遇见第一个并行域，然后并行域中的代码在不同的线程组中并行执行(FORK)。当各个线程在并行域执行完成之后，最后只有主线程在执行(JOIN)。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301611127.webp" alt="image-20231230161102974"></p><h3 id="OpenMP基本用法"><a href="#OpenMP基本用法" class="headerlink" title="OpenMP基本用法"></a>OpenMP基本用法</h3><p>当计算机上安装了gcc之后，就可以直接开始OpenMP编程了。下面是一个hello_world代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nthreads,tid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">/* 编译制导语句 */</span></span><br><span class="line">    <span class="meta"># <span class="keyword">pragma</span> omp parallel private(nthreads,tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid=omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World from thread %d\n&quot;</span>,tid);</span><br><span class="line">        <span class="keyword">if</span>(tid==<span class="number">0</span>)&#123;</span><br><span class="line">            nthreads=omp_get_num_threads();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Number of threads = %d\n&quot;</span>,nthreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private(nthreads, tid)</code>: 这个子句定义了私有变量。在并行执行期间，每个线程都会拥有自己的私有副本。在这个例子中，<code>nthreads</code>和<code>tid</code>是私有变量,私有副本避免了竞争条件。其中由<code># pragma omp</code>开头的语句就是编译制导语句，编译制导语句格式解释如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301635717.webp" alt="image-20231230163502200"></p><p>并行域的写法如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301641289.webp" alt="image-20231230164110177"></p><p>一个并行域就是一个能够被多个进程执行的程序块当一个线程运行到parallel的时候，会创建一个线程组并成为该组的主线程，tid为0。当并行域开始时，程序代码被复制，&#x3D;&#x3D;每个线程都会执行该代码&#x3D;&#x3D;。</p><p>并行的线程数按照如下因素决定，优先级递减：</p><ol><li>使用库函数omp_set_num_threads</li><li>设置环境变量OPM_NUM_THREADS</li><li>由实现决定的默认值</li></ol><h3 id="共享任务结构"><a href="#共享任务结构" class="headerlink" title="共享任务结构"></a>共享任务结构</h3><p>共享任务结构将它所包含的代码划分给线程组内各个成员执行，不产生新的线程，在共享任务结构的入口处没有路障，但是在任务结束处有一个隐含的路障。共享任务结构有三种类型：</p><ol><li>for：线程组共享一个循环，表现出“数据并行性”</li><li>sections：把任务分成离散段，每段由一个线程执行，表现“功能并行性”</li><li>single：串行执行一段代码</li></ol><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301657319.webp" alt="image-20231230165746202"></p><h4 id="for结构"><a href="#for结构" class="headerlink" title="for结构"></a>for结构</h4><p>语句格式：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301700572.webp" alt="image-20231230170039469"></p><p>schedule子句描述如何将循环的迭代划分给线程组中的线程。其参数type为static类型的时候，循环会被划分成大小为chunk的块，静态分配给各线程，若未指定chunk，则会被尽可能均衡地划分。</p><p>下面是一个使用for结构并行计算一个向量的案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> a[N],b[N],c[N];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        a[i]=b[i]=c[i]=i*<span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 使用for结构之前必须先初始化并行域</span></span><br><span class="line">    <span class="meta"># <span class="keyword">pragma</span> omp parallel shared(a,b,c) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta"># <span class="keyword">pragma</span> omp for schedule(dynamic,CHUNKSIZE) nowait</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            c[i]=a[i]+b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="section结构"><a href="#section结构" class="headerlink" title="section结构"></a>section结构</h4><p>sections编译制导语句是非迭代共享任务结构，指定内部的代码划分给线程组中的各线程。嵌套在sections语句中的每个section编译制导语句，由线程组中的一个线程执行。</p><p>语句格式：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301737971.webp" alt="image-20231230173719857"></p><p>使用两个section计算向量加法，分别计算前后半段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> a[N],b[N],c[N];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        a[i]=b[i]=c[i]=i*<span class="number">1.0</span>;</span><br><span class="line">    <span class="meta"># <span class="keyword">pragma</span> omp parallel shared(a,b,c) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta"># <span class="keyword">pragma</span> omp sections nowait</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta"># <span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)</span><br><span class="line">                a[i]=b[i]+c[i];</span><br><span class="line">            <span class="meta"># <span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span>(i=N/<span class="number">2</span>;i&lt;N;i++)</span><br><span class="line">                a[i]=b[i]+c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="single结构"><a href="#single结构" class="headerlink" title="single结构"></a>single结构</h4><p>single编译制导的语句制定内部的代码只有线程组中的一个线程执行，对于非线程安全的代码（比如输入&#x2F;输出），这个语句比较有用。除非是用了nowait语句，否则线程组中没有执行single语句的线程会一直等到代码块结束。</p><p>代码格式：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301747222.webp" alt="image-20231230174735115"></p><h4 id="parallel-for"><a href="#parallel-for" class="headerlink" title="parallel for"></a>parallel for</h4><p>创建一个并行域并包含一个for语句，也就是把parallel和for结合起来。</p><h4 id="parallel-section"><a href="#parallel-section" class="headerlink" title="parallel section"></a>parallel section</h4><p>创建一个并行域并包含一个sections语句。</p><h3 id="同步结构"><a href="#同步结构" class="headerlink" title="同步结构"></a>同步结构</h3><ul><li>master</li></ul><p>master语句指定的代码段将只由主线程执行，该线程组中的其他线程将忽略该代码段。</p><ul><li>critical</li></ul><p>critical指定的代码段在同一时刻只能有一个线程执行。</p><ul><li>barrier</li></ul><p>barrier语句用来同步线程组中的所有线程，在barrier语句处先到达的线程将会被阻塞，直到所有线程到达。</p><ul><li>atomic</li></ul><p>指定的存储单元将被原子地更新，而不允许多个线程同时执行更新操作。</p><ul><li>flush</li></ul><p>用于表示一个同步点，确保所有线程都看到一致的存储器视图。</p><ul><li>ordered</li></ul><p>被指定地代码段如同在船形的处理器上执行，任何时候只能有一个线程执行被ordered所限定的部分。只能出现在for中。</p><ul><li>reduction</li></ul><p>语法<code>reduction([ reduction-modifier, ] reduction-identifier : list)</code>。归约（reduction）操作用于将多个线程或进程计算得到的部分结果合并为一个最终结果，可以看成是一个不会丢失修改的多线程加法。</p><h3 id="计算PI的openMP程序"><a href="#计算PI的openMP程序" class="headerlink" title="计算PI的openMP程序"></a>计算PI的openMP程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> steps = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">double</span> step;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> pi, sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> start, delta;</span><br><span class="line">    step = <span class="number">1.0</span>/(<span class="type">double</span>) steps;</span><br><span class="line">    <span class="comment">// 从1到MAX_THREADS循环，每次循环设置线程数，计算PI值</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;= MAX_THREADS; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; running on %d threads: &quot;</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程数</span></span><br><span class="line">        omp_set_num_threads(j);</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> start = omp_get_wtime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        reduction(+:sum)：变量sum被声明为共享变量，通过+操作符进行归约。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum) private(x)</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; steps; i++) &#123;</span><br><span class="line">            x = (i+<span class="number">0.5</span>)*step;</span><br><span class="line">            sum += <span class="number">4.0</span> / (<span class="number">1.0</span>+x*x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算PI值</span></span><br><span class="line">        pi = step * sum;</span><br><span class="line">        delta = omp_get_wtime() - start;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PI = %.16g computed in %.4g seconds\n&quot;</span>, pi, delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MPI编程"><a href="#MPI编程" class="headerlink" title="MPI编程"></a>MPI编程</h2><p>MPI(Message Passing Interface)是&#x3D;&#x3D;分布存储并行模型&#x3D;&#x3D;下的一个消息传递接口。MPI不是一个独立的自包含系统，而是建立在本地并行程序设计环境之上，进程管理和IO均由本地并行程序设计环境提供的。</p><h3 id="安装、编译、运行"><a href="#安装、编译、运行" class="headerlink" title="安装、编译、运行"></a>安装、编译、运行</h3><p>安装：以Debian为例，使用apt安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install mpich</span><br></pre></td></tr></table></figure><p>编译：使用mpicc编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicc -o out/$1 $1.c</span><br></pre></td></tr></table></figure><p>运行：使用mpirun运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np $2 out/$1</span><br></pre></td></tr></table></figure><p>可用参数：</p><p>-np：指定进程数</p><p>-host：指定主机列表</p><p>-npernode：每个计算节点的进程数</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>一个MPI程序有六个基本函数：</p><ul><li>MPI启动：调用该函数进入MPI环境，完成初始化工作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Init</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> ***argv)</span></span><br></pre></td></tr></table></figure><ul><li>MPI结束：调用该函数从MPI环境中退出，是MPI程序的最后一个调用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Finalize</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><ul><li>获取进程编号：获取当前进程在指定通信域中的编号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *rank)</span><span class="comment">// 结果存储在rank中，而不是返回值的int</span></span><br></pre></td></tr></table></figure><ul><li>获取进程数：获取指定通信域中的进程个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *size)</span><span class="comment">// 结果存储在size中</span></span><br></pre></td></tr></table></figure><ul><li>消息发送：MPI_send函数用于发送一个消息到目标进程，将起始地址为buf的count个datatype类型的数据发送给目标进程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, <span class="type">int</span> dest, <span class="type">int</span> tag, MPI_Comm comm)</span></span><br></pre></td></tr></table></figure><ul><li>消息接收：MPI_Recv用于接收数据，如果数据大于缓冲区，则会</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Recv</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, <span class="type">int</span> source, <span class="type">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span><br></pre></td></tr></table></figure><p>MPI_Comm是MPI中表示通信域（communication domain）的数据类型。它用于定义进程之间的通信关系，指定通信操作的参与进程组。通信域可以是全局通信域(MPI_COMM_WORLD)或自定义的子通信域。通信域定义了一组进程，它们可以通过发送和接收消息进行相互通信。</p><p>MPI_Status是MPI中表示通信状态的数据类型。它用于在MPI通信操作中存储有关消息的信息，如发送者、接收者、消息长度等。定义如下，了解即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MPI_Status</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count_lo;</span><br><span class="line">    <span class="type">int</span> count_hi_and_cancelled;</span><br><span class="line">    <span class="type">int</span> MPI_SOURCE;</span><br><span class="line">    <span class="type">int</span> MPI_TAG;</span><br><span class="line">    <span class="type">int</span> MPI_ERROR;</span><br><span class="line">&#125; MPI_Status;</span><br></pre></td></tr></table></figure><p>一个MPI程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rank, size, tag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sendData, recvData = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MPI相关接口</span></span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);               <span class="comment">// MPI初始化</span></span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); <span class="comment">// 该进程的编号</span></span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size); <span class="comment">// 总进程数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sendData = <span class="number">9999</span>;</span><br><span class="line">        <span class="comment">// MPI发送信息</span></span><br><span class="line">        MPI_Send(&amp;sendData, <span class="number">1</span>, MPI_INT, <span class="number">1</span>, tag, MPI_COMM_WORLD); <span class="comment">// 发送数据到进程1</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d进程发送\n&quot;</span>, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MPI接收信息</span></span><br><span class="line">        MPI_Recv(&amp;recvData, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, tag, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d进程接收到：%d\n&quot;</span>, rank, recvData);</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Docker和hadoop"><a href="#Docker和hadoop" class="headerlink" title="Docker和hadoop"></a>Docker和hadoop</h2><p><strong>Hadoop</strong> 是一个开源的分布式计算框架，它可以处理大规模数据集并将其分配到多台计算机上进行处理。Hadoop主要掌握两个核心组件、Map&#x2F;Reduce的思想。</p><p>Hadoop的两个核心，就是HDFS和MapReduce。HDFS为海量数据提供了<strong>存储</strong>，而MapReduce为海量数据提供了<strong>计算框架</strong>。</p><p>Hadoop的生态圈示意图如下：</p><img src="https://www.eduxiji.net/assets/files/2020-04-30/1588236269-937828-hadoop-0.png" /><h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map&#x2F;Reduce"></a>Map&#x2F;Reduce</h3><ul><li>整体结构：</li></ul><p><code>extends Mapper&lt;Object, Text, Text, IntWritable&gt;</code>，四个范型参数是输入键、输入值、输出键、输出值。</p><p>重写<code>void map(Object key, Text value, Context context)</code>。</p><p><code>extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;</code>，四个范型参数是输入键、输入值、输出键、输出值。</p><p>重写<code>void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)</code>。</p><ul><li>两种数据类型：</li></ul><p><code>IntWritable</code>整形，<code>Text</code>表示字符串，这两种数据结构可以放在context中。</p><ul><li>处理逻辑：</li></ul><p>map函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringTokenizer</span> <span class="variable">itr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(value.toString());</span><br><span class="line"><span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">    word.set(itr.nextToken());</span><br><span class="line">    context.write(word, one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">    sum += val.get();</span><br><span class="line">&#125;</span><br><span class="line">result.set(sum);</span><br><span class="line">context.write(key, result);</span><br></pre></td></tr></table></figure><p>主函数：JJ,MCR,KV,IO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"><span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf, <span class="string">&quot;word count&quot;</span>);</span><br><span class="line">job.setJarByClass(WordCount.class);</span><br><span class="line"></span><br><span class="line">job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">job.setReducerClass(IntSumReducer.class);</span><br><span class="line"></span><br><span class="line">job.setOutputKeyClass(Text.class);</span><br><span class="line">job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">FileInputFormat.addInputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">System.exit(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker是开源的容器引擎。容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。</p><blockquote><p>和虚拟机的区别：</p><p>部署速度、资源消耗、隔离性、部署管理</p></blockquote><p>服务器虚拟化由多种技术架构，其中主要的四种如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181751512.webp" alt="image-20231018173203055"></p><p>云计算关键技术：</p><p>虚多弹分分</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web应用开发</title>
      <link href="/2023/12/17/Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/12/17/Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Web应用开发的课程笔记。<span id="more"></span></p><h1 id="Web应用开发"><a href="#Web应用开发" class="headerlink" title="Web应用开发"></a>Web应用开发</h1><h2 id="Web基础知识"><a href="#Web基础知识" class="headerlink" title="Web基础知识"></a>Web基础知识</h2><h3 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h3><ul><li>DOM：文档对象模型，是独立于平台的内容和结构。一个HTML的所有元素的表示模型就是一个DOM，表现为一个多层级的树</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312172039300.webp" alt="image-20231217203929130"></p><ul><li>BOM：浏览器对象模型，独立于内容且可以和浏览器交互的对象。</li></ul><p>BOM的层次如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecec85dcf1ff4f27a815685189feaccf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote><p>协议组成，常见状态码，常用方法</p></blockquote><p>HTTP工作三大特点：无连接，媒体独立，无状态的</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312172029094.webp" alt="image-20231217202900899"></p><p>八种请求类型：GET, POST, PUT, DELETE, OPTIONS, HEAD, TRACE, CONNECT</p><blockquote><p>HTTP请求：由请求行（请求方式、资源路径、所用HTTP版本），请求头，实体内容</p><p>HTTP响应：由响应状态行、响应头、实体内容</p></blockquote><h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><p>四种引入方式：行内式、内嵌式、外链式、导入式。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312200116795.webp" alt="image-20231220011604673"></p><blockquote><p>外链式和导入式都是引入外部CSS代码的方法，异同在于：</p><p>外链式：使用&lt;link href&#x3D;””&gt;标签引入，导入式使用@引入，例如&lt;style&gt;@import “css&#x2F;hello.css”&lt;style&gt;</p></blockquote><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>这是一个测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/myCss.css&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: blue&quot;</span>&gt;</span>行内式写法：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在标签后面加上 style=&quot;属性:值&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>例如：style=&quot;color: blue&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 内嵌式：将代码集中写在head标签中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>head<span class="symbol">&amp;gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>style type=&quot;text/css&quot;<span class="symbol">&amp;gt;</span></span><br><span class="line">            h1&#123; text-align: center&#125;</span><br><span class="line">    <span class="symbol">&amp;lt;</span>/style<span class="symbol">&amp;gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>/head&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>外链式<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h3><p>js的三种引入方式：行内式、内嵌式和外链式。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;css/myCss.css&quot;</span> type=<span class="string">&quot;text/css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/my.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        function <span class="title function_">neiqian</span><span class="params">()</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;这是内嵌式写的&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h2 id="Servlet教程"><a href="#Servlet教程" class="headerlink" title="Servlet教程"></a>Servlet教程</h2><h3 id="第一个Servlet"><a href="#第一个Servlet" class="headerlink" title="第一个Servlet"></a>第一个Servlet</h3><p>使用一个自己实现的Servlet类实现HttpServlet，然后重写doGet，doPost，doPut，每当有HTTP请求到达对应的路径的时候，就会调用对应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet运行测试</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;/TestServlet0&quot;, urlPatterns = &#123;&quot;/hello&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Test Servlet 0&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet的配置"><a href="#Servlet的配置" class="headerlink" title="Servlet的配置"></a>Servlet的配置</h3><p>使用web.xml可以对Servlet进行配置，步骤如下：</p><ol><li>使用&lt;servlet&gt;标签进行注册，在该标签下包含若干个元素，如&lt;servlet-name&gt;,&lt;servlet-class&gt;等。</li><li>把Servlet映射到URL地址，使用&lt;servlet-mapping&gt;标签定义映射，使用&lt;servlet-name&gt;指定需要映射的Servlet，然后使用&lt;url-pattern&gt;子标签进行URL地址，地址前必须加”&#x2F;“。</li></ol><p>例如，我们把上面的@WebServlet配置去掉，改用web.xml配置，实现如下：</p><p>注意，servlet必须配置name和class两个参数，class用于指定实现类，name用于和mapping建立映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>Servlet01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用注解配置时，value和urlPatterns通常是二选一，通常是忽略value，使用urlPattern，见文知意。</p></blockquote><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>Servlet有三个生命周期：初始化，运行和销毁。</p><p>要想测试生命周期，必须实现GenericServlet，重写init()，service()和destroy接口。</p><ul><li>当第一次访问&#x2F;Servlet02对应的Servlet的时候，init()函数会被调用</li><li>每一次访问该页面，都会调用service()服务（包括刷新）</li><li>当停止程序的时候，调用destroy()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;/TestServlet02&quot;, urlPatterns = &#123;&quot;/Servlet02&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet02</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>在Servlet运行期间，常常需要一些配置，例如编码等等。使用ServletConfig类可以对Servlet进行初始化和默认参数的管理。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;/Servlet03&quot;, urlPatterns = &#123;&quot;/Servlet03&quot;&#125;,initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        PrintWriter out=httpServletResponse.getWriter();</span><br><span class="line">        ServletConfig config=<span class="built_in">this</span>.getServletConfig();</span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;encoding=&quot;</span>+param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet类中有一个getServletConfig方法，返回的是一个ServletConfig类的对象。上述例子使用了注解@WebInitParam方法实现了参数初始化，将encoding设置为UTF-8。除了上述方法外，还可以使用web.xml配置参数。例子如下：</p><p>首先配置xml的参数：注意context-param要写在servlet之前</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>param2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>Servlet01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后获取xml中的配置并打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;Servlet04&quot;,urlPatterns = &quot;/servlet04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet04</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        res.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out=res.getWriter();</span><br><span class="line">        ServletContext context=<span class="built_in">this</span>.getServletContext();</span><br><span class="line">        Enumeration&lt;String&gt; paramsNames=context.getInitParameterNames();</span><br><span class="line">        out.println(<span class="string">&quot;参数是&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(paramsNames.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> paramsNames.nextElement();</span><br><span class="line">            String value=context.getInitParameter(name);</span><br><span class="line">            out.println(name+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190003311.webp" alt="image-20231219000256150"></p><p>获取路径：HttpServlet-&gt; ServletContext-&gt; getInitParameterNames获取names的枚举值，然后调用context.getInitParameter。</p><h4 id="多个Servlet共享数据"><a href="#多个Servlet共享数据" class="headerlink" title="多个Servlet共享数据"></a>多个Servlet共享数据</h4><p>首先写一个Servlet05，重写doGet请求，调用context.setAttribute设置上下文属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;Servlet05&quot;,urlPatterns = &quot;/servlet05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet05</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span>&#123;</span><br><span class="line">        ServletContext context=<span class="built_in">this</span>.getServletContext();</span><br><span class="line">        context.setAttribute(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;this is a data from me&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个Servlet06，获取attribute，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;Servlet06&quot;,urlPatterns = &quot;/servlet06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet06</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> res.getWriter();</span><br><span class="line">        String data=(String) <span class="built_in">this</span>.getServletContext().getAttribute(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用servlet05，再调用servlet06，运行结果如下图：</p><p><img src="C:/Users/19481/AppData/Roaming/Typora/typora-user-images/image-20231219002124686.png" alt="image-20231219002124686"></p><h4 id="读取Web应用下的资源文件"><a href="#读取Web应用下的资源文件" class="headerlink" title="读取Web应用下的资源文件"></a>读取Web应用下的资源文件</h4><p>资源文件包括.properties文件等。示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;Servlet07&quot;,urlPatterns = &quot;/servlet07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet07</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        res.setContentType(<span class="string">&quot;text/html,charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out= res.getWriter();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> context.getResourceAsStream(<span class="string">&quot;veni.properties&quot;</span>);</span><br><span class="line">        Properties properties=<span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        out.println(<span class="string">&quot;Name=&quot;</span>+properties.getProperty(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">        out.println(<span class="string">&quot;City=&quot;</span>+properties.getProperty(<span class="string">&quot;City&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>类图如下，不作过多讲解。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190111467.webp" alt="image-20231219011108143"></p><p>获取请求信息和请求头就直接调函数即可，下面讲讲请求重定向。</p><ul><li>请求重定向：两次请求，请求不同的资源</li></ul><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>类图如下，根据函数名即可作用。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190109846.webp" alt="image-20231219010924558"></p><ul><li>请求转发：一次请求，通过ServletContext共享。</li></ul><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Servlet规范有三个高级特性，Filter，Listener，以及文件的上传下载。Filter用于修改request和response，Listener用于监听context, session, request事件。</p><p><img src="https://th.bing.com/th/id/R.1cc9c9543e2604300e2181353caa438a?rik=aMy/fSlsWHGavw&riu=http://tutorials.jenkov.com/images/java-servlets/servlet-filters-1.png&ehk=6s4rd3wKOrfdMwhy537QCgFAA8ohUM6Znq00xw92x84=&risl=&pid=ImgRaw&r=0" alt="Use of filters in Servlet"></p><p>Servlet Filter是过滤器，由多个Filter组成Filter链，只有通过所有过滤器的请求才能进入Servlet。</p><blockquote><p>拦截器是Servlet内部的处理方法，而Filter是Servlet外部的拦截器。</p></blockquote><ul><li>Filter接口</li></ul><p>该接口定义了init()，doFilter()方法和destroy()方法。</p><ul><li>FilterConfig接口</li></ul><p>在Filter初始化的时候，服务器将FilterConfig对象作为参数传递给Filter初始化方法。</p><ul><li>FilterChain接口</li></ul><p>该接口的doFilter()方法调用Filter，</p><h4 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h4><p><strong>创建阶段-&gt;执行阶段-&gt;销毁阶段</strong></p><h4 id="实现Filter"><a href="#实现Filter" class="headerlink" title="实现Filter"></a>实现Filter</h4><p>使用@WebFilter配置需要拦截的资源，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/filter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// 如果路径匹配，就会执行这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        servletResponse.getWriter().println(<span class="string">&quot;Filter&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>在Web开发中，经常需要对某些事件进行监听。为此，Servlet提供了监听器，专门监听Servlet事件。</p><p>监听过程的组成部分：</p><ol><li>事件：用户的操作，如创建对象，调用方法，创建对象等。</li><li>事件源：产生事件的对象。</li><li>事件监听器</li><li>事件处理器</li></ol><p>事件监听器的过程分为以下步骤</p><ol><li>注册监听器：将监听器绑定到事件源</li><li>监听器监听到事件发生，会调用监听器的成员方法</li><li>事件处理器通过实践对象获得事件源，并对事件源进行处理</li></ol><p>例如，实现一个自动插入审计字段的函数，当执行mapper的时候，调用Listener处理，更新时间等。</p><p>例如，一个监听器的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>, HttpSessionListener, ServletRequestListener &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(javax.servlet.ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;requestDestroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(javax.servlet.ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;requestInitialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><ul><li><p>使用Cookie类，该类仅有一个构造函数：参数为(String name, String value)。一个cookie就是一个带有过期时间等属性的KV对。</p></li><li><p>获取请求的cookies：使用HttpServletRequest类的getCookies()，返回Cookie[]，见上面的类图。</p></li><li><p>设置响应的cookie：使用HttpResponse的addCookie，见类图。注意这里的add不会叠加，只是在返回时更新浏览器的本地cookies。</p></li></ul><h3 id="Session技术"><a href="#Session技术" class="headerlink" title="Session技术"></a>Session技术</h3><p>当浏览器访问Web服务的时候，Servlet容器就会创建一个Session对象和ID属性。Session对象就相当于病例档案，而SessionId就是病例档案号。</p><p>Session只会在用户第一次访问JSP，Servlet等应用的时候才会创建。</p><ul><li>Session的实现为HttpSession，是一个Java Interface，定义如下图：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312191017177.webp" alt="image-20231219101738007"></p><p>可以看到，里面有一个servletContext的成员变量，而interface中的变量都是final的，因此该context不可重新赋值。由于Servlet默认启用session技术，所以在浏览器中的cookies栏都会有一个JSESSIONID。</p><ul><li>HttpServletRequest方法中定义了一个获取Session对象的getSession()函数用于返回当前请求的HttpSession对象。有两个重载形式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpSession <span class="title function_">getSession</span><span class="params">(<span class="type">boolean</span> create)</span>;</span><br><span class="line"><span class="keyword">public</span> HttpSession <span class="title function_">getSession</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//实际上就是默认参数</span></span><br><span class="line"><span class="keyword">public</span> HttpSession <span class="title function_">getSession</span><span class="params">(<span class="type">boolean</span> create=<span class="literal">true</span>)</span>;</span><br></pre></td></tr></table></figure>  如果create为true，那么在HttpSession对象不存在的时候创建一个新的HttpSession，为false返回null。第二个方法默认为true。</li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP知识点如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312191913166.webp" alt="JSP"></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>基本声明和包导入，使用contentType声明文件类型等信息，一般而言IDE会自动完成</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>基本结构：声明和引入完成之后，就是html主体,包括html标签下的head和body等标签。一个完整的jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.text.SimpleDateFormat&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;JSP显示系统时间&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String today= df.format(date);</span><br><span class="line">    %&gt;</span><br><span class="line">    当前时间：&lt;%=today%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP脚本元素"><a href="#JSP脚本元素" class="headerlink" title="JSP脚本元素"></a>JSP脚本元素</h3><h4 id="JSP-Scriptlets"><a href="#JSP-Scriptlets" class="headerlink" title="JSP Scriptlets"></a>JSP Scriptlets</h4><p>Scriptlets就是一个代码段，可以编写java的程序语句。使用格式如下。在Scriptlets中可以进行属性的定义，也可以输出内容，但是无法声明函数。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% java code %&gt;</span><br></pre></td></tr></table></figure><p>声明函数的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! java code %&gt;</span><br></pre></td></tr></table></figure><p>在声明代码段中的函数在整个JSP页面都可以生效，包括多次打开和关闭，除非关闭服务器。</p><h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><p>JSP指令用于配置页面中的一些信息。例如</p><ul><li>page指令：用于指定某个jsp页面的属性和引入java包。常用的page属性有：language，import，contentType。</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li>include指令：实际开发中，有时候会要在一个jsp页面中包含另一个jsp页面，这时候可以通过include指令实现。Include一般使用相对路径。</li><li>taglib指令：可以使用该指令标识页面中所使用的标签库。</li></ul><h3 id="JSP动作元素"><a href="#JSP动作元素" class="headerlink" title="JSP动作元素"></a>JSP动作元素</h3><ul><li>&lt;jsp:include page&#x3D;”” flush&#x3D;””&gt;用于向当前页面引入其他页面的文件，&lt;% @include file &#x3D; “” %&gt;，动态与静态的区别。</li><li>&lt;jsp:forward&gt;将当前请求转发到其他的Web资源，类似Servlet中的request.forward()，因为JSP本质上也是一个Servlet。</li></ul><h3 id="JSP隐式对象"><a href="#JSP隐式对象" class="headerlink" title="JSP隐式对象"></a>JSP隐式对象</h3><p>JSP有9个隐式对象，分别是：out, request, response, config, session, application, page, pageContext, exception。</p><h2 id="EL和JSTL"><a href="#EL和JSTL" class="headerlink" title="EL和JSTL"></a>EL和JSTL</h2><h3 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h3><p>Expression Language，语法格式。</p><p>EL的核心格式就是”${}”</p><p>EL提供了11个隐式对象，这些对象类似于JSP的隐式对象</p><h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p>Java server pages standard tag library，JSP标准标签库，用于替代Java的部分关键字，在页面中处理部分业务逻辑。</p><p>JSTL必须使用JSP的taglib指令来指定标签库。标签库本质上是取代在html中嵌入Java代码的，因此具备逻辑处理能力。</p><blockquote><p>JSTL包含五类标准标签库，分别是核心标签库、国际化&#x2F;格式化标签库、SQL标签库、XML标签库和函数标签库。</p><p>简记为：核、国、S、X、函。</p></blockquote><ul><li>&lt;c:out value&#x3D;”” default&#x3D;””&gt;标签&lt;&#x2F;c:out&gt;，用于输出元素。</li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>常用API：</p><ul><li>Driver接口：所有JDBC程序必须实现的接口，专门给数据库厂商使用。</li><li>DriverManager类：用于加载JDBC驱动并且建立与数据库的连接。有两个比较重要的静态方法：</li></ul><ol><li>registerDriver(Driver driver);注册数据库驱动</li><li>getConnection(String url, String user, String pwd);建立连接返回Connection对象。</li></ol><p>连接数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forname(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure><p>这样一个连接就建立完成了。</p><ul><li>Statement接口：用于执行静态的SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.createStatement();</span><br><span class="line">ResultSet rs=stmt.excute(<span class="string">&quot;select * from users&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">int</span> id=GetInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String name=GetString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ResultSet：用于保存查询结果，可以保存单条或多条，使用rs.next()遍历。</p></li><li><p>PreparedStatement接口：封装了JDBC执行SQL语句的方法，完成Java调用SQL的功能。</p></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring的优良特性"><a href="#Spring的优良特性" class="headerlink" title="Spring的优良特性"></a>Spring的优良特性</h3><ul><li>非侵入式：基于Spring开发的应用程序对象可以不依赖于Spring的API。举个例子，使用Spring initializr初始化了一个Spring项目，但是可以不使用Spring风格的注解写Controller，可以使用Servlet写。</li><li>控制反转IoC：将对象的创建权交给Spring，以前都是我们手动创建对象，现在是由Spring创建。常常使用容器管理，这些容器使用反射、配置文件或注解来定义对象之间的依赖关系，并提供了自动注入依赖的机制。例如，使用@Bean之类的方法控制反转，类会成为一个Bean，当有需要的时候，会自动创建（如@Resource，@Autowired等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepositoryImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当注册为Bean的时候，可以在其他地方有需要时自动引入。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(userRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>依赖注入DI：实现控制反转的一种方法，指的是依赖的对象不需要手动调用set方法设置，而是通过配置赋值。例如Spring的JDBC连接，将对应的配置文件写好，然后在任何地方都可以调用@Mapper等方法实现。</p></li><li><p>面向切面编程AOP：用于将横切关注点（cross-cutting concerns）与核心业务逻辑分离。横切关注点指的是那些在应用程序中多处重复出现的功能，例如日志记录、事务管理、安全性检查等。例如，可以使用AOP的思想自动设置时间等审计字段的更新。</p></li><li><p>容器化与组件化：容器化是指Spring包含并管理对象的生命周期，组件化是指通过各种组件配置组合形成一个复杂的应用，使用xml或注解组合对象。</p></li><li><p>一站式：可以整合各种框架和第三方库，实际上Spring自身也提供了表述层的SpringMVC和持久层的Spring JDBC。</p></li></ul><blockquote><p>表述层是指应用程序中处理用户请求和生成响应的部分。它负责将用户的输入转化为可理解的数据，并将处理结果以适合用户的方式进行呈现。</p></blockquote><p>Spring 可以使开发人员使用 <strong>POJOs</strong> 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 <strong>EJB</strong> 容器产品（企业级JavaBeans），比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</p><blockquote><p>POJO是”Plain Old Java Object”的缩写，它是一种简单的Java对象，没有任何特殊要求或限制。POJO是一种纯粹的普通Java对象，不依赖于任何特定的框架、接口或类库。</p></blockquote><h3 id="Spring框架体系结构"><a href="#Spring框架体系结构" class="headerlink" title="Spring框架体系结构"></a>Spring框架体系结构</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312192150920.webp" alt="image-20231219214854914"></p><p>最下层是Test模块，然后是Core Container模块。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312192151924.webp" alt="image-20231219215119695"></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL食用指南</title>
      <link href="/2023/12/15/WSL%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2023/12/15/WSL%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>这是一个WSL开发的使用指南，可以享受Linux的开发环境和Windows的办公环境（主要是买不起Mac）。下面是使用WSL开发的基本指南。<span id="more"></span></p><h1 id="WSL食用指南"><a href="#WSL食用指南" class="headerlink" title="WSL食用指南"></a>WSL食用指南</h1><h2 id="基础配置篇"><a href="#基础配置篇" class="headerlink" title="基础配置篇"></a>基础配置篇</h2><p>CentOS已经停止维护，推荐使用Debian，轻量且稳定。</p><p>要想使用Debian开发，需要完成下面几件事情：</p><ol><li>更换apt源，阿里源或者清华源都可（如果是云服务器则不需要手动换源，一般对应厂商已经换好）。</li><li>apt install build-essentials，各种开发的基础。</li></ol><p>换源教程：</p><ul><li><p>安装Debian 12.0(bookworm)，执行<code>apt update</code>更新apt。</p></li><li><p>下载https支持：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure><ul><li>修改清华源：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib</span></span><br><span class="line"></span><br><span class="line">deb https://security.debian.org/debian-security bookworm-security main contrib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://security.debian.org/debian-security bookworm-security main contrib</span></span><br></pre></td></tr></table></figure><ul><li>再次执行<code>apt update</code></li><li>下载必要的编译环境，这是各类开发包的基础，如不安装，则无法安装其他部分SDK。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure><p>之后就可以按需安装需要的软件了</p><h2 id="开发篇"><a href="#开发篇" class="headerlink" title="开发篇"></a>开发篇</h2><h3 id="网络调试"><a href="#网络调试" class="headerlink" title="网络调试"></a>网络调试</h3><p>使用WSL开发后端，进行接口调试的时候可以有多种方式。</p><h4 id="IDE端口转发"><a href="#IDE端口转发" class="headerlink" title="IDE端口转发"></a>IDE端口转发</h4><p>一种是直接使用IDEA(或其他IDE的类似功能)的端口转发。如下图所示：将2345端口转发到主机的13151端口，之后调用localhost:13151端口访问。每次启动都会改变端口，推荐前端使用此方法调用，例如开发Vue等项目需要运行的时候，可以使用本机浏览器测试。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312152331769.webp" alt="image-20231215233103387"></p><h4 id="使用netsh-interface-portproxy转发"><a href="#使用netsh-interface-portproxy转发" class="headerlink" title="使用netsh interface portproxy转发"></a>使用netsh interface portproxy转发</h4><p>另外一种是放行WSL的防火墙，进行接口调试。这种方法设置的ip长期有效，端口固定，在使用APIFOX的时候不用每次都修改端口号。推荐后端开发使用此方法。步骤如下：</p><p>查看WSL的ip地址：<code>ip address</code>：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312152340280.webp" alt="image-20231215234033137"></p><p>修改Windows网络转发规则：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=<span class="number">5354</span> listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> connectport=<span class="number">5354</span> connectaddress=<span class="number">172</span>.<span class="number">18</span>.<span class="number">157</span>.<span class="number">129</span></span><br></pre></td></tr></table></figure><p><code>listenport</code>, 表示要监听的 Windows 端口<br><code>listenaddress</code>, 表示监听地址, 0.0.0.0 表示匹配所有地址, 比如Windows 既有Wifi网卡, 又有有线网卡, 那么访问任意两个网卡, 都会被监听到,当然也可以指定其中之一的IP的地址<br><code>connectaddress</code> ,要转发的地址, 这里设置为localhost, 是因为,我们可以通过localhost来访问WSL2, 如果暂不支持, 这里需要指定为 WSL2的IP地址<br><code>connectport</code>, 要转发到的目标端口，即虚拟机监听的端口</p><blockquote><p>推荐转发的端口以2xxxx命名，与To同音，例如28080, 28088, 26379</p></blockquote><p>附netsh的常用指令：</p><p>查看端口转发：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure><p>删除端口转发：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenport=<span class="number">5354</span> listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这个时候，对于本机而言，使用127.0.0.1:5354访问和使用172.18.157.129:5354访问的结果是一样的，都可以正常访问WSL中启动的后端项目。</p><ul><li>局域网访问：使用防火墙配置入站规则，放行对应端口后，重启电脑即可。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312160029651.webp" alt="image-20231216002903288"></p><h4 id="使用容器转发"><a href="#使用容器转发" class="headerlink" title="使用容器转发"></a>使用容器转发</h4><p>使用容器,来配置web服务,显然是最佳选择,这个时候你就会遇到本文的问题,因为你可能希望让其他主机来访问你的容器服务!但是还未实践，此处略过。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Sangfor】深信服产品介绍与最佳实践</title>
      <link href="/2023/10/18/%E3%80%90Sangfor%E3%80%91%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%B6%85%E8%9E%8D%E5%90%88HCI/"/>
      <url>/2023/10/18/%E3%80%90Sangfor%E3%80%91%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%B6%85%E8%9E%8D%E5%90%88HCI/</url>
      
        <content type="html"><![CDATA[<p>通过本文，你将了解到深信服产品的技术以及学习深信服产品的最佳实践，包括HCI、aDesk、EDS和AD等产品。。<span id="more"></span></p><h1 id="深信服超融合HCI"><a href="#深信服超融合HCI" class="headerlink" title="深信服超融合HCI"></a>深信服超融合HCI</h1><h2 id="HCI产品简介"><a href="#HCI产品简介" class="headerlink" title="HCI产品简介"></a>HCI产品简介</h2><h3 id="HCI产品基础"><a href="#HCI产品基础" class="headerlink" title="HCI产品基础"></a>HCI产品基础</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211628796.webp" alt="image-20231021162852689"></p><p>深信服HCI(Hyper-Converged Infrastructure)定位云平台的软硬件，聚焦服务器、虚拟化、数据中心和交付等。深信服的HCI只需要通用的服务器和交换机软件，就可以利用软件技术构建计算、存储、网络和安全的统一资源池，实现基础架构的简化。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181936850.webp" alt="image-20231018193613643"></p><p>与传统的云基础架构（烟囱架构）相比，HCI只需要两种设备即可实现IT的基础要求，而传统的云平台需要服务器、存储设备、网络设备等等，维护成本高，运维复杂。</p><p>深信服HCI具有极简、可靠、高性能、更安全等特点。</p><p>深信服HCI的应用场景：</p><ul><li>新建数据中心</li><li>数据中心改造场景</li><li>CPU应用承载</li><li>K8S应用承载</li></ul><h3 id="HCI关键特性"><a href="#HCI关键特性" class="headerlink" title="HCI关键特性"></a>HCI关键特性</h3><p>深信服HCI关键特性可以由下图概括：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181951996.webp" alt="image-20231018195137766"></p><p>包括了安全特性，平台特性和高可用性等方面。</p><h4 id="aSV服务器虚拟化"><a href="#aSV服务器虚拟化" class="headerlink" title="aSV服务器虚拟化"></a>aSV服务器虚拟化</h4><p>aSV是深信服服务器虚拟化技术，具备了<strong>热迁移、HA高可用、动态资源调度DRS和动态资源添加DRX</strong>的四个基础功能。还有一些其他的优势特性和功能。</p><p>aSV（包括其他的服务器虚拟化）解决了什么问题？</p><ol><li>提供资源利用率：一台服务器可以运行多台虚拟机，彼此独立运行，互不影响</li><li>提高扩展能力：根据负载情况手动调整资源</li><li>提高生产效率：硬件故障、软件故障（重装系统）等速度快</li><li>提高业务可用性：热迁移保障可用性</li><li>提高运维效率：硬件资源、虚拟机资源可视化和统一管理</li></ol><h5 id="热迁移"><a href="#热迁移" class="headerlink" title="热迁移"></a>热迁移</h5><p>热迁移保障了业务的高可用性，当管理员需要进行硬件维护、主机变更等操作的时候，aSV可以在不影响业务的情况下完成迁移操作。</p><ul><li>关键技术：无需外置存储、零宕机时间、兼容外部存储</li><li>支持场景：集群内热迁移、集群内跨存储热迁移、跨集群热迁移</li></ul><h5 id="HA-High-Availability-高可用"><a href="#HA-High-Availability-高可用" class="headerlink" title="HA(High Availability)高可用"></a>HA(High Availability)高可用</h5><p>HA（High Availability）高可用是指在系统或服务出现故障时，能够保持持续可用性和稳定性的能力。HA的目标是确保系统的连续性，最小化服务中断和数据丢失的风险。虚拟机实现HA的前提条件：</p><ol><li>虚拟化集群服务器不少于2台。</li><li>必须配置共享存储（磁盘阵列、分布式存储均可）。</li><li>剩余主机必须有足够的资源供业务恢复使用。</li></ol><blockquote><p>在软件质量架构中，”Availability”（可用性）属性是指系统或应用程序在所需的时间内正常运行和提供服务的能力。它是衡量系统可靠性和可用性的重要指标之一。</p></blockquote><p>应用场景：虚拟机系统异常卡死、操作系统无响应，虚拟机蓝屏、黑屏等等。</p><p>虚拟机HA实现了当业务故障的时候自动、迅速切换到另外的云计算资源上，保持业务的高可用，业务恢复耗时在分钟级。</p><ul><li>分布式管理平台</li><li>平台内置WAF等安全功能</li><li>同意可视化资源管理和运维</li><li>纳管VMware和业务双向迁移</li><li>集群环境一键检测</li><li>行业应用向导</li></ul><h4 id="aSAN存储虚拟化"><a href="#aSAN存储虚拟化" class="headerlink" title="aSAN存储虚拟化"></a>aSAN存储虚拟化</h4><p>aSAN(Storage Area Network)深信服分布式存储的技术，是一款自主开发的分布式存储系统，利用虚拟化技术“池化”集群存储卷内的磁盘，实现存储资源统一管理，向上提供NFS&#x2F;iSCSI存储接口，广泛应用于HCI，aDesk和EDS三大系统。</p><p>aSAN具备防脑裂仲裁机制，但是集群内必须部署3台以上的设备。读一下脑裂的定义就明白了，如果只有两台主机，那么顶多有一条边。当子节点无法通讯的时候，相当于删除一条边，那么集群就分裂成为了两个独立的子集群。</p><blockquote><p>脑裂（brain split）是指在分布式计算环境中，发生了网络或硬件故障导致集群中的节点无法相互通信，从而导致集群分裂成多个独立的子集。这种情况下，每个子集都认为其他子集中的节点已经失效，因此会独立地继续运行和处理任务。</p></blockquote><h5 id="数据副本机制"><a href="#数据副本机制" class="headerlink" title="数据副本机制"></a>数据副本机制</h5><p>主要功能特征：</p><ol><li>每份数据在存储层保留2-3副本</li><li>副本所存放的位置必须满足主机互斥原则，不能将两个副本同时存放在同一台主机上（不然一台物理主机崩溃就会丢失全部数据）</li><li>支持以虚拟机或虚拟磁盘为单位设置副本，支持灵活修改副本数</li></ol><h5 id="数据快速重建"><a href="#数据快速重建" class="headerlink" title="数据快速重建"></a>数据快速重建</h5><ul><li>应用场景：</li></ul><p>当集群内硬盘或主机出现故障，部分数据处于单副本状态，可以通过故障重建的方式恢复损坏的数据。</p><ul><li>可容忍的故障程度：</li></ul><p>两副本：可容忍集群内单台主机硬盘全部故障</p><p>三副本：可容忍集群内两台主机硬盘全部故障，可容忍集群内非同一主机下2块硬盘故障</p><ul><li>特性：</li></ul><ol><li>全局参与，多并发：从多个源端磁盘读取，往多个目的磁盘写入</li><li>智能重建：根据上层的I&#x2F;O情况动态调整重建所用的I&#x2F;O</li><li>分级重建：优先保障重要数据，分等级上传</li></ol><h5 id="亚健康检测和处理"><a href="#亚健康检测和处理" class="headerlink" title="亚健康检测和处理"></a>亚健康检测和处理</h5><p>亚健康介质包括慢盘、坏道过多、寿命到期的SSD等等，亚健康对于系统的危害十分严重。</p><p>处理方法：</p><ol><li>读写算法降级：降低算法的优先级，不在从该盘读写</li><li>亚健康数据迁移：将数据迁到健康的介质</li><li>主动对坏道扫描：及时修理</li></ol><h5 id="克隆技术"><a href="#克隆技术" class="headerlink" title="克隆技术"></a>克隆技术</h5><ul><li>链接克隆：利用快照技术，基于原镜像生成<strong>映射关系</strong>秒级拉起虚拟机，缺点是存在依赖关系，有额外性能开销</li><li>全量克隆：基于原计算克隆一份新的镜像后开机，缺点是启动速度满</li><li>快速全量克隆：利用快照技术拉起虚拟机后，持续拷贝原镜像数据，拷贝完成后，脱离依赖关系</li></ul><h5 id="高性能技术——磁盘分卷"><a href="#高性能技术——磁盘分卷" class="headerlink" title="高性能技术——磁盘分卷"></a>高性能技术——磁盘分卷</h5><p>将多个硬盘分成不同的卷，深信服的分卷包括全闪卷和混闪卷。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182120588.webp" alt="image-20231018212026173"></p><h5 id="高性能技术——存储分层"><a href="#高性能技术——存储分层" class="headerlink" title="高性能技术——存储分层"></a>高性能技术——存储分层</h5><p>分层是aSAN缓存系统中最主要的性能层，SSD分层的核心思想是：</p><ol><li>写操作可以快速地写入分层中，立即向上返回写入成功，然后再将数据写到HDD中。</li><li>读操作尽可能直接从分层中读取数据，无需从HDD中读取。</li></ol><p>存储分层的工作原理如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182127000.webp" alt="image-20231018212714653"></p><h5 id="高性能技术——智能条带化"><a href="#高性能技术——智能条带化" class="headerlink" title="高性能技术——智能条带化"></a>高性能技术——智能条带化</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182130668.webp" alt="image-20231018213056259"></p><p>此外aSAN还具有AI硬盘故障检测的能力，以及提供存储容量、硬盘寿命分析的能力。</p><h4 id="aNET网络虚拟化"><a href="#aNET网络虚拟化" class="headerlink" title="aNET网络虚拟化"></a>aNET网络虚拟化</h4><p>aNET是深信服网络安全虚拟化的一项技术，具备四个关键特性：<strong>网络虚拟化、网络功能虚拟化、分布式虚拟防火墙、业务逻辑拓扑</strong>。</p><ul><li>网络虚拟化技术：采用分布式虚拟交换机aSwitch和虚拟路由器</li><li>网络功能虚拟化：虚拟路由器具备NAT，DNS等等网络功能</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182140353.webp" alt="image-20231018214001970"></p><ul><li>分布式防火墙：</li></ul><p>面向虚拟机的安全策略部署</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182138016.webp" alt="image-20231018213834692"></p><ul><li>业务逻辑拓扑——所画即所得</li></ul><p>在画网络拓扑图的过程中采用智能算法、优化网络拓扑结构。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182139280.webp" alt="image-20231018213926916"></p><h4 id="aSAN注意事项"><a href="#aSAN注意事项" class="headerlink" title="aSAN注意事项"></a>aSAN注意事项</h4><p>aSAN平衡的实现方式中，目标磁盘不可以是多个，只能是单个。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211535391.webp" alt="image-20231021153529235"></p><h2 id="HCI最佳实践"><a href="#HCI最佳实践" class="headerlink" title="HCI最佳实践"></a>HCI最佳实践</h2><p>这里仅记录一下不同的产品服务的注意事项，各位读者可以自行去实操体验。</p><h3 id="HCI性能最佳实践"><a href="#HCI性能最佳实践" class="headerlink" title="HCI性能最佳实践"></a>HCI性能最佳实践</h3><h4 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h4><ul><li>磁盘：深信服一体机系统盘默认最低使用128G SSD盘。</li><li>RAID卡：使用aSAN，缓存盘和数据盘必须配置成non-raid或者jbod模式。</li><li>网卡：支持巨帧，推荐配置6*GE，2*10GE（6个千兆口，2个万兆口）</li><li>交换机：建议每个网络平面采用堆叠的两个交换机，在端口足够的情况下考虑交换机复用</li></ul><h4 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h4><ul><li>vCPU配置</li></ul><ol><li>随着vCPU的增加，性能提升是非线性的，而是对数增长。需要配置虚拟插槽数和每个插槽的核数。配置时，虚拟插槽数不要超过物理CPU个数，插槽核数也不要超过单个CPU的核数。</li><li>启用NUMA调度：vCPU本地内存访问，不会跨NUMA节点。</li><li>推荐默认不使用Host CPU，只有当虚拟机性能不足时才启用。</li></ol><ul><li>内存配置</li></ul><p>配置内存是指最大的可用内存。配置内存时，不能超过集群中单台主机的最大物理内存。建议关闭内存回收。</p><p>极端情况下虚拟机的内存超过主机内存，这时大量使用了交换分区。推荐内存不超配，所有开机虚拟机配置内存不要超过物理机的0.9。</p><p>内存分配的注意事项：如果配置了aSAN，预留32G，否则预留12G。Swap分区大小<code>swap=memory&lt;96GB?memory*2:memory</code>，不超过系统盘剩余空间的50%，最低8GB，最高256GB。</p><p>内存分配公式：<code>分配内存=总内存-预留内存+swap*0.2</code>。</p><ul><li>虚拟磁盘配置</li></ul><ol><li>虚拟磁盘的个数多少与虚拟磁盘的性能无直接关系，例如一块2T的和两块1T的硬盘性能是一样的（不考虑条带化等技术）。</li><li>裸磁盘映射的大小和性能都由裸磁盘本身决定，无调优参数。</li><li>预分配可以大幅提升IOPS和吞吐，但是会浪费一些存储空间。对于数据库等对IO要求高的应用，建议使用预分配，一般虚拟机不建议使用，浪费空间。</li></ol><h4 id="虚拟网络配置"><a href="#虚拟网络配置" class="headerlink" title="虚拟网络配置"></a>虚拟网络配置</h4><ul><li>VXLAN网络通信：虚拟网络内部集群内同一网段内部的虚拟机之间的跨主机流量成为“东西向流量”，深信服在企业服务器内设置了隧道，增加VXLAN报头封装虚拟机跨主机二层通信报文，通过vxlan隧道实现跨主机通信。</li><li>物理出口：用来连接虚拟网络和物理网络，每台服务器至少配置2*GE网口作为物理出口，并做网口聚合绑定。交换机需要关闭stp协议，保障网络稳定性。</li></ul><h4 id="虚拟存储配置"><a href="#虚拟存储配置" class="headerlink" title="虚拟存储配置"></a>虚拟存储配置</h4><ul><li>推荐存储网络使用2*10GE两个万兆口</li><li>SSD缓存盘：SSD可为其磁盘组下的HDD提供缓存加速的能力。SSD和HDD的个数比推荐值为1：3，不能低于1：7。</li><li>存储卷：使用存储多卷，要求每个存储卷的主机数量至少为3台。建议一个集群内不配置超过3个卷，单个卷内主机数不超过12台。</li><li>建议使用三台以上的主机组成一个虚拟存储卷，可以获得条带化的效果和仲裁机制。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211559795.webp" alt="image-20231021155928654"></p><h4 id="HCI管理（重点！）"><a href="#HCI管理（重点！）" class="headerlink" title="HCI管理（重点！）"></a>HCI管理（重点！）</h4><p>HCI初始化有如下的条件：</p><ol><li>根据集群内所有主机的CPU颗数购买充足的首选。</li><li>单主机不支持虚拟存储；普通集群至少要求2台以上的主机，如果需要虚拟存储的条带化功能或使用虚拟存储多卷功能，则需要3台以上的主机。</li><li>延伸集群至少需要4主机起步，加上一个仲裁节点。</li><li>禁止单台主机部署HCI。</li></ol><p>HCI有USE-Key（离线）授权和vKEY（在线）授权两种方式。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211601457.webp" alt="image-20231021160128322"></p><h2 id="HCI产品功能"><a href="#HCI产品功能" class="headerlink" title="HCI产品功能"></a>HCI产品功能</h2><h3 id="集群资源调度DRS"><a href="#集群资源调度DRS" class="headerlink" title="集群资源调度DRS"></a>集群资源调度DRS</h3><p>DRS全称是Distributed Resource Scheduler，指集群资源调度，顾名思义，在特定场景下会调度集群资源，这里的资源指的是虚拟机。我们的DRS会设置CPU和内存阈值，如果超过阈值，就会触发DRS。</p><p>DRS有自动和手动两种，对于选了自动的虚拟机，DRS会配置自动选择合适的主机来运行。而对于那些指定了运行位置的虚拟机，DRS不会对其进行操作。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211508535.webp" alt="image-20231021150843382"></p><h3 id="集群资源动态热添加DRX"><a href="#集群资源动态热添加DRX" class="headerlink" title="集群资源动态热添加DRX"></a>集群资源动态热添加DRX</h3><p>DRX全称是Dynamic Resource Extension，指动态资源拓展。虚拟机资源不足，主机资源空闲的时候，自动为虚拟机添加CPU或者内存。</p><h2 id="HCI产品应用场景"><a href="#HCI产品应用场景" class="headerlink" title="HCI产品应用场景"></a>HCI产品应用场景</h2><h3 id="信服云迁移工具"><a href="#信服云迁移工具" class="headerlink" title="信服云迁移工具"></a>信服云迁移工具</h3><p>信服云迁移工具可以供业务迁移能力(P2V，V2V)，可满足以下的业务场景要求：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211528787.webp" alt="image-20231021152837489"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211531494.webp" alt="image-20231021153154351"></p><p>注意是不会影响被迁移，不是不会被热迁移。蓝屏，USB和接受迁移目标资源不足都会影响虚拟机被热迁移。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211602968.webp" alt="image-20231021160223851"></p><h2 id="HCI产品运维"><a href="#HCI产品运维" class="headerlink" title="HCI产品运维"></a>HCI产品运维</h2><h1 id="深信服桌面云aDesk"><a href="#深信服桌面云aDesk" class="headerlink" title="深信服桌面云aDesk"></a>深信服桌面云aDesk</h1><ul><li>在深信服Webconsole界面中，<strong>sock</strong>命令与<strong>telnet</strong>命令相似。</li></ul><p>VMP（Virtualization Management Platform）是虚拟化管理平台的缩写。VDC(Virtual Desktop Controller)是桌面控制系统的缩写。VDI是虚拟桌面基础设施（Virtual Desktop Infrastructure）的缩写。它是一种技术和架构，用于在服务器上创建和管理虚拟桌面环境，从而提供集中式的桌面虚拟化解决方案。</p><p>可以与VMware对比的是VMP平台都用于管理虚拟机，VDC相当于一个C&#x2F;S架构应用程序的服务器端，VDI是客户端。</p><p>所以，使用aDesk之前必须要先完成VMP的部署和VDC的部署，而这两个平台的部署都是基于HCI的，所以在此之前还需要完成HCI的部署。下面是完成HCI部署之后的平台部署流程图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201835012.webp" alt="image-20231020183431435"></p><h2 id="VMP安装"><a href="#VMP安装" class="headerlink" title="VMP安装"></a>VMP安装</h2><p>VMP叫做虚拟化管理平台，理论上每一台虚拟机都应该安装VMP。而HCI将这些虚拟资源整合在一起，形成一个统一的平台，用于构建和管理虚拟化环境。<strong>HCI通常由多台物理服务器组成</strong>，每台服务器上运行着虚拟化软件，并通过网络进行通信和数据共享。</p><p>安装VMP的过程和安装HCI类似，都是获取到了iso镜像之后，在系统启动之时进入BIOS安装。</p><ul><li>前提条件</li></ul><ol><li>VMP系统镜像</li><li>U盘&#x2F;刻录光盘</li><li>普通PC（用于控制，制作iso镜像）</li><li>需要安装VMP的服务器</li></ol><p>VMP硬件配置要求：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201409517.webp" alt="image-20231020140937268"></p><ul><li>VMP授权管理：</li></ul><p>VMP除了可以使用Key授权之外，还可以借助aCenter实现对VMP和VDC的统一授权，在多集群&#x2F;多分支情况下，随意回收和修改授权。</p><ol><li>aCenter已经通过了Key进行授权，并且VMP节点已经加入了aCenter。</li><li>通过aCenter下发授权至分支节点后，该分支节点原有的授权无效，只继承aCenter所下发的授权。</li><li>通过aCenter进行统一的授权后，分支节点的授权key可拔出回收。</li><li>修改授权后，VDC会重启服务来更新授权信息。</li></ol><h2 id="VMP创建VDC"><a href="#VMP创建VDC" class="headerlink" title="VMP创建VDC"></a>VMP创建VDC</h2><p>再复习一下，VDC(Virtual Desktop Controller)是桌面控制系统的缩写。</p><p>在上一步完成了VMP的安装之后，就可以登录VMP控制台，设置ip等信息创建全新的虚拟机，然后创建VDC，一般VDC运行在4430端口上。如果想要更好的理解，可以把VMware想象成为一个Web应用，那么VDC就是服务器，VDI就是客户端。</p><ul><li>VDC集群的介绍</li></ul><p>VDC集群的各个节点（VDC设备）由一个分发器和一组真实服务器组成，分发器和真实服务器都是VDC设备。网络客户接入VDI的时候，会由分发器合理的分配给集群中最空闲的真实服务器为客户提供服务。</p><ul><li><font>VDC集群的要求：</font></li></ul><ol><li>存在两台VDC并且版本是一致的，确认VDC的ip地址处在同一个内网网段内。</li><li>每台VDC设备上均需要启用集群部署，并且需要配置相同的集群ip。</li><li><strong>软件VDC和硬件VDC可以组件集群</strong>。</li><li>禁止将克隆出的软件VDC和克隆前的软件VDC组件集群。</li></ol><ul><li>VDC用户认证管理</li></ul><p>VDC用户认证管理的主要方式有三种：本地密码认证、LDAP认证和第三方接口认证，可以看aDesk用户管理的部分。</p><p>授权码的注意事项如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201906572.webp" alt="image-20231020190602207"></p><ul><li>创建VDC步骤：</li></ul><ol><li>win操作机登录HCI</li><li>选择存储——本地存储</li><li>系统管理——端口管理——桌面云接入服务</li><li>虚拟机导入界面，导入虚拟机的vma镜像文件</li><li>点击转到虚拟机，开机，选择NetworkSetup Wizard，配置ip为VDC的管理ip。</li><li>部署完成后，浏览器访问<a href="https://VDCip:4430即进入VDC。">https://VDCip:4430即进入VDC。</a></li><li>新建虚拟化管理平台控制器，输入控制器地址，测试连接。</li></ol><ul><li>VDC管理</li></ul><p>在VDC管理过程中，每个用户拥有的硬件特征码个数默认为5个（五种设备？？？）。</p><h2 id="VMP创建VDI"><a href="#VMP创建VDI" class="headerlink" title="VMP创建VDI"></a>VMP创建VDI</h2><ul><li>创建VDI的步骤：</li></ul><ol><li>win操作机登录HCI</li><li>选择上面的虚拟机（VDC已经创建好的）</li><li>选择下面的桌面应用，创建全新VDI虚拟机</li><li>填写VDI虚拟机信息</li><li>安装系统，配置网络</li></ol><ul><li>最佳实践：</li></ul><p>VDI5.4.1开始支持多卷功能，如果是单主机或者双主机只允许创建一个卷；当系统中已存在一个卷的时候，未加入主机数小于3的时候不再允许新加卷。</p><p>单卷最大支持24主机，最佳实践是8-12为一个卷，VMP单集群最大支持创建3个卷。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211627113.webp"></p><h2 id="aCenter平台的部署"><a href="#aCenter平台的部署" class="headerlink" title="aCenter平台的部署"></a>aCenter平台的部署</h2><p>aCenter是虚拟化集中管理平台，适用于VMP集群分布式部署场景。通常将aCenter部署于企业内部，通过公网、专线等方式对各分支机构的VMP集群进行集中的监控、升级、管理和统一授权。</p><ul><li>aCenter安装在物理主机</li></ul><ol><li>需要先将aCenter的ISO镜像通过UltraISO制作启动镜像。</li><li>物理主机最低配置为：4GB内存，65GB硬盘，千兆网卡。</li></ol><ul><li>aCenter安装在VMP平台：</li></ul><p>与VMP上安装VDC虚拟机的过程大致相同，需要在虚拟机操作系统处选虚拟化集中管理平台aCenter，并将aCenter的ISO镜像挂载到虚拟机的光驱上，后续同物理机。配置要求也一样。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211557228.webp" alt="image-20231021155759093"></p><h2 id="aDesk用户和用户组管理"><a href="#aDesk用户和用户组管理" class="headerlink" title="aDesk用户和用户组管理"></a>aDesk用户和用户组管理</h2><p>在aDesk上可以对VMP，VDC和VDI进行的用户进行管理。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202044429.webp" alt="image-20231020204308752"></p><p>主要认证还包括第三方认证。</p><blockquote><p>LDAP（Lightweight Directory Access Protocol）认证是一种基于网络协议的身份验证机制，用于验证用户的身份和授权其访问特定资源。LDAP是一种应用层协议，用于访问和维护分布式目录服务（如LDAP服务器）中的信息。它使用客户端-服务器模型，其中客户端发起LDAP请求，服务器响应并提供所需的信息。</p><p>Radius（Remote Authentication Dial-In User Service）认证是一种网络身份验证协议，用于验证和授权用户对网络资源的访问。Radius认证是一种客户端-服务器认证协议，广泛用于网络接入服务，特别是拨号和虚拟专用网络（VPN）服务。它提供了一种中心化的认证和授权机制，允许用户通过一组凭据（例如用户名和密码）进行身份验证，并授予他们访问网络资源的权限。</p></blockquote><h2 id="客户端接入"><a href="#客户端接入" class="headerlink" title="客户端接入"></a>客户端接入</h2><p>常见的终端接入：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202108380.webp" alt="image-20231020210836189"></p><p>请注意，移动终端不支持登录linux虚拟机，但是可以访问windows虚拟机。 </p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211540608.webp" alt="image-20231021154010471"></p><h2 id="分布式防火墙"><a href="#分布式防火墙" class="headerlink" title="分布式防火墙"></a>分布式防火墙</h2><ul><li>传统终端安全的实现方式</li></ul><ol><li>接入交换机ACL控制终端PC间互访流量，，防止出现一些主机沦陷病毒扩散问题。</li><li>网络防火墙部署在区域边界节点控制区域互访流量。</li><li>计算机软件防火墙保护计算机系统环境安全。</li></ol><ul><li>分布式防火墙</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202203086.webp" alt="image-20231020220323906"></p><p>分布式防火墙适用场景：</p><ol><li>用户对于虚拟机之间的网络有微隔离要求。</li><li>出现诸如勒索病毒一类内网安全事件，需要阻断病毒横向传播场景。</li><li>使用传统基于IP做策略的方式难以满足实际网络访问控制需求的场景（如池桌面）。</li></ol><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202207266.webp" alt="image-20231020220752097"></p><ul><li>新增策略的三种方式：新建策略、复制策略和导入策略。</li></ul><h2 id="报表中心-Sangfor-VDC-Report-Center"><a href="#报表中心-Sangfor-VDC-Report-Center" class="headerlink" title="报表中心(Sangfor VDC Report Center)"></a>报表中心(Sangfor VDC Report Center)</h2><ul><li>报表中心简介</li></ul><p>报表中心可以对VDC和VMP上的数据进行收集，存储和展示，主要包括数据查询、数据分析、报表导出等功能。</p><p>针对VDC传输的数据可以分为：资产信息、管理日志、安全日志、安全策略、并发会话数。</p><p>针对VMP传递的数据可以分为：服务器存储趋势、服务器负载。</p><p>针对用户虚拟机的数据则提供文件导出审计页面。</p><ul><li>报表中心适用场景：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202215944.webp" alt="image-20231020221554753"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211549911.webp" alt="image-20231021154943744"></p><p>请注意，一个桌面云上的报表中心最多能关联1个VDC集群。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211540065.webp" alt="image-20231021154051939"></p><h2 id="显卡虚拟化3D部署"><a href="#显卡虚拟化3D部署" class="headerlink" title="显卡虚拟化3D部署"></a>显卡虚拟化3D部署</h2><ul><li>桌面虚拟化的两种架构：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202217225.webp" alt="image-20231020221749987"></p><ul><li>3D桌面显卡虚拟化(vGPU)优势</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202220261.webp" alt="image-20231020222010083"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="Agent安装"><a href="#Agent安装" class="headerlink" title="Agent安装"></a>Agent安装</h3><p>agent是桌面云的一个重要的组件，虚拟机的正常使用，离不开agent的正常运行。在虚拟机上安装Agent的方法是：虚拟机上面的管理栏下，有安装Agent的相关选项。</p><p>注意！安装Agent后会重启虚拟机。安装Agent之前要安装vmtools：在虚拟机那一栏下拉。</p><h3 id="独享桌面资源的创建"><a href="#独享桌面资源的创建" class="headerlink" title="独享桌面资源的创建"></a>独享桌面资源的创建</h3><ol><li>登入HCI</li><li>虚拟机模板管理——虚拟机转模板</li><li>业务中心——资源管理——新建独享桌面</li><li>按要求配置信息，保存</li></ol><h3 id="桌面云用户接入实验"><a href="#桌面云用户接入实验" class="headerlink" title="桌面云用户接入实验"></a>桌面云用户接入实验</h3><ol><li>登录HCI</li><li>业务中心——用户管理——新建</li><li>输入用户相关信息</li><li>安装VDI客户端并打开</li><li>输入服务器地址，用户名和密码</li></ol><h1 id="深信服分布式存储EDS"><a href="#深信服分布式存储EDS" class="headerlink" title="深信服分布式存储EDS"></a>深信服分布式存储EDS</h1><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211630046.webp" alt="image-20231021163014931"></p><h2 id="存储常见技术"><a href="#存储常见技术" class="headerlink" title="存储常见技术"></a>存储常见技术</h2><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211140380.webp" alt="image-20231021114010575"></p><h3 id="备份与容灾"><a href="#备份与容灾" class="headerlink" title="备份与容灾"></a>备份与容灾</h3><p>容灾（Disaster Recovery）是一种综合性的策略和实践，旨在保护和恢复组织的关键业务和数据，以应对各种灾难性事件，如自然灾害、硬件故障、人为错误等。容灾的目标是在灾难发生时，能够尽快地恢复业务运营和数据访问，并最小化停机时间和数据丢失。</p><p>备份（Backup）是一种数据保护的措施，旨在创建数据的副本并存储在另一个位置，以防止数据丢失或损坏。备份可以用于恢复单个文件、文件夹、数据库或整个系统。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192046268.webp" alt="image-20231019204626041"></p><blockquote><p>RTO（恢复时间目标）是指在发生灾难性事件后，系统需要恢复正常运行所需的时间。它代表了从灾难发生到系统完全恢复正常运行的时间窗口。较短的RTO意味着系统能够更快地恢复，尽快恢复业务运营，减少停机时间和业务中断。RTO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。</p><p>RPO（恢复点目标）是指在发生灾难性事件后，系统需要恢复到的数据恢复点。它代表了在灾难发生前的系统数据状态。较小的RPO意味着系统能够更少地丢失数据，尽可能接近灾难发生前的最新数据。RPO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。RPO越小，丢失的数据越少。</p></blockquote><p>EC（Erasure Coding）机制和副本机制是在分布式存储系统中用于数据可靠性和容错性的两种不同策略。</p><p>EC机制是一种纠删码技术，它将原始数据分割成多个数据块，并通过添加冗余数据块来实现数据的冗余和容错。EC可以在数据丢失或损坏的情况下进行数据恢复，而<strong>不需要完全复制原始数据</strong>。</p><p>副本机制是一种简单而直接的数据冗余策略，它通过完全复制数据来实现容错性。在副本机制中，<strong>原始数据会被完全复制</strong>到多个存储节点上，以确保数据的可靠性。如果某个节点发生故障或数据损坏，可以通过其他副本来恢复数据。</p><h3 id="RAID介绍"><a href="#RAID介绍" class="headerlink" title="RAID介绍"></a>RAID介绍</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/image-20231019205741595.webp" alt="image-20231019205741595"></p><h3 id="传统存储与分布式存储"><a href="#传统存储与分布式存储" class="headerlink" title="传统存储与分布式存储"></a>传统存储与分布式存储</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192102639.webp" alt="image-20231019210250465"></p><h3 id="EDS架构简介"><a href="#EDS架构简介" class="headerlink" title="EDS架构简介"></a>EDS架构简介</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192056711.webp" alt="image-20231019205631518"></p><h2 id="EDS产品应用场景"><a href="#EDS产品应用场景" class="headerlink" title="EDS产品应用场景"></a>EDS产品应用场景</h2><p>EDS产品的应用场景涵盖了块存储、文件存储和对象存储三个方面。</p><h2 id="EDS产品运维"><a href="#EDS产品运维" class="headerlink" title="EDS产品运维"></a>EDS产品运维</h2><p>EDS存储巡检：存储巡检是一种定期检查和评估存储系统的健康状况和性能的过程。它旨在发现和解决潜在的问题，以确保存储系统的稳定性、可靠性和性能。</p><p>进行存储巡检是商业维度，技术维度和其他维度的综合考量结果。可以使用深信服adeploy服务（一个可执行文件）进行存储巡检。</p><h1 id="深信服应用交付AD平台"><a href="#深信服应用交付AD平台" class="headerlink" title="深信服应用交付AD平台"></a>深信服应用交付AD平台</h1><h2 id="网络部署"><a href="#网络部署" class="headerlink" title="网络部署"></a>网络部署</h2><ul><li>深信服AD的集群部署模式种，<strong>1个浮动IP</strong>顶多在<strong>1台设备</strong>上生效。</li><li>深信服AD的集群模式中，当组件集群的AD版本号不一致的时候，健康状态应为<strong>故障</strong>。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211631695.webp" alt="image-20231021163102535"></p><h3 id="网络部署基础"><a href="#网络部署基础" class="headerlink" title="网络部署基础"></a>网络部署基础</h3><h4 id="网口配置"><a href="#网口配置" class="headerlink" title="网口配置"></a>网口配置</h4><p>在HCI的网络部署——网口配置页面，可以配置网口的协商模式，推荐使用Auto配置。</p><h4 id="端口聚合"><a href="#端口聚合" class="headerlink" title="端口聚合"></a>端口聚合</h4><p>端口聚合可以将多个物理接口当作一个单一的逻辑接口来处理，它允许两台设备之间通过多个接口并行连接同时传输数据以提供更高的带宽，更大的吞吐量和可恢复性技术。主要有如下优点：</p><ol><li>增加带宽：带宽相当于聚合的端口的带宽总和。</li><li>增加冗余：其中一个端口坏了还能工作，只是带宽变小。</li><li>负载均衡：可以在组内接口上配置，是流量在接口上自动进行负载均衡。</li></ol><p>操作方法：新建聚合接口——选择绑定策略——选择绑定接口。</p><h4 id="VLAN子接口"><a href="#VLAN子接口" class="headerlink" title="VLAN子接口"></a>VLAN子接口</h4><p>某些情况下与AD设备对接的网口为TRUNK口，要求AD设备对应的接口也可以封装VLAN划分子接口，此时需要配置VLAN子接口。</p><h4 id="端口桥接"><a href="#端口桥接" class="headerlink" title="端口桥接"></a>端口桥接</h4><p>在一些较为复杂的网络结构中，需要AD设备能将两个口划分到一个广播域内，相当于将AD设备的多个口组成一个二层交换机，此时就需要网口桥接功能。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201056310.webp" alt="image-20231020105602015"></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>ECMP是传统边界路由器的运营商链路负载方式。</li><li>策略路由是传统的边界路由器的运营商链路负载方式。</li><li>路由器策略路由链路负载方式无法根据带宽动态调整，调度策略不灵活，资源利用率低。</li></ul><blockquote><p>ECMP是一种路由算法，用于在网络中选择多个等价路径来转发数据流量。当存在多个具有相同开销（cost）的路径时，ECMP允许路由器将数据流量分散到这些路径上，以实现负载均衡和提高网络性能。ECMP通常在网络中的内部路由中使用，例如在数据中心网络中。</p><p>策略路由是一种根据特定的策略或条件，动态选择路由路径的方法。与传统的静态路由不同，策略路由可以根据网络中的不同因素（如流量负载、链路状态、服务质量要求等）来选择最佳路径，以实现更灵活的路由控制。</p></blockquote><h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><p>部署模式使之设备以什么样的工作方式部署到用户的网络中去，不同的部署方式对于网络影响各不相同。AD支持两种部署模式：网关模式和旁路模式。注意，配置AD设备的时候不需要在界面上选择部署模式，以什么样的方式接入客户网络就是什么部署模式。</p><h4 id="网关部署模式"><a href="#网关部署模式" class="headerlink" title="网关部署模式"></a>网关部署模式</h4><p>一般是将AD部署在互联网出口或者是内网服务器前端，逻辑网络层面，设备有两个或多个接口连接到网络内，数据经过路由转发会穿过设备。设备配置里，既有WAN接口，也有LAN属性接口。</p><ul><li>优点：AD的功能都能满足（出战负载、全局负载、应用负载等等）</li><li>缺点：此种部署对网络的改动比较大，建议在新建网络或者网络改造的时候部署。</li></ul><h4 id="旁路模式部署"><a href="#旁路模式部署" class="headerlink" title="旁路模式部署"></a>旁路模式部署</h4><p>一般是AD旁路在接入或者核心交换机上</p><ul><li>优点：无需改变原网络拓扑结构，只需要单臂挂在核心交换机，进行配置即可，对现有网络无影响</li><li>缺点：无法实现链路负载</li></ul><h4 id="三角传输模式"><a href="#三角传输模式" class="headerlink" title="三角传输模式"></a>三角传输模式</h4><p>一般是AD旁路部署在业务服务器同一台二层交换机下或同一个二层网络中，通过AD虚拟服务关闭DNAT和SNAT功能，服务器配置loopback口与虚拟服务相同IP实现。</p><ul><li><p>优点：服务端可以看到客户端源IP；减轻AD流量负担，回来的包不经过AD设备，而是直接转发回客户端</p></li><li><p>缺点：AD无法感知服务器的loopback口健康状态；AD必须与服务器同网段部署。</p></li></ul><h2 id="高可用主备模式"><a href="#高可用主备模式" class="headerlink" title="高可用主备模式"></a>高可用主备模式</h2><h3 id="主备模式简介"><a href="#主备模式简介" class="headerlink" title="主备模式简介"></a>主备模式简介</h3><p>主备模式：两台AD双击部署，一台处于工作状态，另一台处于冷备状态。两台设备通过心跳口检测对端是否存在，并同步设备和会话。当主设备触发问题切换条件时，设备会自动地把业务切换到备用设备。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201119366.webp" alt="image-20231020111917141"></p><p>AD设备的各种部署模式都支持双机热备，以下是典型的拓扑图。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201120265.webp" alt="image-20231020112024952"></p><h3 id="主备模式要求"><a href="#主备模式要求" class="headerlink" title="主备模式要求"></a>主备模式要求</h3><p>主备模式部署要求：</p><ol><li>网口个数一样</li><li>内存大小一样</li><li>序列号一致</li><li>软件版本一致</li></ol><h3 id="主备模式的基本元素"><a href="#主备模式的基本元素" class="headerlink" title="主备模式的基本元素"></a>主备模式的基本元素</h3><h4 id="心跳口"><a href="#心跳口" class="headerlink" title="心跳口"></a>心跳口</h4><p>又叫HA口，主要功能是检测对端是否还存活，通常两台设备的心跳口通过网线直连，并且通过周期性地发送心跳口包来检测对端是否存活，并且有冗余保障机制。</p><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>用来检测主设备发生故障时，进行主备设备切换保证业务的连续稳定运行，切换条件可以由用户自己定义。</p><h4 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h4><h2 id="ACL访问控制策略配置"><a href="#ACL访问控制策略配置" class="headerlink" title="ACL访问控制策略配置"></a>ACL访问控制策略配置</h2><p>ACL(Access Control List)访问控制列表，ACL基于数据连接的五元组来实现外到内或内到外的数据访问控制，可以提升网络的安全性。主要应用场景是禁止内网指定用户访问AD设备或禁止访问互联网，禁止外部主机访问设备或者AD设备发布的内网业务。</p><p>相关的配置在HCI的网络部署——网络安全——ACL配置路径。</p><h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>深信服AD设备对某节点业务健康检查失败之后的处理动作：标记该节点异常；AD会将健康检查失败的节点从资源池中剔除；健康检查失败的节点将不能继续提供业务访问。但是<strong>会在资源池中继续进行健康检查</strong>。</p><p>在AD巡检的过程中，进行外观检查的时候，<strong>备机的alarm灯闪属于正常现象</strong>。主设备的alarm灯亮属于告警现象。</p><h2 id="AD产品应用场景"><a href="#AD产品应用场景" class="headerlink" title="AD产品应用场景"></a>AD产品应用场景</h2><h3 id="智能路由"><a href="#智能路由" class="headerlink" title="智能路由"></a>智能路由</h3><ul><li>适用场景</li></ul><p>外网多条线路时，部署的传统路由器总是出现：链路调度不均衡，跨运营商访问慢</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> 深信服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简明使用教程</title>
      <link href="/2023/10/17/Linux%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2023/10/17/Linux%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>下面是Linux操作系统的简单，覆盖了Linux基本使用的常用指令。<span id="more"></span></p><h1 id="Linux简明使用教程"><a href="#Linux简明使用教程" class="headerlink" title="Linux简明使用教程"></a>Linux简明使用教程</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="命令行和快捷键"><a href="#命令行和快捷键" class="headerlink" title="命令行和快捷键"></a>命令行和快捷键</h3><ul><li>补全命令：使用Tab键可以补全命令</li><li><code>Ctrl+A</code>：光标移动到最前，<code>Ctrl+E</code>：光标移动到最后，<code>Ctrl+L</code>：清除当前窗口</li><li><code>ls -a -l -t</code>和<code>ls -alt</code>是一样的</li></ul><h3 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h3><ul><li>查看文件</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171516725.webp" alt="image-20231017151632556"></p><ul><li><p>创建文件：使用mknod或者touch创建文件，使用mkdir创建目录</p></li><li><p>删除文件：使用<code>rm &lt;文件名&gt;</code>指令，使用<code>rm -r &lt;文件名&gt;</code>可以删除目录</p></li><li><p>移动与复制：使用<code>mv &lt;源文件&gt; &lt;目标目录&gt;</code>移动文件，使用<code>cp &lt;源文件&gt; &lt;目标目录&gt;</code>实现复制文件并移动。</p></li><li><p>创建链接文件：<code>ln -s &lt;A&gt; &lt;B&gt;</code></p></li><li><p>常见的文件类型标识：</p></li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171526100.webp" alt="image-20231017152604976"></p><ul><li><code>chmod</code>是一个用于修改文件或目录权限的命令。它可以更改文件的读取、写入和执行权限，以及文件所有者和所属组的权限。</li></ul><p>例如，将sh设置为可执行的指令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -x script.sh</span><br></pre></td></tr></table></figure><h2 id="Vim编辑器的使用"><a href="#Vim编辑器的使用" class="headerlink" title="Vim编辑器的使用"></a>Vim编辑器的使用</h2><p>Vim有输入模式，命令模式和底行模式三种，其中命令模式和底行模式的区别在于<code>:</code>。</p><p>Vim的基础用法不加赘述，下面是Vim的底行模式的一些命令：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171529532.webp" alt="image-20231017152932416"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171529690.webp" alt="image-20231017152951580"></p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="查看磁盘空间：df指令"><a href="#查看磁盘空间：df指令" class="headerlink" title="查看磁盘空间：df指令"></a>查看磁盘空间：<code>df</code>指令</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171533093.webp" alt="image-20231017153314957"></p><p>使用<code>df -i</code>查看磁盘INodes使用情况，<code>df -h</code>使用合适的单位显示文件系统信息。</p><h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p>使用<code>fdisk</code>指令可以对磁盘进行分区管理，但是只能划分小于2T的分区。由于磁盘分区使用频率较低，故不详细展开，使用时查阅fdisk指令即可。</p><h3 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h3><p>在完成磁盘的分区和格式化之后，还需要挂载到系统路径，才可以使用。</p><p>使用mount命令可以手动挂载，示例如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171547780.webp" alt="image-20231017154713601"></p><p>然而使用mount指令手动挂载的分区，在系统重启之后会取消挂载，要实现开机自动挂载的方法是使用配置文件&#x2F;etc&#x2F;fstab。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux有三类不同的用户：root用户，一般用户和服务用户。用户的管理文件在&#x2F;etc&#x2F;passwd文件中。一般而言，一个用户的home目录在<code>/home/&lt;用户名&gt;</code>。</p><ul><li>新增用户：使用<code>useradd</code>指令。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171555253.webp" alt="image-20231017155501128"></p><ul><li>删除用户：userdel指令，-r可以一并删除用户的home目录。</li><li>Linux用户创建完成以后，默认是没有密码的，设置密码的指令是<code>passwd username</code></li></ul><h2 id="Linux压缩与解压缩"><a href="#Linux压缩与解压缩" class="headerlink" title="Linux压缩与解压缩"></a>Linux压缩与解压缩</h2><h3 id="Linux常见的压缩包格式"><a href="#Linux常见的压缩包格式" class="headerlink" title="Linux常见的压缩包格式"></a>Linux常见的压缩包格式</h3><p>打包在linux下一般是tar，而压缩则可以是zip，gz等等。一般而言，在网上下载某些SDK的时候，最常见的压缩包格式就是tar.gz包。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171601997.webp" alt="image-20231017160148882"></p><blockquote><p>打包和压缩的区别：</p><p>打包是将多个文件和目录合并成为一个；</p><p>压缩是将单个文件使用压缩算法减小空间；</p></blockquote><h3 id="常见的压缩工具"><a href="#常见的压缩工具" class="headerlink" title="常见的压缩工具"></a>常见的压缩工具</h3><h4 id="zip压缩工具"><a href="#zip压缩工具" class="headerlink" title="zip压缩工具"></a>zip压缩工具</h4><p>zip可以压缩文件和目录，并且zip不会删除压缩的文件。</p><ul><li>压缩方法：<code>zip &lt;生成文件&gt; &lt;原始文件&gt;</code>，使用-r可以递归压缩，也就是压缩目录。</li><li>解压方法：<code>unzip &lt;压缩文件&gt; -d &lt;解压路径&gt;</code>，如果不使用-d参数，则会解压到当前路径。</li></ul><h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><p>gzip是用来压缩和解压缩.gz格式的文件的。</p><ul><li>压缩方法：<code>gzip &lt;文件名&gt;</code>，使用-#可以指定压缩等级1~9，默认为6。</li><li>解压方法：<code>gzip -d &lt;文件名&gt;</code></li></ul><p>注意：gzip压缩和解压缩都会删除源文件。</p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><p>bzip2是用来压缩和解压缩.bz2格式的文件的。</p><ul><li>压缩方法：<code>bzip2 -z &lt;文件名&gt;</code> ，不用-z指令也可以压缩</li><li>解压方法：<code>bzip2 -d &lt;文件名&gt;</code></li></ul><blockquote><p>注意：gzip和bzip2都不能压缩目录，因此需要使用tar将其进行打包。而使用tar打包成为一个文件后，则zip也就失去了打包目录的优势。所以tar一般配合gzip和bzip2使用。</p></blockquote><h3 id="打包和解包工具——tar"><a href="#打包和解包工具——tar" class="headerlink" title="打包和解包工具——tar"></a>打包和解包工具——tar</h3><p>熟记下面的参数，即可流畅使用tar。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171627644.webp" alt="image-20231017162706505"></p><p>记忆方法：</p><p><code>-z -j -J</code>三选一，标识压缩方式，分别是gz, bz2和xz；<code>-x</code>表示解包，<code>-c</code>表示打包，不能同时出现。<code>-v -f</code>一般都有，方便指定文件和观察打包&#x2F;解包过程。如果是打包，则指令格式为：<code>tar -cvf &lt;目标文件名&gt; &lt;源文件名&gt;</code>，而解包后面可以直接接文件名，默认是解包到当前文件夹，如果需要打包到指定文件夹，则指令后面需要加上<code>-C &lt;目标路径&gt;</code>。</p><h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><h3 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h3><p>在早期的Linux系统中，如果想要添加软件，必须获取源码，然后编译成二进制代码再运行，这种软件包通常是一个压缩包，比如tar.gz模式。直到现在，某些个人开发者开发的软件也还在使用这种打包方式。</p><p>后来，为了解决从压缩包安装软件的麻烦，软件包发展出了RPM包和Deb包两种形式。</p><ul><li>RPM包：最初是Red Hat Package Manager，后被重命名为RPM，是SUSE，Red Hat和Centos等发行版的首选软件包格式。</li><li>Deb包：基于Debian GNU&#x2F;linux的管理包文件，常用于Debian发行版本比如Ubuntu，Linux mint等等。</li></ul><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><h4 id="apt-Advanced-Package-Tool-："><a href="#apt-Advanced-Package-Tool-：" class="headerlink" title="apt(Advanced Package Tool)："></a>apt(Advanced Package Tool)：</h4><ol><li>apt是Debian和Ubuntu等基于Debian的Linux发行版中的包管理工具。</li><li>apt通过命令行工具apt-get和apt-cache提供了用户友好的接口，用于搜索、安装、升级和删除软件包。</li><li>apt使用.deb软件包格式。</li><li>apt还提供了aptitude和Synaptic等图形化前端工具，简化了软件包管理过程，具备自动下载和安装依赖的能力。</li></ol><h4 id="yum-Yellowdog-Updater-Modified"><a href="#yum-Yellowdog-Updater-Modified" class="headerlink" title="yum(Yellowdog Updater Modified)"></a>yum(Yellowdog Updater Modified)</h4><ol><li>yum是Red Hat、CentOS和Fedora等基于Red Hat的Linux发行版中的软件包管理工具。</li><li>yum通过命令行工具yum提供了用户友好的接口。</li><li>yum使用.rpm软件包格式。</li><li>yum还具有自动解决依赖关系的能力，可以自动下载和安装软件包的依赖项。</li></ol><h3 id="源码安装软件"><a href="#源码安装软件" class="headerlink" title="源码安装软件"></a>源码安装软件</h3><p>有一些开源软件，需要自行使用gcc等编译，这种场景无法统一，可以查阅官方文档结合日志搜索解决。</p><h2 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h2><p>将单一的桌面PC连接到网络是一件容易的事情，但是将Linux服务器连接到网络，比如静态IP，VPN和代理服务器等等。学习网络配置管理，不仅要学会使用网络，更重要的是掌握网络状态，排查系统问题。</p><p>传统的Linux网络配置通过network.service来实现，常见的命令有<code>ifconfig, ifup, ifdown</code>，用于查看，启动和关闭某个网络接口，比如eth0等等。</p><p>后来，Linux系统诞生了NetworkManager这样的管理工具，但是两种工具使用一种即可，否则会有冲突。</p><h3 id="NetwotkManager管理网络"><a href="#NetwotkManager管理网络" class="headerlink" title="NetwotkManager管理网络"></a>NetwotkManager管理网络</h3><h4 id="通过nmtui管理网络"><a href="#通过nmtui管理网络" class="headerlink" title="通过nmtui管理网络"></a>通过nmtui管理网络</h4><p>想通过nmtui管理网络的前提是网卡可以直接被NetworkManager管理，在Debian发行版下，下载安装NetworkManager的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install network-manager</span><br></pre></td></tr></table></figure><p>安装完成后，可以使用<code>nmcli device</code>查看网络设备:</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171812813.webp" alt="image-20231017181234679"></p><p>直接输入nmtui即可使用GUI管理网络，也可以通过修改配置文件直接管理网络。</p><blockquote><p>nmtui是NetworkManager Text User Interface的缩写，是一个基于文本的图形界面工具，用于配置和管理网络连接。而nmcli则是通过命令行的形式管理计算机网络。</p></blockquote><p>在修改网络之后，需要重启网络服务以生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h4 id="其他网络指令"><a href="#其他网络指令" class="headerlink" title="其他网络指令"></a>其他网络指令</h4><ul><li>netstat：使用netstat可以查看整个Linux系统的网络情况</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171824263.webp" alt="image-20231017182432059"></p><p>最常用的指令<code>netstat -antp</code>，运行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171826399.webp" alt="image-20231017182650172"></p><ul><li>ss命令：SocketStatistics的缩写，用来获取socket的统计信息</li></ul><p>当服务器的socket连接数量变得非常大的时候，无论是使用netstat命令还是直接cat &#x2F;proc&#x2F;net&#x2F;tcp，执行速度都会很慢，ss用到了TCP协议栈中的tcp_diag，可以获得linux内核的第一手信息，效率极高。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171830301.webp" alt="image-20231017183018127"></p><p>最常用指令：<code>ss -lntp</code>，以数字形式显示tcp连接，并显示进程名：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171831280.webp" alt="image-20231017183137109"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>Linux的进程在&#x2F;proc目录下，相关信息存在于以ID命名的目录中。</p><blockquote><p>Linux一切皆文件！</p></blockquote><ul><li>查看进程：ps指令</li></ul><p><code>ps ux|less</code>：查看系统当前用户的所有进程，| less是管道处理，分页显示结果</p><p><code>ps -A</code>查看所有进程</p><ul><li>关闭和修改进程：kill指令</li></ul><p>使用kill指令可以对某个进程发出信号，常见的信号如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171839352.webp" alt="image-20231017183953235"></p><p>例如，在确保安全的情况下，可以使用<code>kill -9 1234</code>强制关闭1234进程。</p><p>使用killall指令可以直接根据进程名杀死进程，例如<code>killall bash</code>。</p><ul><li>修改CPU使用优先级：nice指令</li></ul><p>Linux使用nice值定义进程访问CPU的优先级，位于[-20,19]区间，默认取值为0。</p><ol><li>nice值越低，访问CPU优先级越高，默认0。</li><li>普通用户只能将自己的进程nice设为0~19。</li><li>普通用户只能设置nice值变高。</li><li>普通用户只能在自己的进程上设置nice。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice -5 vim &amp;</span><br></pre></td></tr></table></figure><p>将vim进程放在后台运行，并且设置nice值为0+5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n -5 1234</span><br></pre></td></tr></table></figure><p>对进程ID为1234的nice减少5。</p><ul><li>守护进程：所有进程之母</li></ul><p>一般守护进程是init或systemd，位于进程表的第一行，Linux内核中有一个PID为0的进程，表示内核，守护进程的PID则设置为1。</p><blockquote><p>守护进程（daemon）是在操作系统后台运行的一种特殊类型的进程。它们通常在系统引导时启动，并且在整个系统运行期间持续运行。守护进程通常不与用户交互，而是在后台执行特定的任务或提供某种服务。它们被设计为在系统启动时自动运行，并且通常会一直运行，直到系统关闭或手动停止。</p></blockquote><ul><li>服务管理：</li></ul><p>Linux下服务管理有两个指令，分别是service和systemctl指令，systemctl是Linux的最新初始化系统，兼容了service的指令。</p><blockquote><p>service和systemctl指令的本质都是执行&#x2F;etc&#x2F;init.d目录下的脚本</p></blockquote><p>systemctl常用方法如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171852378.webp" alt="image-20231017185227218"></p><h2 id="Linux运维管理"><a href="#Linux运维管理" class="headerlink" title="Linux运维管理"></a>Linux运维管理</h2><h3 id="性能与服务"><a href="#性能与服务" class="headerlink" title="性能与服务"></a>性能与服务</h3><ul><li>系统状态监控：<code>vmstat</code>，直接使用则输出当前的系统状态，第一个数字是持续输出的间隔秒数，第二个数字是持续时长秒数。例如<code>vmstat 1 5</code>表示间隔1s持续执行5次。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171855446.webp" alt="image-20231017185513224"></p><ul><li>内存资源监控：<code>free</code></li></ul><p>使用free指令可以查看系统的内存使用状态，如下图</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171857589.webp" alt="image-20231017185749475"></p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>使用<code>crontab</code>可以编辑计划任务，选项如下：</p><ol><li>-u 指定用户名，不指定为当前用户</li><li>-e 编辑计划任务</li><li>-l 列出计划任务</li><li>-r 删除所有计划任务</li></ol><p>创建单个计划任务的方法如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171901769.webp" alt="image-20231017190131628"></p><p>如需要周期性地执行某些计划任务，则可以写成如下形式：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171903248.webp" alt="image-20231017190308070"></p><h3 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h3><p>系统服务是在操作系统中以守护进程形式运行的软件组件，用于提供特定的功能或服务。这些服务在系统启动时自动启动，并在后台持续运行，以响应系统和用户的需求。</p><p>Linux的系统服务一般位于<code>/usr/lib/systemd/system</code>路径下，具有每个系统服务的内容：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171907744.webp" alt="image-20231017190730361"></p><blockquote><p>后缀名解释：</p><p>service:系统服务，如crond，sshd都是服务，包括自己安装的mysql-server等。</p><p>target:多个unit组成（unit是一个逻辑概念，该目录下的都可以叫做unit，比如service等，target就是组合的unit）</p><p>device:硬件设备</p><p>mount:文件系统挂载点</p><p>automount:自动挂载点</p></blockquote><ul><li>创建系统服务：</li></ul><p>在服务路径下创建.service文件，该文件由三部分组成：</p><ol><li>[Unit]描述、文档等等</li><li>[Service]类型，环境变量，具体指令</li><li>[Install]服务安装到的target</li></ol><p>例如，某个service文件如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171915497.webp" alt="image-20231017191507265"></p><p>使用不同的target可以设置不同的运行级别，使用<code>systemctl get-default</code>可以查看当前的运行级别。</p><ul><li>自启动服务</li></ul><p>使用<code>systemctl enable &lt;服务&gt;</code>可以设置服务自启动，反之，使用<code>systemctl disable &lt;服务&gt;</code>可以禁止服务自启动。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171920730.webp" alt="image-20231017192014594"></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>Linux下管理防火墙的软件比较多，在CentOS的5，6版本和Debian中主要使用iptables，在CentOS 7默认的防火墙管理工具是firewalld。主要学习iptables的配置方法，学有余力可以学习其改进版Shorewall。</p><p>iptables是Linux系统中最常用的防火墙管理工具之一。它是一个基于内核的防火墙管理工具，通过操作netfilter框架实现网络包过滤和网络地址转换。Shorewall是一个基于iptables的高级防火墙管理工具，适用于各种Linux发行版。它提供了一个配置文件来定义防火墙规则，可以简化复杂的防火墙配置。Shorewall支持多种方式的配置，包括命令行和文本配置文件。</p><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>iptables由四个表，分别是：</p><ol><li>filter:默认表，用常用于过滤数据包</li><li>nat:用于地址转换，侧重于连接管理</li><li>mangle:侧重于每一个数据包管理，比如修改TTL</li><li>raw:异常处理</li></ol><p>iptables五个链：</p><ol><li>input:处理进入系统的网络包</li><li>output:处理从系统发送出去的网络包</li><li>forward:处理通过系统转发的网络包</li><li>prerouting:在路由决策之前处理进入系统的网络包</li><li>postrouting:在路由决策之后处理即将离开系统的网络包</li></ol><p>iptables四表五链的对应关系：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171934972.webp" alt="image-20231017193410854"></p><p>四表五链关系理解：</p><ol><li>filter表是最常用的表格，用于过滤网络包。它包含了三个默认的链（chains）：INPUT、OUTPUT和FORWARD。这些链用于处理进入系统、离开系统和通过系统转发的网络包。通过在这些链上配置规则，可以控制网络包的接受、拒绝、转发等。</li><li>nat表用于网络地址转换（Network Address Translation，NAT）。它包含了三个默认的链：PREROUTING、OUTPUT和POSTROUTING。这些链用于在网络包进入和离开系统之前或之后修改包的源地址、目标地址、端口等。</li><li>mangle表用于修改网络包的特定字段。它包含了五个默认的链：PREROUTING、INPUT、FORWARD、OUTPUT和POSTROUTING。这些链用于在不同的阶段对网络包进行修改，例如修改TTL字段、标记包、更改包的QoS等。</li><li>raw表用于进行特定的包处理，如连接追踪（connection tracking）和数据包跳过（packet bypass）。它包含了两个默认的链：PREROUTING和OUTPUT。这些链允许在数据包进入和离开系统之前进行特定的处理和跳过。</li></ol><p>数据包的处理顺序如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171941869.webp" alt="image-20231017194101680"></p><p>流量包通过防火墙，实际就是在这个处理顺序中检验是否满足规则，定义iptables规则的方法如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171942799.webp" alt="image-20231017194230628"></p><ul><li>iptables查看规则：<code>iptables -nvL --line-number</code></li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171947100.webp" alt="image-20231017194700960"></p><p>该指令可以查看不同的链上的所有规则信息。</p><ul><li>iptables规则编写：</li></ul><p>新建一条规则，禁止目标端口为TCP22的访问，放在INPUT链的最后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j DROP</span><br></pre></td></tr></table></figure><p>指定某个规则序号删除指定规则，可以先使用上面的查看规则的指令获取序号，然后删除规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 1</span><br></pre></td></tr></table></figure><p>其他示例：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171951292.webp" alt="image-20231017195128127"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171952499.webp" alt="image-20231017195206347"></p><h2 id="FTP服务器配置"><a href="#FTP服务器配置" class="headerlink" title="FTP服务器配置"></a>FTP服务器配置</h2><p>FTP(文本传输协议)，是一个用于在计算机网络上进行文件传输的应用层协议，一般运行在TCP20和TCP21两个端口，20端口用于在客户端和服务器之间传输数据流，21端口用于传输控制流，并且通向FTP服务器入口。</p><p>FTP有两种工作模式，主动模式下，客户端开启端口，服务器主动连接客户端的端口；被动模式下，服务器开启端口，被动等待客户端连接。</p><h3 id="FTP配置：vsftpd"><a href="#FTP配置：vsftpd" class="headerlink" title="FTP配置：vsftpd"></a>FTP配置：vsftpd</h3><p>在Linux中，一般使用vsftpd进行FTP服务配置，vsftpd是很多发行版本的默认软件，但是如果系统没有安装，则需要自行安装。在Debian系统上，配置vsftpd的文件位于&#x2F;etc&#x2F;vsftpd.conf。打开配置文件，可以发现：主动模式默认使用20端口进行连接。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172008330.webp" alt="image-20231017200833224"></p><h3 id="vsftpd账号配置"><a href="#vsftpd账号配置" class="headerlink" title="vsftpd账号配置"></a>vsftpd账号配置</h3><p>vsftpd使用三种账号访问，匿名帐号，linux本地帐号和虚拟账号，推荐使用虚拟账号访问。使用虚拟账号访问的时候，建议关闭匿名帐号的相关权限，修改方法同样是编辑vsftpd.conf文件：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172013571.webp" alt="image-20231017201301462"></p><p>开启了虚拟账号登录之后，我们需要对虚拟账号进行管理，首先需要配置vsftpd.conf：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172021363.webp" alt="image-20231017202150233"></p><p>接下来就是准备上面配置中的东西，首先是创建一个虚拟账号对应的系统用户名，使用-s禁止该用户登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd virtual_ftpuser -s /sbin/nologin</span><br></pre></td></tr></table></figure><p>接下来在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd_login文件下加入用户信息，创建test1和test2两个账号，并且指定其密码。<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172025851.webp" alt="image-20231017202521753"></p><p>然后生成账号的数据库文件，在Debian发行系统中需要自行安装db_load或使用其他命令（如db_load5.3）替代。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db_load -T -t hash -f /etc/vsftpd/vsftpd_login /etc/vsftpd/vsftpd_login.db</span><br></pre></td></tr></table></figure><p>接下来配置两个用户的权限：在下面的目录创建两个文件：</p><p>&#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test1</p><p>&#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test2</p><p>然后输入以下内容：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs%2Fvblog%2Fimage-20231017220552283.webp?q-sign-algorithm=sha1&q-ak=AKIDCbLd2jCUzkODBH4_S889m9PJWVKQ4ALCobKv1siJvZ8t0ACnZnNEXCIWIKoQZk0d&q-sign-time=1697551818;1697555418&q-key-time=1697551818;1697555418&q-header-list=&q-url-param-list=ci-process&q-signature=dcebd997749108a08bdcdb3e1c2ddc5df5ae450f&x-cos-security-token=r1H4WgNZExkVuYObwUtENLIhx2aBgJza091351a026a984b1330be7a6566bc7a8Z9fn7Qa58nqDuWUebadOp82oSHapqWPvXiPJAZFUxB9Np--oPJHQmK9oLQ1a_cbfiZ1VLpRUaN8PZ3BhrYxshlh4zeZ-epvl1SN2NZNVVFrXh3X3fB-Tp_EFrl8hU-luVRsdVpXCYfPfxHDdoWjeq9rE7EGUYWRghiHuRMAcu3M7fAha0pvdMWdobCR0XqSv&ci-process=originImage"></p><p>接下来创建文件和目录，分别所谓两个虚拟用户的访问根目录，并且在里面生成两个文件，当这两个用户登陆的时候，最开始看到的应该就是自己对应的文件。<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172212442.webp" alt="image-20231017221212222"></p><p>完成了创建账户之后，我们就可以调用这些账号进行认证了，认证方法如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172213436.webp" alt="image-20231017221335233"></p><p>接下来重启系统服务即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd</span><br></pre></td></tr></table></figure><p>后面就可以使用ftp访问当前服务器了，并且可以实现虚拟用户登录。</p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><h3 id="Shell脚本简介"><a href="#Shell脚本简介" class="headerlink" title="Shell脚本简介"></a>Shell脚本简介</h3><p>shell脚本在Linux的shell中工作，并不是一门编程语言，而是命令的集合，类似windows的bat文件。</p><blockquote><p>shell和bash之间的关系：</p><p>Shell是一种命令行解释器（command-line interpreter），它是操作系统与用户之间的接口，用于解释和执行用户输入的命令。而Bash（Bourne Again Shell）是一种Unix shell，它是Shell的一种实现，也是目前最常用的Shell之一。</p></blockquote><p>在编写好shell脚本之后，需要赋予执行权限，才可以直接运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod -x test.sh</span><br><span class="line"></span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure><p>下面编写一个shell脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">d=`date +%H:%M:%S`</span><br><span class="line">echo &quot;script start at $d&quot;</span><br><span class="line">echo &#x27;wait 2 secs&#x27;</span><br><span class="line">sleep 2</span><br><span class="line">d1=`date +%H:%M:%S`</span><br><span class="line">echo &quot;the script end at $d1&quot;</span><br></pre></td></tr></table></figure><p>`date +%H:%M:%S`是一个整体的命令，需要用反引号括起来，表示获取当前时间的HHMMSS格式，echo是将内容送到控制台，当echo显示的内容有变量的时候，需要使用双引号，否则单引号即可。$表示获取变量。</p><p>执行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310180958386.webp" alt="image-20231018095811226"></p><h3 id="Shell脚本语法"><a href="#Shell脚本语法" class="headerlink" title="Shell脚本语法"></a>Shell脚本语法</h3><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>数学运算需要用中括号括起来，要赋值的话还要加$号，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">sum=$[$a+$b]</span><br><span class="line">echo &quot;$a+$b=$sum&quot;</span><br></pre></td></tr></table></figure><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>获取用户交互输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;please input a number x :&quot; x</span><br><span class="line">read -p &quot;please input a number y :&quot; y</span><br><span class="line">sum=$[$x+$y]</span><br><span class="line">echo &quot;x+y=$sum&quot;</span><br></pre></td></tr></table></figure><p>其中-p是设置一条提示消息，用于提示用户需要输入的内容，其后直接跟变量名，无需声明。</p><h4 id="脚本参数和脚本选项"><a href="#脚本参数和脚本选项" class="headerlink" title="脚本参数和脚本选项"></a>脚本参数和脚本选项</h4><p>编写一个脚本，获取其脚本参数的值并相加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=$[$1+$2]</span><br></pre></td></tr></table></figure><p>其中$1和$2代表第1个和第2个参数，而$0则表示该脚本名字本身。</p><p>脚本则是带<code>-</code>的参数，比如<code>ls -l</code>，在实际执行脚本的时候，可以省略脚本选项。一般来说需要使用额外的脚本选项解析工具如getopt来解析，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while getopts &quot;:a:b:c&quot; opt; do</span><br><span class="line">  case $opt in</span><br><span class="line">    a)</span><br><span class="line">      echo &quot;Option -a selected with value $OPTARG&quot;</span><br><span class="line">      ;;</span><br><span class="line">    b)</span><br><span class="line">      echo &quot;Option -b selected with value $OPTARG&quot;</span><br><span class="line">      ;;</span><br><span class="line">    c)</span><br><span class="line">      echo &quot;Option -c selected&quot;</span><br><span class="line">      ;;</span><br><span class="line">    \?)</span><br><span class="line">      echo &quot;Invalid option: -$OPTARG&quot;</span><br><span class="line">      ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>getopts</code>命令用于循环遍历脚本的选项。每个选项都通过<code>case</code>语句进行处理，其中<code>$opt</code>表示当前选项，<code>$OPTARG</code>表示选项的参数值。</p><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><ul><li>if语句逻辑判断：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;input your score : &quot; a</span><br><span class="line">if [ $a -gt 80 ];then</span><br><span class="line">echo &quot;good job&quot;</span><br><span class="line">elif [ $a -gt 60 ];then</span><br><span class="line">echo &quot;you pass the exam&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;you failed&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>逻辑表达式使用[]括起来，并且中括号内部两侧都需要有一个空格。-gt是greater than的缩写，其他的证书比较缩写如下图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181029738.webp" alt="image-20231018102922511"></p><ul><li>case条件判断</li></ul><p>case的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case $Num in</span><br><span class="line">1) echo &#x27;Select 1&#x27;</span><br><span class="line">;;</span><br><span class="line">2) echo &#x27;Select 2&#x27;</span><br><span class="line">;;</span><br><span class="line">4|5) echo &#x27;Select 4 or 5&#x27;</span><br><span class="line">;;</span><br><span class="line">*) echo &#x27;Select othor&#x27;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>shell脚本有严格的语法限制，注意分号的位置为下一行的开始，使用*表示其他的任意匹配。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul><li>for循环</li></ul><p>for循环是一个十分常用的循环结构，常见的用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &lt;var&gt; in &lt;cases&gt; ;do</span><br><span class="line">command</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>while循环</li></ul><p>while循环在实际使用中可能会写成一个死循环，用于监控脚本,while语句的格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while &lt;条件&gt;; do</span><br><span class="line">command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>until循环，语法和while循环一样，但是满足条件的时候终止循环。</li><li>break用于中断，continue用于循环。</li></ul><p>下面有一些简单的练习，可供读者熟悉shell脚本编程:</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181105774.webp" alt="image-20231018110505536"></p><h2 id="grep，sed和awk"><a href="#grep，sed和awk" class="headerlink" title="grep，sed和awk"></a>grep，sed和awk</h2><p><code>grep</code>、<code>sed</code>和<code>awk</code>是在Unix&#x2F;Linux环境中常用的文本处理工具，它们具有不同的特点和用途。</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep命令用于查找文件里面符合条件的字符串，或用于查找内容里包含指定范式的文件。</p><ul><li>查找文件内容</li></ul><p>语法为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &lt;选项&gt; &lt;目标文字&gt; &lt;目标文件&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep tcpdump /etc/passwd</span><br></pre></td></tr></table></figure><p>查找passwd中tcpdump用户的相关信息。</p><ul><li>查找指令内容，例如<code>ls -l | grep m*</code></li></ul><p>此外，所有的查找内容都可以使用正则表达式匹配。正则表达式的联系可以到<a href="https://tool.oschina.net/regex/">网站</a>练习。</p><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p><code>sed</code>是一个流式文本编辑器，可用于对文本进行替换、删除、插入、查找等操作。它使用简单的命令来操作文本，并且可以通过正则表达式进行模式匹配和替换。<code>sed</code>通常用于在脚本中批量处理文本数据，或者通过管道操作处理文本流。</p><p>例如，一个使用sed将文本中的foo替换成为bar的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;foo foo foo&quot; | sed &#x27;s/foo/bar/&#x27;</span><br></pre></td></tr></table></figure><p>输出结果为：<code>s/foo/bar/</code>。</p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p><code>awk</code>是一种用于处理和分析文本数据的强大工具。它是一种完整的编程语言，具有变量、循环、条件语句等常见编程特性。<code>awk</code>通过对输入文本逐行处理，并根据指定的模式和动作来提取和操作数据。</p><p>使用awk命令从文本数据中提取第一列的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1,John,Doe&quot; | awk -F&#x27;,&#x27; &#x27;&#123; print $1 &#125;&#x27;</span><br></pre></td></tr></table></figure><p>输出结果为1。</p><h1 id="Vscode免密登录"><a href="#Vscode免密登录" class="headerlink" title="Vscode免密登录"></a>Vscode免密登录</h1><ol><li>使用ssh-keygen创建密钥对</li><li>将公钥追加到authorized_keys，然后修改权限，重启sshd</li><li>将密钥下载到本地主机</li><li>配置.ssh&#x2F;_config</li></ol><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021836117.webp" alt="image-20240102183647945"></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Sangfor】数据中心与云计算</title>
      <link href="/2023/10/16/%E3%80%90Sangfor%E3%80%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/10/16/%E3%80%90Sangfor%E3%80%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>本文是深信服云计算学习课程的笔记，主要记录了数据中心、负载均衡的相关重点知识。<span id="more"></span></p><h1 id="数据中心与云计算"><a href="#数据中心与云计算" class="headerlink" title="数据中心与云计算"></a>数据中心与云计算</h1><h2 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h2><h3 id="数据中心概述"><a href="#数据中心概述" class="headerlink" title="数据中心概述"></a>数据中心概述</h3><p>数据中心（DC）是为集中放置的电子信息设备提供运行环境的建筑场所，包括主机房、辅助区等等，也就是一个实现信息的集中处理、存储、传输交换的物理空间。</p><p>互联网数据中心（IDC）包括了高速的接入带宽、高性能局域网等等。</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><blockquote><p>2006年亚马逊推出云数据中心，开创了云数据中心的时代。我国在2007年底开始使用云服务。</p></blockquote><p>传统的IT架构：</p><div style="text-align:center">    <img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161738200.webp" alt="image" /></div><p>传统的数据中心缺点：资源分布分散，利用率低，平均业务恢复时间长，手工分配资源，资源无法弹性适配，多DC分散管理，协同性差。于是云数据中心成为了主流。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161749114.webp" alt="image-20231016174921857"></p><p>云数据中心优点：虚拟化、安全可靠、敏捷性高。</p><h3 id="数据中心和服务器"><a href="#数据中心和服务器" class="headerlink" title="数据中心和服务器"></a>数据中心和服务器</h3><h4 id="什么是服务器？"><a href="#什么是服务器？" class="headerlink" title="什么是服务器？"></a>什么是服务器？</h4><p>服务器是计算机的一种，指在网络环境下运行特定的软件，为客户提供服务的计算机。服务器的特性：高可用性、可靠性、可扩展性、易用性、易管理性。</p><p>服务器应用部署的常见架构：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161752124.webp" alt="image-20231016175247891"></p><h4 id="服务器的常见软件："><a href="#服务器的常见软件：" class="headerlink" title="服务器的常见软件："></a>服务器的常见软件：</h4><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161754636.webp" alt="image-20231016175458410"></p><p>特殊系统软件：openstack虚拟化软件</p><p><strong>服务器虚拟化</strong>：将物理资源抽象成为逻辑资源：将一台服务器变成几台甚至上百台相互隔离的虚拟服务器。</p><p>服务器的常见处理器架构：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161800839.webp" alt="image-20231016180057517"></p><p>安装软件的时候需要注意架构，鲲鹏、ARM和x86、AMD64一般有区别。</p><h4 id="服务器总体层次"><a href="#服务器总体层次" class="headerlink" title="服务器总体层次"></a>服务器总体层次</h4><p>下图总结了服务器的总体层次架构：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161804776.webp" alt="image-20231016180432518"></p><h4 id="服务器的硬件结构"><a href="#服务器的硬件结构" class="headerlink" title="服务器的硬件结构"></a>服务器的硬件结构</h4><p>服务器的硬件结构与一般的计算机结构基本一致，此处只摘取重点记录。</p><p>服务器内存条的注意事项：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161808782.webp" alt="image-20231016180838403"></p><p>硬盘的接口性能示意图：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161810386.webp" alt="image-20231016181032036"></p><p>所以买硬盘优先选择PCIe接口，最好不要选择SATA接口。</p><p><strong>RAID技术（服务器关键技术）</strong>：有多个独立的高性能磁盘驱动器组成的磁盘子系统，提供比单个磁盘更高的性能。实现方式有两种：</p><ul><li>硬件RAID：使用硬件RAID卡</li><li>软件RAID：通过操作系统在磁盘管理的方式管理磁盘组</li></ul><p>BMC：BMC是基础管理控制器（Baseboard Management Controller）的缩写。它是一种嵌入式硬件设备，位于服务器或计算机系统的主板上，用于远程管理和监控系统的运行。BMC是一个独立的系统，不依赖其他硬件，也不依赖BIOS，OS等等，但可以与之交互。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="负载均衡概述"><a href="#负载均衡概述" class="headerlink" title="负载均衡概述"></a>负载均衡概述</h4><p>负载均衡是一种在计算机网络中分配工作负载的技术，通过将请求分发到多个服务器上，以平衡服务器之间的负载，从而实现更高的吞吐量和更快的响应时间。</p><p>下面是一个负载均衡的示例：假设有一个负载均衡器和三台服务器（Server A、Server B和Server C）。当客户端发送请求时，请求首先到达负载均衡器。然后，负载均衡器根据预定义的算法（例如轮询、最小连接数等）选择一个服务器，并将请求转发到该服务器。</p><p>负载均衡分类：<br><strong>四层负载均衡（TCP）</strong>：流量分配到<strong>ip+port</strong>，一般用<strong>LVS</strong>实现</p><p><strong>七层负载均衡（http）</strong>：流量分配到不同的<strong>url</strong>，一般用<strong>Nginx</strong>实现</p><h4 id="负载均衡实现案例：DNS轮询"><a href="#负载均衡实现案例：DNS轮询" class="headerlink" title="负载均衡实现案例：DNS轮询"></a>负载均衡实现案例：DNS轮询</h4><p>多个服务器分配不同的IP地址，每次发过来的流量轮流发到不同的服务器中。</p><p>工作原理如下：</p><ul><li><strong>分配域名：</strong>在DNS服务器的配置中，为同一个域名（例如example.com）配置多个A记录，每个A记录对应一个服务器的IP地址。</li><li><strong>轮询IP：</strong>当客户端发送一个DNS查询请求以获取域名的IP地址时，DNS服务器会按照预定义的顺序返回这些IP地址。</li><li><strong>连接服务器：</strong>客户端将使用返回的IP地址之一，发起与服务器的连接。</li><li><strong>下次选择：</strong>下一个客户端请求会按照相同的顺序，再次选择下一个IP地址。</li></ul><h4 id="负载均衡方案LVS"><a href="#负载均衡方案LVS" class="headerlink" title="负载均衡方案LVS"></a>负载均衡方案LVS</h4><h5 id="LVS基础知识"><a href="#LVS基础知识" class="headerlink" title="LVS基础知识"></a>LVS基础知识</h5><p>LVS全称Linux virtual server的简称。LVS服务器集群一般采用三层结构：</p><ul><li><strong>负载调度器：</strong>整个集群对外前端机，负责将客户的请求发到一组服务器执行，而客户认为服务来自同一个IP地址。</li><li><strong>服务器池：</strong>一组真正执行客户请求的服务器，如WEB，MAIL，FTP和DNS服务器等。</li><li><strong>共享存储：</strong>为服务器池提供共享的存储区</li></ul><h5 id="LVS部署模式：三种"><a href="#LVS部署模式：三种" class="headerlink" title="LVS部署模式：三种"></a>LVS部署模式：三种</h5><p>LVS相关的几种IP：CIP, VIP, DIP, RIP</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161846727.webp" alt="image-20231016184603525"></p><h6 id="NAT模式："><a href="#NAT模式：" class="headerlink" title="NAT模式："></a>NAT模式：</h6><p>通过数据报头的修改，使得企业内部的私有IP地址可以访问外网，以及外部用户可以访问公司内网的私有IP主机。NAT有一个哈希表记录映射关系，用于实现流量通信的匹配。</p><p>访问WEB服务器的VIP-&gt;从调度列表中选出一台服务器，修改报头为DIP-&gt;访问RIP，从服务器返回实际的报文-&gt;建立通信，多次发送。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161852789.webp" alt="image-20231016185245577"></p><p>NAT模式的基本属性：</p><ol><li>RIP和DIP处于同一私有网段中（如无法满足，则确保它们能通信）</li><li>各RealServer指向DIP，保证响应能够交给Director。</li><li>缺点是Director负责所有进出数据，而响应数据比请求数据大得多，调度器容易出现瓶颈。</li></ol><h6 id="TUN模式："><a href="#TUN模式：" class="headerlink" title="TUN模式："></a>TUN模式：</h6><p>IP隧道是一种数据包装技术，它可以将原始数据包封装并且添加新的报头，将其发送给真正的服务器。一般用于VPN等。数据流图如下：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161902587.webp" alt="image-20231016190254377"></p><p>与NAT相比，RealServer直接返回客户机，修复了NAT中Director的瓶颈问题。</p><p>TUN模式的基本属性和要求：</p><ol><li>各个RIP不需要处在同一网段，但是RIP必须和公网通信</li><li>RealServer的TUN接口上需要配置VIP地址，以便接受Director的数据包以及作为响应报文的源IP。</li><li>隧道位于Director和RealServer之间，隧道外层的IP头部的源IP是DIP，目标IP是RIP。而隧道内层的IP头可以分析得到源IP（VIP）和目标IP（CIP）。</li><li>需要添加一条特殊路由，使得后端服务器返回客户端的时候源IP为VIP。</li></ol><h6 id="DR模式："><a href="#DR模式：" class="headerlink" title="DR模式："></a>DR模式：</h6><p>直接路由模式（Direct Routing）：DR模式中LVS依然只承担入站请求和选取服务器的任务，由后端真实服务器将其发回客户端。与隧道模式不同的是，RIP需要处在同一网段之中，返回的数据包中，源地址是VIP地址，目标地址是CIP地址。既不修改也不封装IP报文，而是将数据帧的MAC该为真正的MAC地址。</p><p>工作流图如下：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161927813.webp" alt="image-20231016192757568"></p><p>要求和DR和TUN模式类似，但是RIP必须在同一网段。</p><p>三种模式的比较：</p><table><thead><tr><th>比较项</th><th>NAT</th><th>TUN</th><th>DR</th></tr></thead><tbody><tr><td>真实网关</td><td>负载调度器</td><td>自有路由器</td><td>自有路由器</td></tr><tr><td>IP地址</td><td>公网+私网</td><td>公网</td><td>私网</td></tr><tr><td>优点</td><td>安全性高</td><td>Wan加密数据</td><td>性能最高</td></tr><tr><td>缺点</td><td>效率低</td><td>需要隧道支持</td><td>无法跨LAN</td></tr></tbody></table><h5 id="LVS调度算法"><a href="#LVS调度算法" class="headerlink" title="LVS调度算法"></a>LVS调度算法</h5><p>LVS有八种调度算法：</p><ol><li>轮询调度</li><li>加权轮询调度</li><li>最小连接调度</li><li>加权最小连接调度</li><li>基于局部性的最少链接</li><li>带复制的基于局部性的最少链接</li><li>目标地址散列调度</li><li>源地址散列调度</li></ol><p>调度算法与操作系统课程中的思想类似，此处不加赘述，感兴趣者可自行了解。</p><h5 id="LVS典型方案"><a href="#LVS典型方案" class="headerlink" title="LVS典型方案"></a>LVS典型方案</h5><ul><li><p>LVS+Keepalived：</p><p>  keepalived是一个用于实现高可用性的软件，它通常与LVS结合使用。keepalived通过检测服务器的状态，例如网络连通性和服务可用性，来决定是否切换负载均衡器的主备角色。当主负载均衡器发生故障或不可用时，keepalived会自动将备负载均衡器切换为主角色，确保服务的持续可用性。</p></li></ul><h4 id="负载均衡方案Nginx"><a href="#负载均衡方案Nginx" class="headerlink" title="负载均衡方案Nginx"></a>负载均衡方案Nginx</h4><h5 id="理解Nginx应用场景"><a href="#理解Nginx应用场景" class="headerlink" title="理解Nginx应用场景"></a>理解Nginx应用场景</h5><p>Nginx是俄罗斯人编写的轻量级Web服务器。</p><p>什么是反向代理？客户端无感知代理的存在，以代理服务器接受Internet上面的请求，并将服务器上的结果返回请求的客户端。</p><p>什么是正向代理？当客户端无法访问外部资源的时候（比如墙），可以通过一个正向代理间接地去访问，所以正向代理是客户端需要配置代理服务器的ip。</p><h6 id="Nginx基本模块"><a href="#Nginx基本模块" class="headerlink" title="Nginx基本模块"></a>Nginx基本模块</h6><ul><li>upstream模块：定义后端服务器列表，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 动态服务器组</span><br><span class="line">upstream dynamic_server&#123;</span><br><span class="line">server localhost:8080;</span><br><span class="line">server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其他页面反向代理</span><br><span class="line">location ~.*$ &#123;</span><br><span class="line">index index.jsp index.html;</span><br><span class="line">proxy_pass http://dynamic_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>location ~.*$</code>：这是一个正则表达式模式，表示匹配所有请求URI。<code>~.*$</code>的意思是忽略大小写的匹配任意字符，并且<code>$</code>表示匹配结尾。</li></ul><h5 id="理解Nginx调度算法"><a href="#理解Nginx调度算法" class="headerlink" title="理解Nginx调度算法"></a>理解Nginx调度算法</h5><p>目前Nginx服务器的upstream模块支持六种方式的分配：分别是轮询，权重，依据ip的分配，最小连接时间，相应时间和依据url的分配。</p><h5 id="Nginx的高可用负载均衡架构"><a href="#Nginx的高可用负载均衡架构" class="headerlink" title="Nginx的高可用负载均衡架构"></a>Nginx的高可用负载均衡架构</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161957039.webp" alt="image-20231016195718716"></p><p>上述方法是主从服务器的架构图，使用Nginx和Keepalived实现了高可用性和安全性。</p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><h3 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211632769.webp" alt="image-20231021163237669"></p><p>云计算是一种基于网络的计算模型，它通过互联网连接和共享的方式，提供各种计算资源和服务，包括计算能力、存储空间、数据库、应用程序等。</p><p>云计算的主要特点是将计算和存储资源从本地的物理设备转移到云服务提供商的服务器上。</p><p>云计算主要分为三种服务模型：IaaS（如OpenStack)，PaaS(如阿里云等)，SaaS(如讯飞听见)。</p><p>平台的发展趋势是ABCD融合：A人工智能(AI)，B大数据(Big Data)，C云计算(Cloud)，D物联网(Device)。</p><p>云计算的关键技术在于虚拟化，虚拟化的思想将资源抽象成为共享的资源池，然后由云平台从资源池分配资源。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181159548.webp" alt="image-20231018115943283"></p><p>服务器虚拟化由多种技术架构，其中主要的四种如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181751512.webp" alt="image-20231018173203055"></p><p>典型方案是KVM和Xen两种，KVM（Kernel-based Virtual Machine）和Xen是两种常见的开源虚拟化方案。</p><p>KVM是一种基于Linux内核的虚拟化技术。它利用Linux内核中的虚拟化扩展（如Intel的VT或AMD的AMD-V）来实现硬件虚拟化，允许多个虚拟机在同一物理服务器上同时运行。KVM提供了直接访问物理硬件的能力，因此在性能方面表现良好。KVM是Linux内核的一部分，因此无需额外的内核模块。</p><p>Xen是一种基于虚拟机监视器（Hypervisor）的虚拟化技术。它通过将操作系统直接运行在硬件上，实现了虚拟机的创建和管理。Xen支持多种操作系统，包括Linux、Windows和其他一些主流操作系统。</p><p>典型的云服务实例：云服务由很多种，包括云主机、私有云、弹性伸缩、负载均衡等等。常见的需求和方案对应的云服务如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181759399.webp" alt="image-20231018175947141"></p><p>“标准云”的架构可以分为三层：云管理平台、云平台和资源层。三层对应的著名产品如下：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211102854.webp" alt="image-20231021110156554"></p><h4 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h4><p>前面我们已经讲过，云计算最重要的一步就是将硬件资源虚拟化。虚拟化技术可以将计算机的硬件资源（如处理器、内存、存储和网络）进行抽象，使得多个虚拟机可以共享这些资源，并在逻辑上与物理计算机相隔离。这样，每个虚拟机就可以在自己的虚拟环境中运行操作系统和应用程序，就像独立的计算机一样。</p><p>虚拟化技术经过多年发展，已经成为一个庞大的家族，其中技术繁多，但是主要有四个分类指标：</p><h5 id="按照实现方法分类"><a href="#按照实现方法分类" class="headerlink" title="按照实现方法分类"></a>按照实现方法分类</h5><p>按照实现方法分类的分类标准是通过软件辅助还是硬件辅助的方式实现对物理资源的访问拦截并且重定向。</p><p>按照上面的标准，可以将虚拟化分为软件辅助的虚拟化和硬件支持的虚拟化。</p><ul><li>软件辅助的虚拟化</li></ul><p>通过软件让客户机的特权指令陷入异常，从而触发宿主机进行虚拟化处理，实现对物理资源的截获和处理。常见的软件虚拟化工具有<strong>QEMU和Vmware Workstation</strong>。</p><p>优点：成本低廉，部署方便，管理维护简单</p><p>缺点：额外性能开销，增加了复杂性</p><ul><li>硬件支持的虚拟化</li></ul><p>通过物理平台本身提供的特殊指令，实现对硬件资源的模拟与支持。常见的有<strong>Intel的VT-x和AMD的AMD-V</strong>。</p><p>优点：性能优势，提供不同位数的操作系统支持</p><p>缺点：成本较高，维护麻烦</p><h5 id="按照实现机制分类"><a href="#按照实现机制分类" class="headerlink" title="按照实现机制分类"></a>按照实现机制分类</h5><ul><li>半虚拟化</li></ul><p>通过对客户操作系统内核进行修改，加入特定指令，直接调用硬件资源，避免由VMM层转换指令带来的性能开销。典型的<strong>半虚拟化技术如Xen</strong>。</p><ul><li>全虚拟化</li></ul><p>客户机的操作系统是不需要做任何修改的，客户机操作系统和底层硬件完全隔离，由VMM转化成底层调用代码，具备良好的兼容性。<strong>如KVM，VMWareStation。</strong></p><h5 id="虚拟化技术分类"><a href="#虚拟化技术分类" class="headerlink" title="虚拟化技术分类"></a>虚拟化技术分类</h5><ul><li>裸机架构：直接使用VMM管理软件</li><li>宿主架构：硬件之上有一个普适操作系统</li><li>混合架构：兼而有之，<strong>其中KVM属于混合虚拟化</strong>。</li></ul><p>还有其他的许多虚拟化技术，感兴趣者可自行查阅相关资料。</p><h4 id="云计算典型方案"><a href="#云计算典型方案" class="headerlink" title="云计算典型方案"></a>云计算典型方案</h4><p>下面我们将讲一下深信服的服务器虚拟化方案aSV、分布式存储方案aSAN、网络虚拟化方案aNET和深信服HCI超融合方案，这一部分直接了解即可，后面会单独详细讲解。</p><h5 id="服务器虚拟化方案——aSV"><a href="#服务器虚拟化方案——aSV" class="headerlink" title="服务器虚拟化方案——aSV"></a>服务器虚拟化方案——aSV</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181823623.webp" alt="image-20231018182330353"></p><h5 id="分布式存储方案——aSAN"><a href="#分布式存储方案——aSAN" class="headerlink" title="分布式存储方案——aSAN"></a>分布式存储方案——aSAN</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181824926.webp" alt="image-20231018182432624"></p><h5 id="网络虚拟化方案——aNET"><a href="#网络虚拟化方案——aNET" class="headerlink" title="网络虚拟化方案——aNET"></a>网络虚拟化方案——aNET</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181825999.webp" alt="image-20231018182516725"></p><h5 id="深信服超融合方案HCI"><a href="#深信服超融合方案HCI" class="headerlink" title="深信服超融合方案HCI"></a>深信服超融合方案HCI</h5><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181826692.webp" alt="image-20231018182617359"></p><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><ul><li><strong>Kubernetes</strong>是一个开源的容器编排和管理平台，用于自动化部署、扩展和管理容器化应用程序，不是虚拟化技术。</li></ul><h5 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h5><p>容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211629334.webp" alt="image-20231021162923235"></p><ul><li>chroot技术</li></ul><p>chroot，即change root directory，改变root目录。在Linux中，根目录为&#x2F;，执行上述指令可以改变用户的根目录。</p><ul><li>namespace技术</li></ul><p>Linux namespace是Linux提供的一种内核级别环境隔离方法，提供了对UTS、IPC、mount、PID和Network等的隔离机制。</p><ul><li>Cgroup技术</li></ul><p>与namespace技术类似，也是将程序进行分组。但是Cgroup是对一组进程进行统一的资源监控和限制。</p><p>容器规范：OCI</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181836779.webp" alt="image-20231018183649557"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181837337.webp" alt="image-20231018183710065"></p><h5 id="典型容器——Docker"><a href="#典型容器——Docker" class="headerlink" title="典型容器——Docker"></a>典型容器——Docker</h5><p>Docker是使用最广泛的开源容器引擎，是一种操作系统级的虚拟化技术，依赖于namespace和Cgroups技术。</p><p>Docker的基本组成如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181839117.webp" alt="image-20231018183931847"></p><p>具体的Docker容器可以自行查阅资料学习。</p><h4 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h4><p>云原生是一种构建和运行应用程序的方法，是技术体系和方法论。在云原生的架构下，开发模式，应用架构，部署运维都应当以云平台为基础：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181843006.webp" alt="image-20231018184308771"></p><p>云原生由四个要素：</p><ol><li>微服务：几乎每个云原生的定义都包含微服务。</li><li>容器化：容器化为微服务提供保障。</li><li>DevOps：DevOps是一个敏捷思维，是一个沟通文化，也是组织形式。</li><li>持续交付：不误开发的交付，不停机实现更新，小步快跑，与传统的瀑布模型不同。</li></ol><blockquote><p>DevOps是一种融合软件开发（Development）和信息技术运维（Operations）的文化、方法和实践，旨在实现快速而可靠的软件交付和持续改进。DevOps的主要目标是通过增强开发团队和运维团队之间的协作和沟通，实现更快速、更频繁的软件交付。它强调自动化、持续集成和持续交付等实践，以减少部署错误、加快软件交付时间和提高系统稳定性。</p></blockquote><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211603341.webp" alt="image-20231021160331229"></p><h3 id="云计算关键技术"><a href="#云计算关键技术" class="headerlink" title="云计算关键技术"></a>云计算关键技术</h3><p>云计算的关键技术是虚拟化技术，而虚拟化技术又主要包括计算虚拟化、存储虚拟化和网络虚拟化。先来看一下虚拟化的几个基本概念：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181851942.webp" alt="image-20231018185123724"></p><p>IDV（Integrated Desktop Virtualization）是一种虚拟化技术，它允许将整个桌面环境虚拟化并交付给用户。<strong>IDV技术将操作系统、应用程序和用户数据打包到一个虚拟桌面中，并通过网络将其传输到用户的终端设备上</strong>。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211625919.webp" alt="image-20231021162425358"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211627113.webp" alt="image-20231021162748995"></p><h4 id="计算虚拟化"><a href="#计算虚拟化" class="headerlink" title="计算虚拟化"></a>计算虚拟化</h4><h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><h4 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h4><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><h4 id="CMP介绍"><a href="#CMP介绍" class="headerlink" title="CMP介绍"></a>CMP介绍</h4><p>CMP(Cloud Management Platforms)是指云管理平台，是一种管理公有云、私有云和混合云环境的整合性产品。CMP可以用来管理OpenStack云环境，而Horizon只是用来管理OpenStack的Dashboard的。因此，CMP往往是以应用为中心的，而OpenStack是以基础设施为中心的。</p><h4 id="OpenStack-1"><a href="#OpenStack-1" class="headerlink" title="OpenStack"></a>OpenStack</h4><p>OpenStack是一个开源的云计算平台，用于构建和管理私有云和公有云基础设施。它提供了一组模块化的软件组件，用于实现虚拟化、网络、存储和计算等基础设施服务。OpenStack的主要组件如下：</p><ol><li><strong>Nova（计算）</strong>：Nova是OpenStack的计算组件，负责管理和调度计算资源。它可以创建和管理虚拟机实例，并提供弹性计算能力。</li><li><strong>Neutron（网络）</strong>：Neutron是OpenStack的网络组件，用于提供网络服务和管理网络资源。它支持虚拟网络的创建、子网和路由的配置，以及负载均衡和防火墙等网络功能。</li><li><strong>Cinder（存储）</strong>：Cinder是OpenStack的存储组件，用于提供持久化块存储服务。它可以创建和管理块存储卷，并将其附加到虚拟机实例中。</li><li><strong>Swift（对象存储）</strong>：Swift是OpenStack的对象存储组件，用于存储和检索大规模的非结构化数据。它提供了可扩展、冗余和持久的对象存储服务。</li><li><strong>Keystone（身份认证）</strong>：Keystone是OpenStack的身份认证组件，用于管理用户、角色和权限等身份信息。它提供了统一的身份认证和授权机制，以确保只有经过授权的用户可以访问OpenStack的服务。</li><li><strong>Horizon（管理界面）</strong>：Horizon是OpenStack的Web管理界面，用于管理和监控OpenStack的各个组件。它提供了直观的图形界面，使用户可以方便地管理云基础设施。</li><li><strong>Glance（镜像服务）</strong>：Glance是OpenStack镜像服务的组件。</li></ol><p>OpenStack的设计基本上是按照亚马逊设置的，可以将OpenStack理解为开源版本的AWS。OpenStack火起来的原因一个是Apache旗下的开源软件，另外就是使用python进行编写。</p><h3 id="云计算交付和运维体系"><a href="#云计算交付和运维体系" class="headerlink" title="云计算交付和运维体系"></a>云计算交付和运维体系</h3><h3 id="云计算商业应用"><a href="#云计算商业应用" class="headerlink" title="云计算商业应用"></a>云计算商业应用</h3><h2 id="存储基础"><a href="#存储基础" class="headerlink" title="存储基础"></a>存储基础</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211144206.webp" alt="image-20231021114422063"></p><p>外挂存储的分类：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211153332.webp" alt="image-20231021115335090"></p><h4 id="DAS——直连式存储"><a href="#DAS——直连式存储" class="headerlink" title="DAS——直连式存储"></a>DAS——直连式存储</h4><p>DAS(Direct Attached Storage)即开放系统的直连式存储，即主机设备或者计算设备直接通过物理接口和线缆连接存储磁盘，从而获得存储资源。是一种连接方式，不是协议。可以是服务器上自带的硬盘或者线缆直连硬盘盒。DAS与服务器之间的通道通常采用SCSI连接。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211156540.webp" alt="image-20231021115639268"></p><p>DAS有两种模式，JBOD的RAID。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211200496.webp" alt="image-20231021120040252"></p><p>DAS架构特点：</p><ol><li>资源浪费，不利于共享：DAS直接挂在服务器上，随着需求增大，服务器和存储的设备数量变多，资源利用率地下。</li><li>占用服务器资源大：以来主机操作系统进行IO读写和存储维护。</li><li>扩展性差：采用SCSI连接，资源有限。</li><li>管理性差：由原设备厂商提供升级和扩展。</li></ol><h4 id="SAN——存储区域网络"><a href="#SAN——存储区域网络" class="headerlink" title="SAN——存储区域网络"></a>SAN——存储区域网络</h4><p>SAN是英文Storage Area Network的缩写，通常译为“存储区域网络”，它是一种在服务器和外部存储资源或独立的存储资源之间实现高速可靠的访问网络。其工作原理示意图如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211424735.webp" alt="image-20231021142447574"></p><p>SAN存储，主要包括两种网络架构的SAN，一种是基于IP的SAN，一种是基于FC网络的SAN。两种架构的对比如下：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211426782.webp" alt="image-20231021142641606"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211427016.webp" alt="image-20231021142705777"></p><h4 id="NAS——网络附加存储"><a href="#NAS——网络附加存储" class="headerlink" title="NAS——网络附加存储"></a>NAS——网络附加存储</h4><p>NAS(Network Attached Storage)：网络附加存储，是一种集中存储、支持备份、可实现跨平台的数据共享，兼容性好的存储结构。特点如下：</p><ol><li>支持网络文件共享协议NFS，CIFS</li><li>NAS有自己的文件系统</li><li>基于TCP&#x2F;IP协议</li></ol><ul><li>NAS和CIFS协议</li></ul><p>NFS(Network File System)即网络文件系统，是FreeBSD支持的文件系统中的一种，适用于<strong>类Unix操作系统</strong>，允许网络中的计算机之间通过TCP&#x2F;IP共享网络资源。在NFS中，本地NFS客户端应用可以透明地读写服务器上的文件，就像访问本地文件一样。</p><p>CIFS(Common Internet File System)仅适用于Windows操作系统，使客户端可以远程访问Internet计算机上的文件并提供服务，CIFS使用客户端服务器模式。</p><p>对比：CIFS面向网络连接的共享协议，常用TCP协议，而NFS可使用TCP或UDP。NFS缺点之一，要求client必须安装专用软件，而CIFS集成在OS内部，无需额外添加软件。</p><p>以下是DAS，NAS和SAN三种存储架构的对比：<br><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211443203.webp" alt="image-20231021144339995"></p><h3 id="存储协议"><a href="#存储协议" class="headerlink" title="存储协议"></a>存储协议</h3><p>不同的架构下，有不同的存储协议。下面是DAS，NAS和SAN的存储协议示意图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211451131.webp" alt="image-20231021145110855"></p><p>这些协议作了解即可。</p><h3 id="RAID技术"><a href="#RAID技术" class="headerlink" title="RAID技术"></a>RAID技术</h3><p>RAID(Redundant Array of Independent Disk)即独立磁盘冗余阵列，通常简称为磁盘阵列。有软件RAID和硬件RAID两种连接方式。</p><p>RAID技术有三个关键概念：镜像(Mirroring)、数据条带(Data Stripping)和数据检验(Data parity)。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211457197.webp" alt="image-20231021145752935"></p><p>业界和学术界一般把RAID分成七个标准的RAID等级，等级之间不存在高低之分。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211459697.webp" alt="image-20231021145952455"></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【课程笔记】Java程序设计</title>
      <link href="/2023/09/07/%E3%80%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E3%80%91Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/09/07/%E3%80%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E3%80%91Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>本文是Java程序设计课程整理的笔记，记录了一些易错点。<span id="more"></span></p><h1 id="Java程序设计"><a href="#Java程序设计" class="headerlink" title="Java程序设计"></a>Java程序设计</h1><p>[TOC]</p><p>环境和基础语法就略过了，直接从类开始讲起。可以说，C++只是半面向对象的，而Java是真正面向对象的语言。</p><h2 id="Java面向对象程序设计"><a href="#Java面向对象程序设计" class="headerlink" title="Java面向对象程序设计"></a>Java面向对象程序设计</h2><h3 id="类和对象的使用"><a href="#类和对象的使用" class="headerlink" title="类和对象的使用"></a>类和对象的使用</h3><p>Java的所有代码都必须写在类中，包括main函数，所以说，Java是完全面向对象（OOP）的。类的基本概念和使用和C++类似。</p><h4 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h4><p>对象和数组都是引用类型，所以都在栈中有名字和地址，<strong>对象真正的信息存储在堆中</strong>。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312151523999.webp" alt="image-20231215152323766"></p><p>String，数组和类的声明后默认是null。int,double等默认为0，boolean默认为false。</p><blockquote><p>Java内存的结构：</p><ul><li>栈区：存放局部变量，基本数据类型</li><li>堆区：存放对象和数组</li><li>方法区：包括常量池（字符串常量等），类加载信息（类信息只会加载一次，相当于加载类的定义）</li></ul></blockquote><p>Java的变量置空，实际上是把栈区的变量地址置空，并没有删除堆中的内存。如果没有变量指向内存中的某个类，那么这段空间就是垃圾，即未被引用的对象。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312151608106.webp" alt="image-20231215160811902"></p><h4 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a>方法的调用机制</h4><ul><li>调用方法会开辟一个独立的栈空间。所以，递归调用的时候最容易出现的错误是爆栈。</li><li>函数return之后，该方法创建的栈就会被销毁，数据返回到调用方法的地方。</li></ul><p>可变参数的使用：int… 表示多个同类型的变量，可当数组使用。可变参数可以和其他的类型参数一起使用，但是必须保证可变参数位于参数列表的最后一位。一个形参列表中只能出现一个可变参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String s, <span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的初始化与清理"><a href="#类的初始化与清理" class="headerlink" title="类的初始化与清理"></a>类的初始化与清理</h4><p><strong>类的初始化顺序</strong>：</p><ul><li><p>初始化静态定义</p></li><li><p>初始化非静态定义</p></li><li><p>初始化构造器</p></li></ul><p>如下图，先初始化静态定义，所以先有bowl4,5，然后初始化其他定义，最后初始化构造器。</p><p><img src="https://qn-st0.yuketang.cn/FhpSa4OBxoNV_bO-0kXvGpwFJjtz" alt="img"></p><p><strong>多个类的初始化顺序</strong>：</p><ol><li>主类静态定义</li><li>主类main方法</li><li>声明主类对象（非静态定义和构造器）</li><li>其他类的对象（非静态定义和构造器）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Insect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;, j=&quot;</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">printInit</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beetle</span> <span class="keyword">extends</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Beetle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span> + k);</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">        <span class="type">Beetle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beetle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="color: orange;">读上面的代码，主要考察类的初始化顺序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static Insect.x1 initialized</span><br><span class="line">static Beetle.x2 initialized</span><br><span class="line">Beetle constructor</span><br><span class="line">i=9, j=0</span><br><span class="line">Beetle.k initialized</span><br><span class="line">k=47</span><br><span class="line">j=39</span><br></pre></td></tr></table></figure><p><strong>对象的回收</strong>：</p><p>Java对象的回收是通过垃圾回收器来完成的。垃圾回收器是Java的一部分，负责自动管理内存，释放不再使用的对象的内存空间。</p><p>Java使用的是基于”可达性分析”的垃圾回收算法。当一个对象不再被任何活动的引用所引用时，它就被判定为”不可达”，即无法通过程序的任何路径访问到它。当垃圾回收器运行时，它会扫描堆中的对象，标记所有可达的对象，然后清理掉所有不可达的对象，最后压缩内存碎片，产生一块连续的空闲内存。</p><blockquote><p>工作过程简记：扫描-&gt;标记-&gt;清理-&gt;压缩</p></blockquote><h4 id="类的使用注意事项"><a href="#类的使用注意事项" class="headerlink" title="类的使用注意事项"></a>类的使用注意事项</h4><ul><li>“public”（公共）：具有最高的访问级别，可以被任何其他类访问。</li><li>“protected”（受保护）：<strong>只能被同一包内的类访问，或者是该类的子类访问</strong>。</li><li>“default”（默认）：如果没有明确指定访问修饰符，即没有使用任何修饰符，默认为”default”访问级别。”default”访问级别限制了<strong>同一包内的类</strong>可以访问。</li><li>“private”（私有）：具有最低的访问级别，只能被定义该成员的类内部访问。</li></ul><p>下表可以更清晰地反映各个权限修饰符的可访问范围：</p><table><thead><tr><th>访问权限</th><th>同一个类</th><th>同一个包（含子类）</th><th>不同包子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>private</td><td>✔</td><td></td><td></td><td></td></tr><tr><td>default</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>protected</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>public</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><p>在Java语言中，函数的参数传递方式有两种：</p><ul><li>值传递：基本数据类型是使用值传递的</li><li>引用传递：对象引用类型（如数组，类对象等）是通过引用传递的进行的。</li></ul><p>需要注意的是，Java 中的所有数据类型都是按值传递的，即使是引用类型，也是通过将引用的值（即地址）进行传递。区别在于，引用传递可以修改对象的状态，但无法修改引用本身（即无法将引用指向其他对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee x, Employee y)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是a仍为Alice，b仍为Bob。但是如果改成下面的函数，则两人的名字会互换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee x, Employee y)</span> &#123;</span><br><span class="line">    String temp=x.name;</span><br><span class="line">    x.name=y.name;</span><br><span class="line">    y.name=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="所有类的基类"><a href="#所有类的基类" class="headerlink" title="所有类的基类"></a>所有类的基类</h4><p>类java.lang.Object处于java开发环境的类层次的根部，其它所有的类（包括自己写的类）都是直接或间接地继承了此类。该类定义了一些最基本的状态和行为。下面，我们介绍一些常用的方法。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202309151426565.webp" alt="image-20230915142555938"></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A A1=<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">A A2=<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(A1.equals(A2));</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>当类很多的时候，可以使用包管理类，方式命名冲突等。</p><p>打包的关键字为<code>package &lt;包名&gt;</code>。</p><p>引入包的关键字<code>import &lt;包名&gt;(&lt;类名&gt;)</code></p><blockquote><p>注意，使用<code>import java.util/*</code>，只导入该包的一级目录，不推荐使用*的方式导入。</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol><li>概念：单例模式（Singleton Pattern）是一种创建对象的设计模式，它确保一个类只有一个实例，并提供全局访问该实例的方式。</li><li>实现方法：在单例模式中，类的构造函数被私有化，使得该类无法通过常规方式进行实例化。同时，该类提供一个静态方法或静态属性，用于获取类的唯一实例。这样，无论在何处调用该静态方法或属性，都会返回同一个对象实例</li><li>主要特点：<strong>静态实例、全局访问、私有构造</strong></li><li>单例模式的应用场景：线程池、数据库连接池、日志记录器、全局缓存等等。</li></ol><p>下面是一个单例模式设计类的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单例模式和静态声明的对比：</p><p>单例模式使用类来保存自身对象，当调用getInstance()的时候，如果已经有实例，那么就会返回实例，这一点就决定了这个模式能保证只有一个对象，而使用静态声明则并不能达到该目标。</p></blockquote><p>在上述代码中，我们写一个主函数来测试这个单例模式的工作过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">    s1.getInstance().setMessage(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(s2.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，你会发现，s1和s2的message都变成了hello，这是因为两者共享同一个实例。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202309152132186.webp" alt="image-20230915212709643"></p><p>更多知识可以查阅设计模式的相关书籍。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类分为四种：成员内部类，嵌套内部类，静态内部类，匿名内部类。</p><p>一个类的定义嵌套在另一个类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupTwo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            count++; <span class="comment">// 访问外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Johnson&quot;</span>);</span><br><span class="line">        s1.output(); <span class="comment">// 通过 s1 调用内部类的成员方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + <span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GroupTwo</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupTwo</span>();</span><br><span class="line">        g2.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类具有如下特性：</p><p>•一般用在定义它的类或语句块之内,在外部引用它时必须给出完整的名称。</p><p>•可以使用包含它的外部类的静态成员变量和实例成员变量,也可以使用所在方法的局部变量。</p><p>•可以定义为abstract。</p><p>•可以声明为public, private或protected。</p><p>•若被声明为static,就变成了顶层类,不能再使用实例成员变量和局部变量。</p><p>•若想在内部类中声明任何static成员,则该内部类必须声明为static。</p><p>外部类不一定has a内部类。</p><blockquote><p>因此外部类与内部类的访问原则是：在外部类中，通过一个内部类的对象引用内部类中的成员；反之，在内部类中可以直接引用它的外部类的成员，包括静态成员、实例成员。</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312202322840.webp" alt="image-20231220232213715"></p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312202321627.webp" alt="image-20231220232147418"></p><blockquote><p>6、关于匿名内部类叙述正确的是？ (  )</p><p>A、匿名内部类可以继承一个基类，不可以实现一个接口</p><p>B、匿名内部类不可以定义构造器</p><p>C、匿名内部类不能用于形参</p><p>D、以上说法都不正确</p><p> 答案：B，因为匿名内部类不能有构造器，需要将构造参数传给超类构造器。C可以用于形参，见下面的代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Exercise;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestInnerClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;可以飞&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.name=name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.setName(<span class="string">&quot;鹦鹉&quot;</span>);</span><br><span class="line">        System.out.print(animal.getName());</span><br><span class="line">        animal.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般用于实现事件监听器和回调，搭配lamda表达式使用。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312202325586.webp" alt="image-20231220232556452"></p><blockquote><p>1、匿名内部类和嵌套类的概念和注意事项</p><p>匿名内部类：</p><p>只创建这个类的一个对象，不用为它命名。在定义类的同时，就生成该类的一个实例，并且不会在其他地方听到这个类。</p><p>用于构造对象的任何参数都要被放在超类名后面的括号内。</p><p>匿名内部类不能有构造器。</p><p>匿名内部类既可以拓展类，也可以拓展接口。同时只能且必须实现一个类或者是一个接口。</p><p>匿名内部类是局部内部类的一种。</p><p>嵌套类：</p><p>在一个类中定义另外一个类。</p><p>嵌套类的范围受其封闭类的范围限制。</p><p>嵌套类可以访问封闭类的成员，包括私有成员。</p><p>嵌套类可以被声明为private public protected或package private。</p><p>内部类是非静态嵌套类。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="子类的构造函数"><a href="#子类的构造函数" class="headerlink" title="子类的构造函数"></a>子类的构造函数</h4><p>在子类中需要指定父类的构造函数的时候，使用<code>super(var args)</code>调用父类的指定构造函数，如下图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TempClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    TempClass ()&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;specific name&quot;</span>);</span><br><span class="line">        name=<span class="string">&quot;default son&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的继承中构造函数的调用顺序：先执行父类构造函数。当然，在手动调用父类的构造函数的时候，父类的构造函数也必须位于子类构造函数的第一行，否则编译器会报错：<code>call to super() must be first statement in constructor body</code>。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312161859458.webp" alt="image-20231216185911260"></p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>向上转型是指将一个<strong>子类的实例赋值给其父类的引用变量</strong>。这种转型是安全的，因为子类对象包含了父类对象的所有属性和方法，所以可以通过父类引用变量来统一使用不同的子类。所以，当使用父类引用（指针）管理子类对象的时候，访问的变量是<strong>父类变量</strong>，但是调用的方法是<strong>子类的方法</strong>。</p><p>能覆盖的是基类的域（变量）、静态方法，不能覆盖的是非静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">field</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">field</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSuperField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>(); <span class="comment">// 向上转型，使用父类引用指向子类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field + <span class="string">&quot;, sup.getField() = &quot;</span> + sup.getField());</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sub.field + <span class="string">&quot;, sub.getField() = &quot;</span> + sub.getField() + <span class="string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sup.field = 0, sup.getField() = 1</span><br><span class="line">sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</span><br></pre></td></tr></table></figure><h4 id="静态绑定与动态绑定"><a href="#静态绑定与动态绑定" class="headerlink" title="静态绑定与动态绑定"></a>静态绑定与动态绑定</h4><p>静态绑定也就是编译时绑定，动态绑定是运行时绑定。</p><p>静态方法、私有方法、final方法使用静态绑定，其他方法使用动态绑定。和向上转型类似，都是为了实现多态。如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSub</span> <span class="keyword">extends</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticSuper</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSub</span>(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(sup.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base staticGet()</span><br><span class="line">Derived dynamicGet()</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Java 不支持多继承性,即一个类只能有一个父类。单继承性使得Java类层次简单,易于程序的管理。为了克服单继承的缺点,Java使用了接口,一个类可以实现多个接口。使用关键字interface 来定义一个接口。接口的定义和类的定义很相似,分为接口声明和接口体两部分。在接口中，抽象方法可以省略</p><h4 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h4><p>我们曾使用class关键字来声明类，接口通过使用关键字interface来声明。完整的接口定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">interface</span> <span class="title class_">interfaceName</span> [<span class="keyword">extends</span> <span class="title class_">listOfSuperInterface</span>]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中public修饰符指明任意类均可以使用这个接口，缺省情况下，只有与该接口定义在同一个包中的类才可以访问这个接口。extends子句与类声明中的extends子句基本相同，不同的是一个接口可以有多个父接口，用逗号隔开，而一个类只能有一个父类。子接口继承父接口中所有的常量和方法。</p><p>通常接口名称以able或ible结尾，表明接口能完成一定的行为，例如Runnable、Serializable。</p><h4 id="接口体"><a href="#接口体" class="headerlink" title="接口体"></a>接口体</h4><p>接口体中包含常量定义和方法定义两部分。其中常量具有public、static和final属性。</p><p>接口中只能进行方法的声明，而不提供方法的实现，所以，方法定义没有方法体，且用分号(;)结尾，在接口中声明的方法具有public和abstract属性。另外，如果在子接口中定义了和父接口同名的常量，则父接口中的常量被隐藏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Summaryable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MAX=<span class="number">50</span>; <span class="comment">// 接口中的属性具有public、static、final属性</span></span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">printone</span><span class="params">(<span class="type">float</span> x)</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> x ,<span class="type">float</span> y)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//jdk8以后，接口可以有默认实现，需要使用default实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// jdk8以后接口可以有静态函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h4><p>一个类通过使用关键字implements 声明自己使用（或实现）一个或多个接口。如果使用多个接口,用逗号隔开接口名。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculate</span> <span class="keyword">extends</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Summary</span>,Substractable&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Calculate使用了Summary 和Substractable接口,继承了Computer类。</p><p>如果一个类使用了某个接口,那么这个类必须实现该接口的所有方法,即为这些方法提供方法体。需要注意的如下：</p><p>1）在类中实现接口的方法时,方法的名字,返回类型,参数个数及类型必须与接口中的完全一致。</p><p>2）接口中的方法被默认是public ,所以类在实现接口方法时,一定要用public 来修饰。</p><p>3）另外,如果接口的方法的返回类型如果不是void 的,那么在类中实现该接口方法时,方法体至少要有一个return 语句。</p><p>4）抽象类实现接口的时候，可以不实现所有接口。</p><p>接口的调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface usbInterface)</span>&#123;</span><br><span class="line">        usbInterface.start();</span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口优点及与抽象类比较"><a href="#接口优点及与抽象类比较" class="headerlink" title="接口优点及与抽象类比较"></a>接口优点及与抽象类比较</h4><p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。通过接口使得处于不同层次，甚至互不相关的类可以具有相同的行为。接口其实就是方法定义和常量值的集合。</p><p><strong>优点：</strong></p><p>(1)通过接口可以实现<strong>不相关类的相同行为</strong>，而不需要考虑这些类之间的层次关系。</p><p>(2)通过接口可以指明类的多个需要实现的方法。</p><p>(3)通过接口可以了解对象的交互界面，而不需了解对象所对应的类。</p><p>接口把方法的定义和类的层次区分开来，通过它可以在运行时动态地定位所调用的方法。同时接口中可以实现“多重继承”，且一个类可以实现多个接口。正是这些机制使得接口提供了比多重继承（如C++等语言）更简单、更灵活、而且更强劲的功能。  </p><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>Java异常分为两种：Error和Exception，都继承自Throwable。</p><ul><li>Error错误：Java虚拟机无法解决的严重问题，如OOM等，程序会崩溃，无法捕获。</li><li>Exception异常：其他因为编程错误导致的一般性问题，可以捕获或抛出。包括运行时异常（如数组下标越界）和编译时异常（如FileNotFound异常），如不处理编译异常，则编译无法通过。</li></ul><p>层级关系如下图所示：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171137589.webp" alt="image-20231217113741371"></p><p>异常处理有两种方式：捕获异常和抛出异常。</p><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>try-catch-finnally处理机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码可能有异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">// 捕获到异常</span></span><br><span class="line">    <span class="comment">// 系统将异常对象封装成为Exception e</span></span><br><span class="line">    <span class="comment">// 程序员可以自己写处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ++i</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管try代码块是否异常，始终要执行finally</span></span><br><span class="line">    <span class="comment">// 通常会放资源的关闭，如SQL连接，关闭文件等</span></span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally无论是否错误，都会执行，即便在catch中执行return语句。如上图，两个++i都会执行，不过return的 i 比最终的 i 小1。</p><p>throws处理机制：</p><p>在函数调用堆栈中，如果当前方法不想处理异常，可以将异常抛出到调用者，调用者可以执行try-catch-finally捕获，也可以继续抛出。当异常到达JVM的时候，程序会被中断，输出异常信息。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171223815.webp" alt="image-20231217122322601"></p><p>一般来说，函数默认处理方式是抛出一个Exception异常，即处理形式如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171228177.webp" alt="image-20231217122848041"></p><p>子类继承父类的时候，所抛出的异常类型要么是父类的异常，要么是父类异常的子异常，例如父类抛出RuntimeException，子类抛出NullPointerException，是合理的异常。</p><p>throw和throws的区别如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171356553.webp" alt="image-20231217135613297"></p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常的本质是<strong>自定义异常信息</strong>以及<strong>抛出异常的条件</strong>。</p><p>自定义异常步骤：</p><ol><li>自定义类名，继承Exception和RuntimeException。</li><li>如果继承Exception，属于编译异常。</li><li>如果继承RuntimeException，属于运行异常，一般继承RuntimeException。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age&gt;=<span class="number">18</span>&amp;&amp;age&lt;=<span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在18~120之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h2><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>在Java中，基本数据类型的自动装箱（autoboxing）和自动拆箱（unboxing）是编译器提供的便利功能，用于在基本数据类型和其对应的包装类型之间进行转换。</p><ul><li>自动装箱（Autoboxing）：将基本数据类型自动转换为对应的包装类型</li><li>自动拆箱（Unboxing）：将包装类型自动转换为对应的基本数据类型</li></ul><p>-128~127之间的数字，存在内存中加速访问。</p><h2 id="JavaIO"><a href="#JavaIO" class="headerlink" title="JavaIO"></a>JavaIO</h2><p>什么是流？可以从中读入<strong>一个字节序列</strong>的对象称作输入流，可以向其中写入<strong>一个字节序列</strong>的对象称作输出流。字节序列是任意长度的Byte，所以按照某个固定长度单位读写的对象不是流。</p><p>Java的流分为字符流和字节流两类，两者读写数据的单位不一样，但是操作方法类似，都是Read和Write两个方法。</p><blockquote><p>字节流：单位是1Byte，不使用缓冲区</p><p>字符流：单位是2Byte的Unicode字符，使用缓冲区</p></blockquote><h3 id="字节流处理"><a href="#字节流处理" class="headerlink" title="字节流处理"></a>字节流处理</h3><p>Inputstream, outputstream, fileinputstream, fileoutputstream, InputStream和OutputStream都是抽象类，不能实例化，因此在实际应用中都使用的是他们的子类。Java通过系统类System实现标准输入输出的功能，定义了3个流变量，in，out和err。System.in作为字节输入流类InputStream的对象实现标准输入。System.out作为打印流类PrintStream的对象实现标准输出。</p><p>FileInputStream和FileOutputStream用于进行文件的输入输出处理，其数据源和接收器都是文件。 FileInputStream用于顺序访问本地文件，FileInputStream重写了抽象类InputStream的读取数据的方法。FileOutputStream用于向一个文本文件写数据，FileOutputStream重写了抽象类OutputStream的写数据的方法。</p><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><p>Java通过System类实现了标准输入输出功能，定义了三个流：</p><ul><li>static PrintStream err </li><li>static InputStream in </li><li>static PrintStream out</li></ul><p>使用System.out可以获取输出流PrintStream，包括Println等函数，可以直接用于打印。System.err可以理解以报错形式呈现的System.out。使用System.in获取的输入流是字节流，封装的函数较少，如下如所示。因此，获取标准输入的时候，常用Scanner类组合操作。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312121931488.webp" alt="image-20231212193146247"></p><p>使用<code>Scanner</code>类的<code>hasNext()</code>方法，它检查输入流中是否有下一个标记可供扫描。但是，如果没有更多的输入可用，<code>hasNext()</code>方法将会阻塞，即使输入流已经关闭。</p><p><strong>标准输入输出的示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scanner= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span>(scanner.hasNext())&#123; <span class="comment">// 这里的while会一直阻塞，类似while(cin&gt;&gt;str)，除非手动break</span></span><br><span class="line">    String str=scanner.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带退出功能的输入循环：</strong>自己写一个退出标志，关闭scanner并且退出循环。可以直接break不close，但是不可以close不break。因为<code>scanner.close()</code>之后调用<code>scanner.hasNext()</code>会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">    String str=scanner.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;\exit&quot;</span>))&#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Reader&#x2F;Writer是Java用来处理字符流的类。它们是以字符为单位进行读写操作，适用于处理文本数据。FileReader和FileWriter提供了字符文件读写的。</p><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>InputStream和OutputStream都是抽象类，不能直接实例化，实际使用需要实例化流类的子类，例如标准输入输出流，文件流等等。</p><p>FileInputStream和FileOutputStream是文件处理流类，数据源和接收器都是文件。其中FileOutputStream的创建不依赖文件是否存在。例如下面的代码中，文件系统并不存在hello.test文件，但是实际可以直接写入，证明了FileOutputStream不依赖于文件是否存在。</p><p><strong>文件读示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./src/FileIO/hello.test&quot;</span>);</span><br><span class="line">FileOutputStream oStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">String s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">oStream.write(s.getBytes());</span><br></pre></td></tr></table></figure><p>文件的读写需要使用File类和Stream类结合使用，File类提供文件级的操作，如创建，打开等等。Stream则提供字节级的操作，<code>s.getBytes()</code>的作用就是获取字符串的字节流并将其写入文件中。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是啥就不多说了，下面直接讲java线程的使用。线程的使用主要依靠<code>java.lang.Thread</code>支持多线程编程。</p><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>线程的创建使用Thread()，有多种重载方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread();</span><br><span class="line">Thread(Runnable target);</span><br><span class="line">Thread(Runnable target,String name);</span><br><span class="line">Thread(String name);</span><br><span class="line">Thread(ThreadGroup group, Runnable target);</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name);</span><br><span class="line">Thread(ThreadGroup group, String name);</span><br></pre></td></tr></table></figure><p>参数target是线程执行的目标对象，也就是目标代码，group是线程组，name是线程名称。</p><h4 id="采用继承创建线程"><a href="#采用继承创建线程" class="headerlink" title="采用继承创建线程"></a>采用继承创建线程</h4><p>通过继承Thread类，并覆盖Thread类中的run()方法完成线程的创建。</p><p>Thread有两个最重要的方法：run()和start()，其中run()方法中写线程代码的逻辑，start()方法首先会进行多线程相关的初始化，然后再执行run()方法。</p><p>采用继承创建线程的示例代码如下，继承方式实现比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">            MyThread t=<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口创建线程"><a href="#实现接口创建线程" class="headerlink" title="实现接口创建线程"></a>实现接口创建线程</h4><p>使用这种方法创建线程，需要实现java.lang.Runnable接口创建多线程。</p><p>注意，使用这种方法，需要先new一个自己实现的子线程对象，然后再new一个Thread对象，然后将子线程对象传入Thread中，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        MyThread2 mt2=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt2);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两段代码的输出结果：不确定，一般在9990~9999之间，思考为什么？</p><h3 id="线程生命周期和调度"><a href="#线程生命周期和调度" class="headerlink" title="线程生命周期和调度"></a>线程生命周期和调度</h3><h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p>线程是动态的，生命周期有六个：NEW，RUNNABLE，BLOCKED，WAITING，TIMED WAITING，TERMINATED六种。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171613815.webp" alt="image-20231217161324619"></p><p>Java的线程调度策略是固定优先级的抢占式调度：高优先级的进程可以抢占低优先级的进程，同优先级的进程按照时间片轮转。</p><p>Java线程分为十个等级，为1~10，10是最高优先级，默认优先级为5。宏定义：</p><ol><li>MIN_PRIORITY：1</li><li>NORMAL_PRIORITY：10</li><li>MAX_PRIORITY：5</li></ol><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>线程中断的方法：</p><ol><li>设置特定变量，控制run()方法</li><li>使用interrupt，中断当前状态，该线程会抛出一个InterruptException，可以在catch中加入自己的控制逻辑。</li></ol><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>在Java中，线程可以分为两种类型：用户线程（User Thread）和守护线程（Daemon Thread）。</p><p>守护线程是一种在后台运行的线程，它的存在并不会阻止程序的终止。当所有的用户线程都结束时，守护线程会自动被终止，即使它还没有执行完毕。与之相对，用户线程的执行完毕是程序终止的一个条件。</p><p>守护线程通常被用于执行某些支持性任务，例如垃圾回收（Garbage Collection）线程就是一个守护线程。JVM的垃圾回收线程在后台运行，负责回收不再使用的对象，释放内存资源。</p><p>设置守护线程的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt.setDaemon(True);</span><br></pre></td></tr></table></figure><p>如果将线程dt设置为守护线程，当所有线程结束后，dt也会自动结束。如果没有设置，即使main线程执行完毕，dt也不退出。</p><h3 id="线程同步与互斥"><a href="#线程同步与互斥" class="headerlink" title="线程同步与互斥"></a>线程同步与互斥</h3><p>什么是同步？线程同步是指有一个线程在对内存进行操作的时候，其他线程不可以对这个内存地址进行操作，直到该线程完成。这里的同步，是指<strong>临界区的同步</strong>，所有线程必须保证临界区的数据完全一致，所以同一时刻只能有一个线程写。</p><h4 id="synchronized同步"><a href="#synchronized同步" class="headerlink" title="synchronized同步"></a>synchronized同步</h4><p>想想上面的多线程代码，分开10000个线程，每个线程都对count+1，最终的结果却总不是10000，为什么？</p><p>这是因为count是临界区，多个线程对其进行访问，但是没有上互斥锁，导致丢失修改。为了解决这个问题，可以使用Java中的syncchronized关键字解决，基本语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (互斥对象Object)&#123;</span><br><span class="line">    <span class="comment">// 临界代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，互斥对象是一个具体的对象，具备了临界代码的数据。在Java底层，每一个对象都对应于一个可称为“互斥锁”的标记，这个标记可以保证在任意时刻只有一个线程访问。因此，把类中的任意一个成员对象放入synchronized之后，所有的类访问的都是同一个对象，并且具备互斥访问的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种写法如下：synchronized放在方法中，表示整个方法为同步方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出最终的计数结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + example.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免死锁的方法：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312171928289.webp" alt="image-20231217192724302"></p><p>不要出现两个相互请求资源的synchronized代码块。</p><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p>一个完整的通讯程序应该包含如下的步骤：</p><ol><li>创建Socket。</li><li>打开连接到Socket的输入&#x2F;输出流。</li><li>按照一定的协议对Socket进行读&#x2F;写操作。</li><li>关闭Socket。</li></ol><h3 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h3><p>服务器的任务就是等候建立一个连接，然后使用该连接的Socket建立一个InputStream（用于接收数据）和OutputStream（用于发送数据）。</p><p>首先，服务器需要先启动，监听一个端口，记为sp。然后调用accpt()函数开始工作，准备接受客户端的Socket。Socket s&#x3D;accept()函数会阻塞线程，直到有一个新的Socket接入，然后将其赋值<code>Socket socket=serverSocket.accept();</code>一旦过了这句话，就表明建立了连接。</p><p>服务器程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">5354</span>);</span><br><span class="line">            Socket socket=serverSocket.accept();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader in=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                PrintWriter out=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream())),<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    String str=in.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(str.equals(<span class="string">&quot;END&quot;</span>))&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(str);</span><br><span class="line">                    out.println(<span class="string">&quot;服务器在鹦鹉学舌：&quot;</span>+str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：accept会抛出异常，因此需要一个单独的try语句。后面的所有操作都应该包含在try中，以便处理异常。</p><h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;172.18.157.129&quot;</span>,<span class="number">5354</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Socket=&quot;</span>+socket);</span><br><span class="line">            BufferedReader in=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            PrintWriter out=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()),<span class="literal">true</span>);</span><br><span class="line">            InputStreamReader stdin=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">            BufferedReader stdin_reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(stdin);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                String std=stdin_reader.readLine();</span><br><span class="line">                out.println(std);</span><br><span class="line">                System.out.println(<span class="string">&quot;发送了&quot;</span>+std);</span><br><span class="line">                String str=in.readLine();</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程是创建一个Socket，指定需要连接的服务器ip:port，然后这个套接字就会尝试往服务器套入。当被accept()之后，双方建立连接开始通信。</p><p>工作过程可以简化为下面的图，单个Socket连接的过程就像打电话一样，客户端指定对方身份（ip+port），然后拨出，接通后，两边都显示对方的手机号（ip+port）。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312202143037.webp" alt="image-20231220214344844"></p><h3 id="多线程服务端"><a href="#多线程服务端" class="headerlink" title="多线程服务端"></a>多线程服务端</h3><p>多线程的服务端代码如下，在下面的代码中，使用一个ServerWorker继承了Thread线程基类，然后重写run方法，运行新的线程。这里不用担心线程过多，因为客户端断开连接的时候，readLine函数会抛出异常，Connection reset，然后会执行finally后面的语句，也就是关闭socket连接。这就是前面要求可能抛出异常的地方都要使用try-catch-finally的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServerWorker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerWorker</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        socket=s;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">        out=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()),<span class="literal">true</span>);</span><br><span class="line">        number=++ServerWorker.count;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                String str=in.readLine();</span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">&quot;END&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(number+<span class="string">&quot;收到了：&quot;</span>+str);</span><br><span class="line">                out.println(number+<span class="string">&quot;收到了：&quot;</span>+str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> PORT=<span class="number">5354</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//这里会阻塞，直到一个新的Socket连接</span></span><br><span class="line">                Socket socket=s.accept();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ServerWorker</span>(socket);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            s.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>27</strong>、下面这三条语句</p><p>  System.out.println(“is ”+ 100 + 5)； </p><p>  System.out.println(100 + 5 +“ is”)；</p><p>  System.out.println(“is ”+ (100 + 5))；</p><p>的输出结果分别是？ (  )</p><p>A、is 1005, 1005 is, is 1005</p><p>B、is 105, 105 is, is 105</p><p>C、is 1005, 1005 is, is 105</p><p>&#x3D;&#x3D;D、is 1005, 105 is, is 105&#x3D;&#x3D;</p><p>考+号的左结合性。</p></blockquote><blockquote><p><strong>7</strong>、下列程序段执行后，运行结果为   AB,B   。</p><p>public class Foo {</p><p>public static void main (String [] args) { </p><p>StringBuffer a &#x3D; new StringBuffer (“A”);</p><p>StringBuffer b &#x3D; new StringBuffer (“B”);</p><p>operate(a,b);</p><p>System.out.printIn(a + “,” +b);</p><p>}</p><p>static void operate (StringBuffer x, StringBuffer y) {</p><p>​        x.append(y);</p><p>​y &#x3D; x;</p><p>​    }</p><p>}</p></blockquote><blockquote><p>静态内部类不可以直接访问外围类的数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ 对）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一看就明白的Go语言并发教程</title>
      <link href="/2023/08/24/%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%98%8E%E7%99%BD%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B/"/>
      <url>/2023/08/24/%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%98%8E%E7%99%BD%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Go语言提供了强大的并发编程能力，通过Goroutines、Channels和互斥锁等机制，使得并发编程变得简单和高效。本文将使用通俗的语言和简单的案例讲述Go语言并发编程的那些事儿。<span id="more"></span></p><h1 id="一看就明白的Go语言并发教程"><a href="#一看就明白的Go语言并发教程" class="headerlink" title="一看就明白的Go语言并发教程"></a>一看就明白的Go语言并发教程</h1><h2 id="Go线程实现原理"><a href="#Go线程实现原理" class="headerlink" title="Go线程实现原理"></a>Go线程实现原理</h2><h3 id="Go线程模型的三要素"><a href="#Go线程模型的三要素" class="headerlink" title="Go线程模型的三要素"></a>Go线程模型的三要素</h3><ul><li>M(machine)：一个M代表一个内核级线程，或称“工作线程”，在Go语言中，Machine通常对应于一个操作系统线程，它可以在CPU上执行指令。</li><li>P(processor)：一个P代表一个Go语言代码片段所需要的资源（或称上下文环境），它是Go调度器自己实现的一种调度单元。</li><li>G(goroutine)：一个G代表一个Go语言的代码片段，G是对Go代码段的封装。</li></ul><p>三者之间的关系如下图：</p><pre class="mermaid">graph TD;  Machine((Machine)) --> Processor((Processor));  Processor((Processor)) --> Machine((Machine));  Processor --> Goroutine1((Goroutine 1));  Processor --> Goroutine2((Goroutine 2));  Processor --> ...((...));  Processor --> Goroutinen((Goroutine n));</pre><p>简单来说，G的执行需要P和M的支持，一个M在与P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境），每一个P都会包含一个可运行的G队列，该队列中的G会被依次传递给与其上层P关联的M中，即可以使用CPU运行G中的代码。</p><p>这个模型的核心思想是将多个goroutine调度到少量的处理器上执行，避免了每个goroutine都与操作系统线程直接关联，从而提高了并发效率。</p><h3 id="Go调度器"><a href="#Go调度器" class="headerlink" title="Go调度器"></a>Go调度器</h3><p>Go语言调度器是Go运行时的一部分，负责管理和调度goroutine的执行。调度器是Go语言并发模型的核心组件之一，它实现了在多个goroutine之间进行切换，从而实现并发执行的能力。调度器的主要目标是充分利用CPU资源，实现高效的并发和并行执行。</p><p>Go语言调度器具有以下特点：</p><ul><li>基于G-P-M模型：即上文的Goroutine，Processor，Machine模型。</li><li>调度单位是处理器P：一个处理器可以在一个操作系统线程上运行，但是多个处理器可以在同一个线程上轮流执行，以实现更高的并发。处理器还负责管理goroutine的调度、垃圾回收等任务。</li><li>抢占式调度与协作式调度：在调度策略中，调度器的调度是抢占式的：当一个goroutine执行时间超过一定阈值时，调度器可以中断它并切换到另一个goroutine。而goroutine也可以自行退出，比如遇到网络请求或者IO操作的时候，可以自愿放弃执行，这种方式叫做协作式调度。</li><li>垃圾回收：调度器还负责协调垃圾回收。当垃圾回收器运行时，调度器会暂停所有goroutine的执行，确保垃圾回收可以安全地执行。垃圾回收通常会在处理器完成当前任务后执行，以减少对应用程序的干扰。</li></ul><h2 id="并发与协程-Goroutine"><a href="#并发与协程-Goroutine" class="headerlink" title="并发与协程(Goroutine)"></a>并发与协程(Goroutine)</h2><h3 id="Goroutine简介"><a href="#Goroutine简介" class="headerlink" title="Goroutine简介"></a>Goroutine简介</h3><p>在操作系统提供的线程模型之上，Go语言通过goroutine实现了协程的概念，它是一种非常轻量级的执行单元。与传统的线程相比，goroutine的创建和销毁开销非常小，因此可以创建成千上万个goroutine，而不会消耗大量的内存和系统资源。</p><ul><li>协程：用户态，轻量级线程，栈大小处于KB级别</li><li>线程：内核态，线程可以跑多个协程，栈大小处于MB级别</li></ul><p>协程的调度和使用由Go语言完成，这就是Go语言的高并发的基本条件。</p><h3 id="GO语言实现协程"><a href="#GO语言实现协程" class="headerlink" title="GO语言实现协程"></a>GO语言实现协程</h3><p>通过使用关键字<code>go</code>，可以在Go程序中启动一个goroutine，使得一个函数在一个独立的协程中并发执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello routine&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">hello(j)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>go func(j int) &#123; ... &#125;(i)</code>：在每次循环迭代时，都会启动一个新的goroutine，执行一个匿名函数。这个匿名函数接受一个整数参数<code>j</code>，该参数被初始化为当前循环变量<code>i</code>的值。<code>time.Sleep(time.Second)</code>是为了能够确保所有goroutine都结束之后再结束主函数。</p><p>上述代码也可以简写成为如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> hello(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行两次，结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308241954085.webp" alt="image-20230824195449942"></p><p>这里可以看到五个协程的执行顺序是不一样的，这是由于操作系统的调度和Go语言调度的不确定性，Go的调度器会根据不同的策略将goroutines分配给不同的线程执行。这会导致不同的goroutines在不同的时间上交替执行，从而产生不确定的结果。</p><h3 id="协程间通信"><a href="#协程间通信" class="headerlink" title="协程间通信"></a>协程间通信</h3><p>Go语言有一句著名的标语：通过通信实现共享内存，而不是通过共享内存实现通信。下图展现了这两种思想的不同：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021453324.webp" alt="image-20230726101648650"></p><p>在传统的操作系统做法中，把数据放在共享内存中以供多个线程访问，这种思想看似简单，实际上使得并发控制变得异常困难。Go不推荐使用共享内存传递数据，而是采用channel通信传递数据，当然还保留一些传统方法的实现（比如互斥量）。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>通道分为有缓冲通道和无缓冲通道。使用通道的一个实例，一个协程输入数字，一个协程计算平方，主协程打印结果，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calSquare</span><span class="params">()</span></span> &#123;</span><br><span class="line">src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//子协程1发送数字0-9</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">src &lt;- i</span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//子协程2计算输入数字的平方</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">dest &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//主协程打印数字</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123;</span><br><span class="line"><span class="built_in">println</span>(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;平方数&quot;</span>, i, <span class="string">&quot;通道内元素个数&quot;</span>, <span class="built_in">len</span>(dest))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">calSquare()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建channel：使用make关键字可以创建channel，比如<code>make(chan,int)</code>是一个传递整形的无缓冲channel，而<code>make(chan int, 3)</code>则是一个缓冲区大小为3的channel。</li><li>channel输入：往channel里面输入数据需要用到左箭头<code>&lt;-</code>，表示将右操作数送到左操作数表示的channel中。</li><li>channel输出：需要获取channel里面的内容时，句式为<code>for i := range dest</code>，需要注意的是：当通道为空时，<code>for</code>循环会停止执行，并等待新的数据到达通道，然后继续处理数据。</li></ul><p>我们可以看一下，上述代码在正常情况下时可以在ms级别的时间内完成运算的，如下图：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251359124.webp" alt="image-20230825135945958"></p><p>然而，当我们使得生产数据的协程每生产完一个数据后休息1秒，输出结果：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251401755.webp" alt="image-20230825140134605"></p><p>我们发现每次处理完之后，channel的大小都为0，但是都进行了下一次的平方数计算。这个例子说明了for循环把channel缓冲区里面的数据读完之后并不会立刻结束循环，而是陷入阻塞状态，等到有新的数据来到，就立刻工作。举个形象的例子，这三个协程就像是流水线上面的三个工人，子协程1效率比较低，1秒钟才生产一个配件，给到后面的协程都是立刻完成，但是后面的协程看到传送带没东西来就下班了吗？并不是，而是继续在原地等待新的零件到来，直到这条流水线关闭，即<code>defer close(src)</code>语句执行。</p><pre class="mermaid">graph TD;    A[子协程1] -->|src| B[子协程2];    B -->|dest| C[主协程];</pre><h3 id="线程同步WaitGroup"><a href="#线程同步WaitGroup" class="headerlink" title="线程同步WaitGroup"></a>线程同步WaitGroup</h3><p>在 Go 语言中，<code>sync.WaitGroup</code> 是用于等待一组 Goroutine 完成执行的同步原语。当我们开启多个协程的时候，我们并不知道哪一个协程最先完成，如果main函数结束的时候有部分协程还未结束，则会影响最终的输出结果。在上文中我们使用了<code>time.Sleep(time.Second)</code>确保所有协程都完成（因为人为可以确定1s的时间足够了），然后再退出主函数。但是当我们无法确定的时候，我们就需要使用WaitGroup再确保所有的Goroutine完成之后再执行下一步工作。下面这段代码演示了五个人开始工作，直到所有人完成工作再结束的场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少 WaitGroup 计数器</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d开始\n&quot;</span>, id)</span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 模拟工作时间</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d结束\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;所有协程结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251637828.webp" alt="image-20230825163731709"></p><p>可以看到，<code>wg.Wait()</code>一行代码等待所有 Goroutine 完成之后才算执行完毕，进入后面的打印代码。如果将这一行注释掉，那么所有Goroutine还未结束的时候就已经打印”所有协程结束”了，这很明显不符合逻辑，读者可以修改运行试试。</p><h2 id="Go语言同步"><a href="#Go语言同步" class="headerlink" title="Go语言同步"></a>Go语言同步</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>Go语言中使用标准库代码包sync和sync&#x2F;atomic实现同步操作。这一部分的知识需要一部分操作系统的基础知识，建议先去了解临界区、互斥量、信号量等名词。</p><h4 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h4><p>互斥锁是传统并发程序对于共享资源进行访问控制的主要手段，它由标准库代码包中的synnc中的Mutex类型表示。Muext类型只有三个公开的指针方法：Lock、Unlock和TryLock。其中TryLock是测试并加锁的函数，返回值为bool，当可以上锁的时候返回true。Lock方法尝试对互斥量进行加锁，如果互斥量未被锁，那么该方法会对Lock进行加锁。如果该互斥量已被上锁，那么调用该方法的goroutine会阻塞直到获取互斥量。</p><p>下面将使用一个例子具体描述互斥锁的工作过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AddWithMutex 使用互斥锁对num1进行加1操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddWithMutex</span><span class="params">(num1 *<span class="type">int</span>, mutex *sync.Mutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">*num1++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddWithoutMutex 不使用互斥锁对num2进行加1操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddWithoutMutex</span><span class="params">(num2 *<span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">*num2++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">num1 := <span class="number">0</span></span><br><span class="line">num2 := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 10000个协程同时对num1和num2进行加1操作</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> AddWithMutex(&amp;num1, &amp;mutex, &amp;wg)</span><br><span class="line"><span class="keyword">go</span> AddWithoutMutex(&amp;num2, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;num1 with lock:&quot;</span>, num1)</span><br><span class="line">fmt.Println(<span class="string">&quot;num2 without lock:&quot;</span>, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">AddTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别启动了10000个协程，对两个整数进行+1操作。其中num1使用互斥锁相加，每次+1之前对变量进行上锁，结束后释放锁，而num2不使用互斥锁。来看一下运行结果：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308282326129.webp" alt="image-20230828232559958"></p><p>num2没有加到10000，读者可以copy上述代码多运行几次，可以发现num2每次运行的结果都不一样，但是永远不会超过10000，怎么回事呢？这是因为num2的某些线程的修改丢失了，当某个goroutine拿到内存中的num2的值（假设为100）但还未+1时，突然它的运行时间到了，根据前面抢占式的原理，它被踢出运行态，改为就绪态，但是goroutine切换的时候寄存器还会保留当前goroutine的信息（即num2&#x3D;100），当他再次切回运行态的时候，num2已经是101了，但是这个被切换出去的goroutine还是会执行100+1&#x3D;101的操作，并将其写回内存地址中，最后导致其中一次修改丢失。</p><p>举个更容易理解的例子：在某一年的春运上，有很多人在抢最后一张机票，当用户A点击了购票但是还没付款的时候，假如购票系统没有对机票上锁，用户B也点击了购票并且比用户A更早付款完毕，写回机票数量为0。当A付款完毕之后，也写回机票数量为0，这就发生了丢失修改，两个人得到了机票，但是机票数量只减少了一张，这是明显不符合逻辑的。</p><p>正确的做法是对临界区的变量操作时，需要先对其进行上锁，操作完毕之后就释放锁。这样就可以保证每一个goroutine的修改都是有效的。</p><h4 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h4><p>读写锁与一般互斥锁的主要区别为：</p><ul><li>当临界区未上锁时，可以添加读锁和写锁。</li><li>当临界区已有读锁时，可以继续添加读锁，但无法添加写锁。</li><li>当临界区已有写锁时，不可以再添加任何锁。</li></ul><p>写解锁会试图唤醒所有因为要进行读或写锁定而阻塞的goroutine，而读解锁只会在没有任何锁定的情况下试图唤醒因为要进行写锁定而被阻塞的goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟读操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(mutex *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> mutex.TryRLock() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;上读锁&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;无法上读锁&quot;</span>)</span><br><span class="line">mutex.RLock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟读2秒</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"><span class="built_in">println</span>(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;读操作执行完毕&quot;</span>)</span><br><span class="line">mutex.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟写操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(mutex *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> mutex.TryLock() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;上写锁&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;无法上写锁&quot;</span>)</span><br><span class="line">mutex.Lock()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="built_in">println</span>(time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), <span class="string">&quot;写操作执行完毕&quot;</span>)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RWLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;开始时间&quot;</span>, time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">rwMutex := sync.RWMutex&#123;&#125;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="comment">//先读</span></span><br><span class="line"><span class="keyword">go</span> read(&amp;rwMutex, &amp;wg)</span><br><span class="line"><span class="comment">//1秒后尝试读，尝试写</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;尝试读写&quot;</span>, time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">go</span> read(&amp;rwMutex, &amp;wg)</span><br><span class="line"><span class="keyword">go</span> write(&amp;rwMutex, &amp;wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行观察结果：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308302051036.webp" alt="image-20230830205143846"></p><p>开始后立刻进行读操作（记为0s），读操作需要耗时两秒，而1s时刻同时开始读和写操作，由于临界区处于读加锁的情况，可以继续加读锁，但是不可以添加写锁，所以读操作被阻塞。2s时刻和3s时刻分别完成两次读操作，然后唤醒了写操作，经过5s后（即8s时刻），写操作完成，整个进程结束。</p><h3 id="条件变量Cond"><a href="#条件变量Cond" class="headerlink" title="条件变量Cond"></a>条件变量Cond</h3><h4 id="Cond简介"><a href="#Cond简介" class="headerlink" title="Cond简介"></a>Cond简介</h4><p>在Go语言中，条件变量（<code>Cond</code>）是一种用于实现协程之间的条件同步的机制。它允许协程在满足某个条件时等待其他协程的通知。条件变量常用于实现线程池、事件循环等并发场景。条件变量是利用共享的全局变量进行同步的一种机制：</p><ul><li>一个线程等待”条件变量的条件成立”挂起（或者说等待一个信号而睡眠）</li><li>另一个线程使”条件成立”（发送唤醒信号）</li></ul><p>因此条件变量的使用总是和一个互斥锁结合在一起使用，这种思想就像是IPC中的睡眠与唤醒。</p><h4 id="Cond使用场景"><a href="#Cond使用场景" class="headerlink" title="Cond使用场景"></a>Cond使用场景</h4><p>Mutex 通常用来保护临界区和共享资源，条件变量Cond 用来协调想要访问的共享资源。有一个协程正在接收数据，其他协程必须等待这个协程接收完数据，才能读取到正确的数据（比如生产者消费者问题）。</p><p>上述情形下，如果单纯的使用 channel 或者互斥锁，只能有一个协程可以等待，并读取到数据，没办法通知其他协程也读取数据。</p><h4 id="Go语言sync-Cond"><a href="#Go语言sync-Cond" class="headerlink" title="Go语言sync.Cond"></a>Go语言sync.Cond</h4><p>创建一个条件变量需要使用sync.NewCond的，sync.NewCond的唯一参数时sync.Locker类型的，可以是Mutex或者RWMutex，返回的结果是*sync.Cond类型的结构体，具有三个方法：</p><ul><li>Wait()：Wait方法会自动对与该条件变量相关联的那个锁进行解锁，并使它所在的goroutine阻塞。一旦收到通知，该方法所在的goroutine就会被唤醒，并且该方法会立即尝试锁定该锁。</li><li>Signal()：通知任意一个正在等待的goroutine，唤醒一个为此而阻塞的goroutine。</li><li>Broadcast()：通知所有正在等待的goroutine，唤醒所有为此而阻塞的goroutine。</li></ul><p>需要注意的是Wait方法会释放锁，如果在调用该方法之前没有获得锁，就会报错<code>fatal error: sync: unlock of unlocked mutex</code>，因此Cond的使用应该是goroutine进入临界区之后，某个条件还没到位，调用Wait释放锁并睡眠，等待Signal或者Broadcast唤醒。</p><p>下面是使用Go语言sync.Cond解决生产者消费者问题的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CondExample</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 生产者协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="built_in">println</span>(time.Now().Format(<span class="string">&quot;04:05&quot;</span>), <span class="string">&quot;开始生产&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟生产过程</span></span><br><span class="line">cond.Broadcast()            <span class="comment">// 发送信号通知消费者协程</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待信号</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">&quot;04:05&quot;</span>), <span class="string">&quot;消费者收到信号，开始处理&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">&quot;04:05&quot;</span>), <span class="string">&quot;程序结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设生产者协程需要2秒，消费者协程可以立刻进行，那么程序开始后，生产者开始生产，两秒后生产完成并broadcast，消费者收到信号，立即开始消费，程序结束。运行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202309032029555.webp" alt="image-20230903202854380"></p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作（Atomic Operation）是计算机科学中的一个重要概念，它表示一组操作在执行过程中不会被中断，不会被其他并发操作干扰，并且在执行完毕后不可再分割为更小的操作单元。例如，Go语言提供了<code>sync/atomic</code>包，用于执行原子操作。这些操作通常包括原子加载、原子存储、原子增加、原子交换等。</p><h4 id="原子增-减"><a href="#原子增-减" class="headerlink" title="原子增&#x2F;减"></a>原子增&#x2F;减</h4><p><strong>原子增加（Atomic Increment）：</strong> 这是一个原子操作，用于增加一个共享变量的值。无论有多少个线程或进程尝试增加这个变量的值，只有一个线程能够成功执行增加操作。<strong>原子减少（Atomic Decrement）</strong>也同理。</p><p>在Go语言的 <code>sync/atomic</code> 包中，<code>AddInt32</code>、<code>AddInt64</code>、<code>AddUint32</code>、<code>AddUint64</code> 等函数用于执行原子增加操作。想要执行原子减操作时，可以在函数参数中传入负数，下面是一个原子增操作的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i32 <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> ii2 <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">ii2++</span><br><span class="line">&#125;()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">atomic.AddInt32(&amp;i32, <span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;原子加&quot;</span>, i32)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;直接++&quot;</span>, ii2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高并发的情况下，10000个goroutine使用原子操作依然能够保证程序的正确性，而直接相加则会在高并发的情况下出现丢失修改，无法达到10000。</p><h4 id="比较和交换CAS"><a href="#比较和交换CAS" class="headerlink" title="比较和交换CAS"></a>比较和交换CAS</h4><p>比较和交换（Compare and Swap，通常缩写为CAS）是计算机科学中的一种原子操作，用于实现并发编程中的同步和互斥。它是一种基于共享内存模型的原子操作，通常用于多线程或多进程并发环境中，以确保对共享数据的安全访问。</p><p><code>atomic.CompareAndSwap</code> 是 Go 语言中用于执行比较和交换（CAS）操作的函数，它允许在多个 goroutine 之间安全地操作共享变量。该函数有三个参数：</p><ul><li><strong>指针参数（ptr）：</strong> 这是一个指向共享变量的指针，通常是一个内存地址。</li><li><strong>旧值参数（old）：</strong> 这是你期望共享变量的当前值等于的值。</li><li><strong>新值参数（new）：</strong> 如果共享变量的当前值等于旧值参数，那么它将被更新为新值参数。</li></ul><p>例如，一个int32类型的CAS函数形式：<code>func CompareAndSwapInt32(addr *int32, old, new int32) bool</code>,执行该函数的时候，会先判断参数addr指向的地址值是否等于old值，如果等于old值，才会替换成为new值。如不相等，后面的替换操作就会忽略。</p><p>CAS的思想总是存在一个假设，就是该操作的值未曾改变，也就是和old值相等，一旦确认这个假设的真实性就进行替换。而使用锁则是更加谨慎，锁的思想总是假设会有并发的操作修改目标变量，并需要用锁将相关的操作保护起来。可以说，使用锁的方法比较悲观，使用CAS的方法比较乐观。所以CAS的优势是不创建互斥量的情况下完成并发操作，减少同步程序的性能消耗。劣势是目标变量被频繁修改的情况下CAS操作成功率低，甚至需要一个for循环来确保该操作完成（这就是函数返回bool类型的原因）。</p><p>下面是一个使用CAS完成并发操作的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CAS</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="type">int32</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">const</span> numGoroutines = <span class="number">100000000</span></span><br><span class="line">    wg.Add(numGoroutines)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 死循环尝试递增计数器的值</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                oldValue := atomic.LoadInt32(&amp;counter)</span><br><span class="line">                newValue := oldValue + <span class="number">1</span></span><br><span class="line">                <span class="comment">// 尝试 CAS 操作</span></span><br><span class="line">                <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;counter, oldValue, newValue) &#123;</span><br><span class="line">                    <span class="keyword">break</span> <span class="comment">// CAS 成功，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;结束时间&quot;</span>, time.Now().Format(<span class="string">&quot;04:05&quot;</span>), <span class="string">&quot;变量值&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子载入-存储"><a href="#原子载入-存储" class="headerlink" title="原子载入&#x2F;存储"></a>原子载入&#x2F;存储</h4><p>**原子载入（Atomic Load) ** 是一种原子操作，用于从内存中读取共享变量的当前值。原子载入操作是多线程和多协程编程中的重要概念，它确保了共享数据的安全读取，是避免竞态条件和数据不一致问题的关键工具之一。Go 语言提供了 <code>sync/atomic</code> 包，其中包括 <code>LoadInt32</code>、<code>LoadInt64</code>、<code>LoadUint32</code>、<code>LoadUint64</code> 等函数，用于执行原子载入操作，读取相应类型的共享变量的当前值。</p><p>原子载入的函数形式为：<code>func LoadInt32(addr *int32) (val int32)</code>，当执行原子加载的时候，没有任何其他操作可以对此值进行读写操作，这里的约束由语言本身和底层硬件实现。</p><p>在go语言中，访问共享变量的时候应该使用原子操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sharedValue <span class="type">int32</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">// 使用原子载入操作读取共享变量的值</span></span><br><span class="line">value := atomic.LoadInt32(&amp;sharedValue)</span><br><span class="line">fmt.Println(<span class="string">&quot;Current value:&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原子存储（Atomic Store）</strong>与原子载入类似，在原子地存储某个值的过程中，任何操作都不会针对这个值进行读写。在go语言中修改共享变量应该使用原子存储。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还记得本文前面说的Go名言吗？<code>通过通信实现共享内存，而不是通过共享内存实现通信</code>，事实上，我们上面使用到的线程间通信方法都遵循了这个原则。比如在互斥锁和原子操作中，我们做的事情不过是确保一个shareValue的值在高并发中不会被错误读写，而通信只是我们实现这一目标的手段，无论是锁还是条件变量，都是通信手段而不是目标。只要确保了共享内存中的值是正确的，Go语言并发的问题也就迎刃而解了。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM入门教程与最佳实践</title>
      <link href="/2023/08/10/GORM%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/08/10/GORM%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>GORM是一种Go语言的ORM（对象关系映射）库，用于简化数据库的操作。它提供了一种简单、易于使用的方式来进行数据库的增删改查操作，支持多种数据库，如MySQL、PostgreSQL、SQLite等。下面，我们将从理论和实践的角度学习GORM框架。<span id="more"></span></p><h1 id="GORM入门教程与最佳实践"><a href="#GORM入门教程与最佳实践" class="headerlink" title="GORM入门教程与最佳实践"></a>GORM入门教程与最佳实践</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h3><p>先来讲讲什么是ORM。ORM（对象关系映射）是一种编程技术，用于将关系型数据库中的数据映射到面向对象编程语言中的对象模型。它能够自动地在数据库表和对象之间建立映射关系，并提供一种简化数据库操作的方式。</p><p>相信有过Java开发经验的人都不会对MyBatis感到陌生，GORM的思想与MyBatis相似，都是为了简化数据库的操作，<strong>将数据库的一个关系映射到业务中的一个类或者结构体</strong>（尽管MyBatis并不认为是一个ORM框架，因为其保留了使用xml编辑数据库操作语言）。</p><p>ORM的核心思想是通过将数据库表的行数据映射为对象的属性，将数据库表的列映射为对象的字段，从而实现数据库和对象之间的无缝转换。ORM框架负责处理数据库的增删改查操作，以及数据库表和对象之间的映射关系，开发者只需要操作对象，而无需直接与底层数据库打交道</p><h3 id="GORM的优点"><a href="#GORM的优点" class="headerlink" title="GORM的优点"></a>GORM的优点</h3><p>GORM框架有许多优点，这些优点减少了开发的工作量的同时还提高了系统的效率。</p><ul><li>数据库模型定义：使用结构体来定义数据库表结构，通过结构体的字段和标签来映射数据库表的列。</li><li>CRUD操作：提供了丰富的方法来进行数据库的增删改查操作，如Create、Read、Update和Delete等。</li><li>查询构建器：支持链式调用和条件语句来构建复杂的查询，包括条件查询、排序、分页等。</li><li>关联查询：支持通过预加载、延迟加载等方式进行关联查询，方便处理数据库表之间的关系。</li><li>事务支持：提供了事务的开启、提交和回滚等操作，保证原子性和数据一致性。</li><li>数据迁移：支持数据库结构的自动迁移，可以根据模型定义自动生成数据库表结构。</li><li>钩子函数：支持在数据库操作前后触发的钩子函数，方便进行数据验证、处理等操作。</li><li>软删除：支持逻辑删除，可以通过标记字段来实现数据的软删除和恢复。</li></ul><h3 id="GORM框架下载"><a href="#GORM框架下载" class="headerlink" title="GORM框架下载"></a>GORM框架下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br></pre></td></tr></table></figure><p>使用上述指令可以获取到最新的gorm框架。</p><h2 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h2><p>要想使用GORM框架，首先需要连接自己的数据库。此处略去如何安装数据库，并且以MySQL为例，建立连接并进行数据库操作。</p><p>建立连接的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">username := <span class="string">&quot;your_username&quot;</span>    <span class="comment">//用户名</span></span><br><span class="line">password := <span class="string">&quot;your_password&quot;</span> <span class="comment">//密码</span></span><br><span class="line">host := <span class="string">&quot;127.0.0.1&quot;</span>   <span class="comment">//数据库地址，可以是Ip或者域名</span></span><br><span class="line">port := <span class="number">3306</span>          <span class="comment">//数据库端口</span></span><br><span class="line">Dbname := <span class="string">&quot;test&quot;</span>      <span class="comment">//数据库名</span></span><br><span class="line"><span class="comment">//MYSQL dsn格式： &#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4</span></span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&quot;</span>, username, password, host, port, Dbname)</span><br><span class="line"><span class="comment">//gorm.Open()用于建立连接，打开数据库</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;连接数据库失败, error=&quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dsn是数据源名称(Data Source Name)，在GORM框架中，MySQL的dsn格式为：<code>&#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4</code>，?后面的是可选参数，可以设置字符集，时区等等。</p><p>db是一个gorm.DB类型的对象，建立连接之后，后面对于数据库的所有操作都可以由这个对象实现。如果没有报错，那么证明数据库连接成功。</p><h2 id="GORM实现CRUD"><a href="#GORM实现CRUD" class="headerlink" title="GORM实现CRUD"></a>GORM实现CRUD</h2><p>这里再科普一遍CRUD的英文单词吧。CRUD 是一个常用的缩写词，代表了常见的数据库操作，包括创建（Create）、读取（Read）、更新（Update）和删除（Delete）。下面我们将分别讲讲如何使用GORM框架实现CRUD，同时也给出官方文档地址<a href="https://gorm.io/docs/">gorm.io&#x2F;docs&#x2F;</a>。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>使用GORM框架之后，插入数据变得非常简单，实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="type">int</span>    <span class="string">`gorm:&quot;id&quot;`</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`gorm:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`gorm:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//---------------------</span></span><br><span class="line">    <span class="comment">//此处省略连接数据库的代码</span></span><br><span class="line">    <span class="comment">//---------------------</span></span><br><span class="line">    res := db.Create(User&#123;<span class="number">1</span>, <span class="string">&quot;Veni&quot;</span>, <span class="number">20</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(res.Error)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入指定字段，使用Select选择插入的字段，使用Omit选择忽略的字段，Omit字段使用数据库默认值</span></span><br><span class="line">    db.Select(<span class="string">&quot;id&quot;</span>).Omit(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>).Create(User&#123;<span class="number">1</span>,<span class="string">&quot;Veni&quot;</span>,<span class="number">20</span>&#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们讲述了ORM的定义，一个对象对应一个关系，在定义结构体的时候，<code>gorm:&quot;id&quot;</code>的作用是将结构的变量与数据库关系表中的字段建立映射。并且<code>func (*User) TableName() string</code>是一个结构体函数的写法，其<code>return</code>的值就是想要建立映射关系的表名。如果没有这个结构体函数，那么表名就是蛇形复数，比如User对应users表，UserName对应user_names表。这里我建了一张user表，注释掉结构体函数报错如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308102015271.webp" alt="image-20230810201529078"></p><p>Create函数自动创建了一个INSERT语句用于插入信息，并且将结构体中的数据传入数据库。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>读取数据可以比较灵活，比如使用.分的控制语句查找符合要求的数据。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//---------------------</span></span><br><span class="line">    <span class="comment">//此处省略连接数据库的代码</span></span><br><span class="line">    <span class="comment">//---------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明对象用以接收查询结果</span></span><br><span class="line">u := User&#123;&#125;</span><br><span class="line">res := db.Where(<span class="string">&quot;name=?&quot;</span>, <span class="string">&quot;Veni&quot;</span>).Find(&amp;u)</span><br><span class="line"><span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(res.Error)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, u)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明切片用于保存多个查询结果</span></span><br><span class="line">    uu := []User&#123;&#125;</span><br><span class="line">res = db.Find(&amp;uu)</span><br><span class="line"><span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(res.Error)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, uu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定查找范围和接收对象"><a href="#指定查找范围和接收对象" class="headerlink" title="指定查找范围和接收对象"></a>指定查找范围和接收对象</h4><p>GORM中用于指定接收对象的关键字有First，Last，Take，Find。此类关键字一般放在查询语句的最后，用于指定查询的范围和接收的对象。记得加取址符号&amp;，这样才能修改u的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到符合条件并且按照主键排序的第一个user</span></span><br><span class="line">res := db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;u)</span><br><span class="line"><span class="comment">//找到按照age字段升序排列的第一个user——First</span></span><br><span class="line">res := db.Order(<span class="string">&quot;age asc&quot;</span>).First(&amp;u)</span><br><span class="line"><span class="comment">//找到最后一个——Last</span></span><br><span class="line">res := db.Order(<span class="string">&quot;age asc&quot;</span>).Last(&amp;u)</span><br><span class="line"><span class="comment">//随便找到一个——Take</span></span><br><span class="line">res := db.Order(<span class="string">&quot;age asc&quot;</span>).Take(&amp;u)</span><br><span class="line"><span class="comment">//找到所有满足条件的——Find</span></span><br><span class="line">res := db.Order(<span class="string">&quot;age asc&quot;</span>).Find(&amp;uu)</span><br></pre></td></tr></table></figure><p>使用First查询不到数据的时候，会返回ErrRecoedNotFound，而使用Find查询不到的时候返回空数组。</p><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><p>使用Where方法可以实现条件查询，即数据库的选择操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res := db.Where(<span class="string">&quot;name = ?&quot;</span>,<span class="string">&quot;Veni&quot;</span>).Find(&amp;uu)</span><br></pre></td></tr></table></figure><p>需要注意的是，在gorm框架使用Where需要放在Find函数前面。这一点不同于数据库查询语言DQL中的写法：Where语句写在最后。</p><h4 id="投影语句"><a href="#投影语句" class="headerlink" title="投影语句"></a>投影语句</h4><p>gorm框架中的Select方法，对应的是DQL中的Select语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res := db.Select(<span class="string">&quot;name,age&quot;</span>).Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">0</span>).Find(&amp;u)</span><br></pre></td></tr></table></figure><p>执行查询语句：<code>[&#123;Id:0 Name:Veni Age:20&#125; &#123;Id:0 Name:Moss Age:75&#125;]</code>，可以看到，由于我没有选择Id字段，查找结果里面的所有对象的Id均为0（因为int的空置为0，string的空值为空串）。但是，作为一个ORM框架，每一个字段都应该对应着一个对象的一个属性，即便没有Select，该属性还是会占用内存，也就是说存储一个10和一个0是差别不大的，所以Select语句使用相对较少。当然在分组语句和聚合函数中还是会使用的。</p><h4 id="分组语句"><a href="#分组语句" class="headerlink" title="分组语句"></a>分组语句</h4><p>分组语句的实现方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Group(<span class="string">&quot;age&quot;</span>).Find(&amp;result)</span><br></pre></td></tr></table></figure><p>需要注意的是：不在分组函数中的字段必须在聚合函数中。比如一张工人薪资表，按照部门求平均工资，则group的字段为部门，那么薪资必须要使用average（或者sum等聚集函数）。这是因为，分组语句会改变行数，因此不同字段需要使用聚集函数同时改变行数才能维持表的行列形态。</p><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>聚合函数包括sum, average,count,max,min等，使用聚合函数的方法类似，都是在Select或者Having语句中嵌套使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temp <span class="keyword">struct</span> &#123;</span><br><span class="line">    Count <span class="type">int</span></span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Age   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">tempArr := []temp&#123;&#125;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">res := db.Table(<span class="string">&quot;user&quot;</span>).Select(<span class="string">&quot;count(*) as `count`,name,age&quot;</span>).Group(<span class="string">&quot;id,name,age&quot;</span>).Having(<span class="string">&quot;count(*) &gt;?&quot;</span>, <span class="number">0</span>).Find(&amp;tempArr)</span><br></pre></td></tr></table></figure><p>需要注意的是，使用聚合函数建立的查找表的字段一般都不是model对应的字段，因此需要定义一个新的结构体去接收和存储查询结果。字段名遵循蛇形命名方法，同时使用Table方法指定表。</p><h4 id="having语句"><a href="#having语句" class="headerlink" title="having语句"></a>having语句</h4><p>分组或聚集之后的查询表需要进行选择操作时，不能使用where语句，需要使用having语句，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res := db.Table(<span class="string">&quot;user&quot;</span>).Select(<span class="string">&quot;count(*) as `count`,name,age&quot;</span>).Group(<span class="string">&quot;id,name,age&quot;</span>).Having(<span class="string">&quot;count(*) &gt;?&quot;</span>, <span class="number">0</span>).Find(&amp;tempArr)</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><h4 id="给定数据更新："><a href="#给定数据更新：" class="headerlink" title="给定数据更新："></a>给定数据更新：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用model指定操作的表名</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name=?&quot;</span>, <span class="string">&quot;Veni&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//使用table指定操作的表名</span></span><br><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Where(<span class="string">&quot;name=?&quot;</span>, <span class="string">&quot;Veni&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>这里推荐使用Table指定表名，因为使用Table比较接近于数据库查询语言DML的写法。</p><h4 id="SQL表达式更新："><a href="#SQL表达式更新：" class="headerlink" title="SQL表达式更新："></a>SQL表达式更新：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Moss&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * 2 + ?&quot;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这里使用了<code>gorm.Expr()</code>方法，这个方法是表达式更新的写法，表达式为<code>age=age*2+1</code>，这个写法比较灵活，可以指定多个参数或不指定参数。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="物理删除"><a href="#物理删除" class="headerlink" title="物理删除"></a>物理删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接删除，后面接的都是主键的值</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;,<span class="number">1</span>)<span class="comment">//删除主键为1的记录</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;,[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)<span class="comment">//删除主键为1和2的记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Where条件语句删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>,<span class="string">&quot;Moss&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简洁的条件删除</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;,<span class="string">&quot;Name = ?&quot;</span>,<span class="string">&quot;Moss&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h4><p>gorm提供了goem.DeleteAt用于帮助用户实现软删。定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Id      <span class="type">int</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    age     <span class="type">int</span></span><br><span class="line">    Deleted gorm.DeleteAt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拥有软删除能力的Model调用Delete的时候，记录不会从数据库中真正删除，但是gorm会将DeleteAt设置为当前时间，并且无法正常查询。使用Unscoped可以查询到软删的数据。</p><h2 id="GORM的事务"><a href="#GORM的事务" class="headerlink" title="GORM的事务"></a>GORM的事务</h2><p>数据库的事务是指一组数据库操作（如插入、更新、删除等）被视为一个不可分割的工作单元，并且要么全部成功执行，要么全部回滚（撤销）。事务可以确保数据库的一致性和完整性，同时提供了并发控制和故障恢复的机制。GORM提供了Begin、Commit、Rollback等方法用于事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tx:=db.Begin() <span class="comment">//开始事务</span></span><br><span class="line"><span class="comment">//在事务中执行db操作需要全部换成tx</span></span><br><span class="line">res=tx.Create(&amp;User&#123;Name:<span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> res.Error!=<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//遇到错误时回滚</span></span><br><span class="line">    tx.Rollback()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">tx.Commit()<span class="comment">///提交事务</span></span><br></pre></td></tr></table></figure><p>Transaction方法自动提交事务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err = tx.Create(&amp;User&#123;<span class="number">1</span>, <span class="string">&quot;M&quot;</span>, <span class="number">18</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = tx.Create(&amp;User&#123;<span class="number">1</span>, <span class="string">&quot;Name&quot;</span>, <span class="number">11</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用Transaction方法提交事务，这样可以防止忘记提交的情况。</p><h2 id="GORM-Hook"><a href="#GORM-Hook" class="headerlink" title="GORM Hook"></a>GORM Hook</h2><p>Gorm提供了CRUD的Hook（钩子函数）能力，在创建，查询，更新，删除等操作前后自动调用的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate (tx *gorm.DB)(err <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> u.Age&lt;<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;Age cannot be negative&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理也可以创建AfterCreate的Hook。</span></span><br></pre></td></tr></table></figure><h2 id="GORM生态"><a href="#GORM生态" class="headerlink" title="GORM生态"></a>GORM生态</h2><p>GORM框架有着极其丰富的生态，以下是一些常见的GORM框架的工具及其仓库地址。在熟练使用GORM原生框架之后，可以尝试使用下面的工具提高开发效率或者系统性能。</p><table><thead><tr><th>工具名</th><th>地址</th></tr></thead><tbody><tr><td>GORM 代码生成工具</td><td><a href="https://github.com/go-gorm/gen">https://github.com/go-gorm/gen</a></td></tr><tr><td>GORM 分片库方案</td><td><a href="https://github.com/go-gorm/sharding">https://github.com/go-gorm/sharding</a></td></tr><tr><td>GORM 手动索引</td><td><a href="https://github.com/go-gorm/hints">https://github.com/go-gorm/hints</a></td></tr><tr><td>GORM 乐观锁</td><td><a href="https://github.com/go-gorm/optimisticlock">https://github.com/go-gorm/optimisticlock</a></td></tr><tr><td>GORM 读写分离</td><td><a href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a></td></tr><tr><td>GORM OpenTelemetry 扩展</td><td><a href="https://github.com/go-gorm/opentelemetry">https://github.com/go-gorm/opentelemetry</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> grom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【再学网络】http原理与实践</title>
      <link href="/2023/08/07/%E3%80%90%E5%86%8D%E5%AD%A6%E7%BD%91%E7%BB%9C%E3%80%91http%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/08/07/%E3%80%90%E5%86%8D%E5%AD%A6%E7%BD%91%E7%BB%9C%E3%80%91http%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>HTTP（Hypertext Transfer Protocol），又叫超文本传输协议，是一种用于在客户端和服务器之间传输超文本的协议。它是互联网上应用最广泛的一种协议，用于在 Web 浏览器和 Web 服务器之间进行通信。<span id="more"></span></p><h1 id="【再学网络】HTTP原理与实践"><a href="#【再学网络】HTTP原理与实践" class="headerlink" title="【再学网络】HTTP原理与实践"></a>【再学网络】HTTP原理与实践</h1><h2 id="为什么需要协议"><a href="#为什么需要协议" class="headerlink" title="为什么需要协议"></a>为什么需要协议</h2><p>HTTP是位于OSI参考模型和TCP&#x2F;IP模型中的应用层的一个工作协议，使用HTTP协议是用户和开发者的双重需要。</p><p>从用户的角度看，需要HTTP的原因有：</p><ul><li>访问和浏览网页：HTTP 协议是 Web 浏览器和 Web 服务器之间进行通信的基础。</li><li>下载和上传文件：HTTP 协议也被用于文件传输，用户可以通过 HTTP 请求下载文件，或通过 HTTP 请求上传文件。</li><li>与 Web 应用交互：现代的 Web 应用通常是基于 HTTP 协议构建的，用户可以通过 HTTP 请求与 Web 应用进行交互。</li></ul><p>从开发者的角度看，原因有：</p><ul><li>通信协议的标准化：HTTP 协议定义了客户端和服务器之间通信的规范和约定，使得开发者能够按照统一的标准进行开发。</li><li>简单和易于开发：HTTP 协议采用简单的文本格式，易于理解和调试。</li><li>跨平台和互操作性：HTTP 协议是一种跨平台的协议，不依赖于具体的操作系统和开发技术。</li><li>可扩展和定制化：HTTP 协议支持自定义的头部字段，开发者可以利用这一特性传递额外的信息和参数。</li></ul><h2 id="HTTP协议原理"><a href="#HTTP协议原理" class="headerlink" title="HTTP协议原理"></a>HTTP协议原理</h2><h3 id="HTTP协议内容"><a href="#HTTP协议内容" class="headerlink" title="HTTP协议内容"></a>HTTP协议内容</h3><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071512719.webp" alt="image-20230807151153388"></p><p>一个HTTP请求包含请求行、请求头和请求体，如上图中的第一段报文，请求行中的方法名为POST，请求体为邀请小姐姐看电影的话。而一个http响应包含状态行、响应头和响应体三部分，比如上文中的第二段报文。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071529415.webp" alt="image-20230807152944203"></p><h3 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h3><p>一个HTTP请求是以客户端的应用层的封装开始，到服务端的应用层的解封装结束。一个HTTP响应则相反，从服务端的封装开始，客户端的解封装结束。一个HTTP请求需要经过中间件，路由和编码解码等层级才能达到服务器。举个简单的例子，一个请求的请求路由是&#x2F;hello，那么在route层就会对其做一次检验，只有正确的路由才会放行；假设middleware层有一个登录验证的中间件，那么这一层就会把携带不正确身份信息的请求过滤掉。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071539103.webp" alt=" HTTP层次结构图 "></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>HTTP 中间件提供了一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Auth 中间件验证用户的身份，如果用户未通过身份验证，中间件将会把用户导向登录页面，反之，当用户通过了身份验证，中间件将会通过此请求并接着往下执行。当然，除了身份验证之外，中间件也可以被用来运行各式各样的任务，如：CORS 中间件负责替所有即将离开程序的响应加入适当的标头；而日志中间件则可以记录所有传入应用程序的请求。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>当服务器收到 HTTP 请求时，它会根据请求的 URL 和方法进行路由匹配。如果请求的 URL 和方法与某个路由规则匹配，服务器将调用与之关联的处理程序来处理请求，并生成相应的响应。例如，在一个 Web 应用中，可以定义一个路由规则将 GET 请求的 “&#x2F;users” 路径与一个处理函数关联起来。当用户在浏览器中访问 “&#x2F;users” 路径时，服务器将调用该处理函数来处理请求，并返回用户列表。</p><p>路由一般会组织成树的结构，也组织成映射结构。一般来说，树状结构可以加快路由匹配速度。</p><h4 id="路由参数和请求参数的区别"><a href="#路由参数和请求参数的区别" class="headerlink" title="路由参数和请求参数的区别"></a>路由参数和请求参数的区别</h4><ul><li>路由参数是指实际的请求路由随着不同的参数值而改变的路由，比如不同的用户登录某个博客网站，博客网站为他们分配了不同的路由，比如<code>/blog/123,/blog/456</code>，匹配模式为：<code>/blog/:id</code>。</li></ul><h2 id="HTTP实战"><a href="#HTTP实战" class="headerlink" title="HTTP实战"></a>HTTP实战</h2><p>下面我们将以Go语言为例，使用Gin框架，将HTTP应用在实战项目中。</p><h3 id="什么是curl"><a href="#什么是curl" class="headerlink" title="什么是curl"></a>什么是curl</h3><p>首先来了解一个工具——curl。curl全称是Client URL，是一个命令行工具和库，用于发送HTTP、HTTPS，FTP等协议的请求，并且获取响应数据。</p><p>curl的原理类似于一个命令行式的浏览器，虽然不具备渲染和展现网页的能力，但是具备调试API，下载文件，网络监测等能力。</p><h4 id="curl的简单使用"><a href="#curl的简单使用" class="headerlink" title="curl的简单使用"></a>curl的简单使用</h4><ul><li><code>-X</code>用于指定发送请求时使用的方法</li><li><code>-H</code>用于指定发送请求的请求头</li><li><code>-d</code>或者<code>--data</code>用于指定的数据，可以是文件，JSON，表单等等。</li></ul><h4 id="其他发送请求的工具"><a href="#其他发送请求的工具" class="headerlink" title="其他发送请求的工具"></a>其他发送请求的工具</h4><p>除了使用CLI的形式发送HTTP请求，还可以使用GUI工具发送。这里推荐使用Postman和APIFox。Postman比较成熟稳定，APIFox偶尔有bug，但具有Postman的功能并且还有写文档和Mock的能力，可以自行取舍。</p><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>GET请求用于从服务器获取数据。下面以一个简单的获取账户密码的例子来说明GET请求的实现：</p><p>首先定义一个实体User，它仅有两个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="type">string</span></span><br><span class="line">Password <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们测试通过GET传递用户名为参数获取密码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Query(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment">//此处仅作演示，实际开发中不会把密码返回，而是把密码加密存到数据库中</span></span><br><span class="line">user := models.User&#123;name, <span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line">c.JSON(<span class="number">200</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308081136485.webp" alt="image-20230808113646280"></p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>POST请求用于向服务端推送数据，一般而言，数据写在请求体body中。下面是一个简单的处理POST请求的demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUserInfo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">data, err := io.ReadAll(c.Request.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(<span class="number">500</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Request body:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">    <span class="comment">//将数据进行处理</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次使用APIFox代替curl发送请求，这里有几个需要注意的点：</p><ul><li>请求类型要改成POST请求，相当于指定<code>-X POST</code>。</li><li>请求的信息要写在Body中，不要写在Params中。这一步相当于<code>-d &lt;json数据&gt;</code>。</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191710697.webp" alt="image-20230819171001584"></p><p>后端接收到请求并且打印，输出结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/image-20230819170901529.webp" alt="image-20230819170459017"></p><h4 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h4><p>以下是一个PUT请求示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 从 URL 参数中获取 id</span></span><br><span class="line">id := c.Query(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析请求中的 JSON 数据</span></span><br><span class="line"><span class="keyword">var</span> requestData <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;requestData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里进行更新操作，例如更新数据库记录等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回成功响应</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Resource updated successfully&quot;</span>,</span><br><span class="line"><span class="string">&quot;id&quot;</span>:      id,</span><br><span class="line"><span class="string">&quot;data&quot;</span>:    requestData,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>APIFox发送请求以及响应，设置请求同时要设置Params和Body。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191745903.webp" alt="image-20230819174558791"></p><h4 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h4><p>下面是一个DELETE请求示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 从 URL 参数中获取 id</span></span><br><span class="line">id := c.Query(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里进行删除操作，例如从数据库中删除记录等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回成功响应</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Resource deleted successfully&quot;</span>,</span><br><span class="line"><span class="string">&quot;id&quot;</span>:      id,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>APIFox请求和响应结果：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191742816.webp" alt="image-20230819174237717"></p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>当涉及HTTP请求时，GET、POST、PUT和DELETE是最常见的几种方法，用于在客户端和服务器之间传递数据和执行操作。以下是它们之间的比较：</p><table><thead><tr><th>维度</th><th>GET请求</th><th>POST请求</th><th>PUT请求</th><th>DELETE请求</th></tr></thead><tbody><tr><td>用途</td><td>获取数据，如网页、图片等</td><td>提交数据，如表单数据</td><td>更新资源，替换操作</td><td>删除资源</td></tr><tr><td>幂等性</td><td>幂等操作，不改变状态</td><td>非幂等操作，可能改变状态</td><td>幂等操作，相同更新</td><td>幂等操作，不改变状态</td></tr><tr><td>数据传递</td><td>通过URL查询参数传递</td><td>通过请求体传递数据</td><td>通过请求体传递完整资源</td><td>通常通过URL标识资源</td></tr><tr><td>安全性</td><td>相对较安全，不改变状态</td><td>相对较安全，可能改变状态</td><td>相对较安全，需要授权</td><td>相对较安全，需要授权</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不同的HTTP请求方法在执行操作和传递数据时有不同的语义和适用场景。选择正确的方法取决于业务要执行的操作以及与服务器交互的目的。如希望深入了解HTTP请求方法的内部工作原理和细节，可以研究相关的HTTP协议规范，如RFC 7231。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架入门级教程与实践</title>
      <link href="/2023/08/05/Gin%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/08/05/Gin%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>Gin是一个用Go语言编写的高性能Web框架，它简洁、快速，并具有良好的路由和中间件支持。<span id="more"></span></p><h1 id="Gin框架入门级教程与实践"><a href="#Gin框架入门级教程与实践" class="headerlink" title="Gin框架入门级教程与实践"></a>Gin框架入门级教程与实践</h1><h2 id="为什么使用Gin"><a href="#为什么使用Gin" class="headerlink" title="为什么使用Gin"></a>为什么使用Gin</h2><p>我们使用Gin的原因很直接也很简单，那就是Gin很强大也很简单。Gin框架具有如下的有点：</p><ul><li><strong>高性能</strong>：Gin框架使用了基于Radix树的路由匹配算法，使得路由查找非常快速。同时，Gin框架基于HTTP标准库进行开发，具有低内存占用和高并发处理能力。</li><li><strong>简单易用</strong>：Gin框架提供了简洁的API和易于理解的代码结构，使得开发者能够快速上手并编写清晰、可维护的代码。</li><li><strong>路由和中间件支持</strong>：Gin框架提供了灵活的路由定义方式，支持参数路由、分组路由等。同时，Gin框架内置了丰富的中间件支持，如日志、认证、CORS等，可以方便地实现各种功能和扩展需求。</li><li><strong>JSON解析和输出</strong>：Gin框架内置了强大的JSON解析和输出功能，可以方便地处理请求数据和生成响应。同时，Gin框架还支持其他格式的数据解析和输出，如XML、YAML等。</li><li><strong>插件生态丰富</strong>：Gin框架有着活跃的社区和丰富的插件生态，可以方便地集成其他常用库和组件，如数据库ORM、缓存库、验证库等。</li></ul><p>这些看一下就好，以后会体会到Go的高并发和JSON解析等强大功能的。</p><h2 id="Gin框架的入门"><a href="#Gin框架的入门" class="headerlink" title="Gin框架的入门"></a>Gin框架的入门</h2><h3 id="下载Gin依赖"><a href="#下载Gin依赖" class="headerlink" title="下载Gin依赖"></a>下载Gin依赖</h3><p>执行以下命令，下载和安装Gin依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>以下指令会把Gin安装在GOPATH里面的src文件夹中。</p><h3 id="第一个Gin应用"><a href="#第一个Gin应用" class="headerlink" title="第一个Gin应用"></a>第一个Gin应用</h3><p>我们先写一个Gin应用，打开Gin的世界。新建一个main.go文件，敲进去这样的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Veni&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8888&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>打开浏览器，输入：<code>localhost:8888/hello</code>，结果返回为<code>&quot;message&quot;:&quot;Veni&quot;</code>，第一个Gin应用完美运行。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071127195.webp" alt="image-20230807112709050"></p><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p>package和import就不说了，从main函数开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br></pre></td></tr></table></figure><p>这一段代码用来创建一个默认的Gin引擎的实例并赋值给r，该实例已经配置了一些常用的中间件和默认的设置，比如默认使用Logger中间件用于记录请求日志，默认使用Recovery中间件用于恢复panic。还有默认的错误信息处理，默认请求路由器等等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Veni&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>r.GET()用于创建一个GET请求的处理函数，请求的路由是”&#x2F;hello”，然后绑定了一个处理函数func。func函数的参数是<code>c *gin.Context</code>，这是Gin框架里面的上下文对象，它封装了每个http请求的信息和操作方法，用于处理请求和响应。为什么要使用指针<code>*</code>呢？因为这里面需要对这个上下文进行修改，因此采用指针传递才能在函数中修改变量的值。Gin.Context有许多用法，比如：</p><ul><li><code>c.Request</code>：获取原始的 http.Request 对象。</li><li><code>c.Writer</code>：获取原始的 http.ResponseWriter 对象。</li><li><code>c.Param(key)</code>：获取路由参数值。</li><li><code>c.Query(key)</code>：获取查询参数值。</li><li><code>c.PostForm(key)</code>：获取表单参数值。</li><li><code>c.JSON(code int, obj interface&#123;&#125;)</code>：以 JSON 格式返回数据。</li><li><code>c.HTML(code int, name string, data interface&#123;&#125;)</code>：渲染 HTML 模板并返回。</li><li><code>c.Set(key string, value interface&#123;&#125;)</code>：设置上下文的键值对。</li><li><code>c.Get(key string) interface&#123;&#125;</code>：获取上下文中的值。</li></ul><p>所以，上面的c.JSON的作用就是以JSON格式返回数据，函数的第一个参数是整形返回码，interface可以是任意类型的对象。</p><p>gin.H{}是Gin框架中用来创建JSON或HTML相应的方式，可以创建一个 map [string] interface类型的对象。使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data := gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, World!&quot;</span>,</span><br><span class="line"><span class="string">&quot;count&quot;</span>:   <span class="number">10</span>,</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(<span class="number">200</span>, data)</span><br></pre></td></tr></table></figure><p>在实际开发中，一般的返回JSON都命名成data，符合前后端开发的习惯。</p><h3 id="Gin项目结构"><a href="#Gin项目结构" class="headerlink" title="Gin项目结构"></a>Gin项目结构</h3><p>Gin的项目结构可以是因人而异的。Go语言相互调用包的过程很简单，公有变量和私有变量只需要使用大小写区分。受到MVC架构的影响，我一般将项目组织成如下的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- main.go  </span><br><span class="line">- router.go</span><br><span class="line">- config.yaml</span><br><span class="line">- controller/</span><br><span class="line">  - user.go</span><br><span class="line">- model/</span><br><span class="line">  - user.go</span><br><span class="line">- middleware/</span><br><span class="line">  - authMiddleware.go</span><br><span class="line">- service/</span><br><span class="line">  - database.go</span><br><span class="line">  - redis.go</span><br><span class="line">- test/</span><br><span class="line">  - config.yaml</span><br><span class="line">  - main_test.go</span><br><span class="line">  - user_test.go</span><br><span class="line">- utils/</span><br><span class="line">  - time.go</span><br></pre></td></tr></table></figure><ul><li>main文件是程序的入口，用于完成初始化，启动Gin等操作；router用于配置路由信息，包括对应路由的处理函数。</li><li>controller目录为控制器层，用于处理路由对应的请求。</li><li>model目录是模型层，对应着数据库的一个关系或者自建的实体模型。</li><li>middleware是中间件层，用于完成权限认证等操作。</li><li>service层存放的是业务逻辑的相关代码，以及调用其他服务或API的代码，可以将DB和Redis等操作代码也放在这一文件夹中。</li><li>test是测试目录，用于完成单元测试等工作。</li></ul><p>在项目的实际开发中，推荐使用的命名方法是：公有类型名和方法名使用大驼峰，私有类型和方法、目录和文件名使用小驼峰。</p><h2 id="Gin项目结构逐层解析"><a href="#Gin项目结构逐层解析" class="headerlink" title="Gin项目结构逐层解析"></a>Gin项目结构逐层解析</h2><p>现在你已经能够启动Gin框架的hello world，并且也了解了Gin的项目结构。下面我们将逐个实现上述结构，让萌新也可以拥有一个完整的项目框架经验。</p><h3 id="package-main"><a href="#package-main" class="headerlink" title="package main"></a>package main</h3><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><p>前文中我们直接在main函数处理了一个GET请求，但是实际开发中是绝对不会把处理函数写在main函数里面的。main函数主要做两件事情：初始化环境和启动Gin。所以，一个简单的main.go文件如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">//初始化路由器</span></span><br><span class="line">InitRouter(r)</span><br><span class="line">    <span class="comment">//初始化数据库</span></span><br><span class="line">service.InitDatabase()</span><br><span class="line">    <span class="comment">//初始化Redis</span></span><br><span class="line">service.InitRedis()</span><br><span class="line"><span class="comment">//启动Gin</span></span><br><span class="line">r.Run(<span class="string">&quot;:8888&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h4><p>初始化引擎一句之前已经解析过了，下面讲讲InitRouter(r)。这个函数我们写在router.go这个文件中，用于处理路由和相关请求。比如下面的这个文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRouter</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">    <span class="comment">//静态文件路径</span></span><br><span class="line">    r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./public&quot;</span>)</span><br><span class="line">    <span class="comment">//注册路由组</span></span><br><span class="line">    router := r.Group(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">    <span class="comment">//在路由组下注册路由</span></span><br><span class="line">    router.POST(<span class="string">&quot;/user/login/&quot;</span>, controller.Login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的参数需要带指针*，不然在主函数中调用是不会改变r的值的。</li><li>r.Static用于注册静态文件的路径，比如某些HTML以及图片等，将其指向本地的public文件夹。</li><li>使用r.Group注册路由组，使用路由组可以统一注册中间件，同时也符合树形结构路由的要求。</li><li>router.POST则指定了一个路径下的POST请求及其处理函数（controller.Login）。此时的路径必须加上路由组的路径，即完整的路径为：<code>/api/user/login/</code>。</li></ul><h4 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h4><p>该文件用于处理所有重要的配置，比如数据库，Redis等等。使用yaml记录配置十分简洁，可以将字段一一对应到某个go语言的结构体中，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="attr">driver:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">  <span class="attr">port:</span></span><br><span class="line">  <span class="attr">username:</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">addr:</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="attr">DB:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">OSS:</span></span><br><span class="line">  <span class="attr">endPoint:</span></span><br><span class="line">  <span class="attr">accessKey:</span></span><br><span class="line">  <span class="attr">accessSecret:</span></span><br></pre></td></tr></table></figure><p>每一个层级对应一个结构体，最小的层级对应结构体的一个字段。比如，用来存储database配置的两个结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DatabaseConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Driver   <span class="type">string</span> <span class="string">`yaml:&quot;driver&quot;`</span></span><br><span class="line">Host     <span class="type">string</span> <span class="string">`yaml:&quot;host&quot;`</span></span><br><span class="line">Port     <span class="type">int</span>    <span class="string">`yaml:&quot;port&quot;`</span></span><br><span class="line">Username <span class="type">string</span> <span class="string">`yaml:&quot;username&quot;`</span></span><br><span class="line">Password <span class="type">string</span> <span class="string">`yaml:&quot;password&quot;`</span></span><br><span class="line">Database <span class="type">string</span> <span class="string">`yaml:&quot;database&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">Database DatabaseConfig <span class="string">`yaml:&quot;database&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package-service"><a href="#package-service" class="headerlink" title="package service"></a>package service</h3><p>在主函数里面有一个初始化数据库的函数我们没有说，现在我们来讲一讲这个<code>service.InitDatabase()</code>。这里需要一点gorm的基础，可以去看<a href="https://veni222987.github.io/2023/08/10/%EF%BC%88%E5%AE%8C%EF%BC%89GORM%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">我的博客另一篇介绍gorm的文章</a>。具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Db *gorm.DB</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDatabase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//读取配置文件</span></span><br><span class="line">configFile, err := os.ReadFile(<span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//反序列化configFile到config（即上面的var config struct&#123;&#125;变量）</span></span><br><span class="line">err = yaml.Unmarshal(configFile, &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拼接字符串</span></span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">config.Database.Username,</span><br><span class="line">config.Database.Password,</span><br><span class="line">config.Database.Host,</span><br><span class="line">config.Database.Port,</span><br><span class="line">config.Database.Database,</span><br><span class="line">)</span><br><span class="line">Db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DSN(Database Source Name)为数据库资源名称，用于gorm打开数据库并建立连接。后面对数据库的所有操作都可以通过Db这个变量来完成。</p><h3 id="package-model"><a href="#package-model" class="headerlink" title="package model"></a>package model</h3><p>这个目录存储了主要的结构体，比如<code>model/user.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id              <span class="type">int64</span>  <span class="string">`gorm:&quot;id&quot; json:&quot;id&quot;`</span>                             <span class="comment">// 用户id</span></span><br><span class="line">Name            <span class="type">string</span> <span class="string">`gorm:&quot;name&quot; json:&quot;name&quot;`</span>                         <span class="comment">// 用户名称</span></span><br><span class="line">FollowCount     <span class="type">int</span>    <span class="string">`gorm:&quot;follow_count&quot; json:&quot;follow_count&quot;`</span>         <span class="comment">// 关注总数</span></span><br><span class="line">FollowerCount   <span class="type">int</span>    <span class="string">`gorm:&quot;follower_count&quot; json:&quot;follower_count&quot;`</span>     <span class="comment">// 粉丝总数</span></span><br><span class="line">Avatar          <span class="type">string</span> <span class="string">`gorm:&quot;avatar&quot; json:&quot;avatar&quot;`</span>                     <span class="comment">// 用户头像</span></span><br><span class="line">BackgroundImage <span class="type">string</span> <span class="string">`gorm:&quot;background_image&quot; json:&quot;background_image&quot;`</span> <span class="comment">// 用户个人页顶部大图</span></span><br><span class="line">Signature       <span class="type">string</span> <span class="string">`gorm:&quot;signature&quot; json:&quot;signature&quot;`</span>               <span class="comment">// 个人简介</span></span><br><span class="line">TotalFavorited  <span class="type">int</span>    <span class="string">`gorm:&quot;total_favorited&quot; json:&quot;total_favorited&quot;`</span>   <span class="comment">// 获赞数量</span></span><br><span class="line">WorkCount       <span class="type">int</span>    <span class="string">`gorm:&quot;work_count&quot; json:&quot;work_count&quot;`</span>             <span class="comment">// 作品数</span></span><br><span class="line">FavoriteCount   <span class="type">int</span>    <span class="string">`gorm:&quot;favorite_count&quot; json:&quot;favorite_count&quot;`</span>     <span class="comment">// 喜欢数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定数据库表名，如不指定，则默认为蛇形复数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gorm可以指定某一个属性对应的数据库表的字段，使用json则可以指定当该结构体序列化为json的时候的字段名。</p><h3 id="package-controller"><a href="#package-controller" class="headerlink" title="package controller"></a>package controller</h3><p>下面是一个控制器的实例，用于处理路由器中已经指定的路由及其处理函数。这里以login为例，函数的具体实现如下，该函数写于<code>controller/user.go</code>文件中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">DB := service.Db</span><br><span class="line"><span class="comment">//获取参数</span></span><br><span class="line">name := ctx.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := ctx.Query(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"><span class="comment">//判断用户是否存在</span></span><br><span class="line">account := model.Account&#123;&#125;</span><br><span class="line">DB.Table(<span class="string">&quot;account&quot;</span>).Where(<span class="string">&quot;username = ?&quot;</span>, name).Find(&amp;account)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(account.Username) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(http.StatusUnprocessableEntity, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">422</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;用户不存在&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断密码是否正确</span></span><br><span class="line"><span class="keyword">if</span> err := bcrypt.CompareHashAndPassword([]<span class="type">byte</span>(account.Password), []<span class="type">byte</span>(password)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">400</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;密码错误&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;status_code&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;status_msg&quot;</span>:  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package-middleware"><a href="#package-middleware" class="headerlink" title="package middleware"></a>package middleware</h3><p>这个包用来存放中间件的相关代码，简单的token验证中间件的实现方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryAuthMiddleWare</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">token := ctx.Query(<span class="string">&quot;token&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> service.IsTokenExist(token) &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;鉴权成功，token有效\n&quot;)</span></span><br><span class="line">service.RedisClient.Set(token, service.RedisClient.Get(token).Result, <span class="number">86400000000000</span>)</span><br><span class="line">ctx.Next()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;无效的token&quot;</span>)</span><br><span class="line">ctx.AbortWithStatusJSON(<span class="number">401</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;无效的Token&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里假设处理函数面对的HTTP请求把token放在了Query的位置，则通过ctx.Query(“token”)即可获取到这个token值。这里使用Redis查询是否存在该token从而完成权限鉴定功能，具体实现在函数<code>service.IsTokenExist(token)</code>中，这里就不给出详细代码了，可以自行到github仓库里面看。</p><h3 id="package-utils"><a href="#package-utils" class="headerlink" title="package utils"></a>package utils</h3><p>这里存放一些代码中可能会使用到的工具函数，比如日期，时间转换等等。下面是一个日期转换的工具：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomTime <span class="keyword">struct</span> &#123;</span><br><span class="line">time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *CustomTime)</span></span> UnmarshalJSON(b []<span class="type">byte</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">s := <span class="type">string</span>(b)</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">ct.Time = time.Time&#123;&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span> : <span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">t, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">ct.Time = t</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *CustomTime)</span></span> MarshalJSON() ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ct.IsZero() &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;null&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;\&quot;%s\&quot;&quot;</span>, ct.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以把日期序列化为<code>YYYY-MM-DD hh-mm-ss</code>的形式。</p><h3 id="package-test"><a href="#package-test" class="headerlink" title="package test"></a>package test</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>这个包里面的函数用于开展单元测试，单元测试是软件开发中的一种测试方法，旨在验证代码中的最小可测试单元（通常是函数、方法或类）是否按预期工作。</p><ul><li>对于需要测试的代码文件创建一个名为<code>*_test.go</code>的文件。</li><li>测试代码写成函数形式：<code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放在<code>TestMain(m *testing.M)</code>函数中，并且文件取名为main_test.go</li></ul><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><p>在test目录下，一般需要包含如下文件：config.yaml，main_test.go，*_test.go（*代表任意匹配），config.yaml里面的配置填写测试环境配置，比如测试数据库。main_test.go完成对测试环境的初始化工作，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">service.InitRedis()</span><br><span class="line">service.InitDatabase()</span><br><span class="line">code := m.Run()</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以一次写各个函数的单元测试函数了，下面是一个处理gin框架下的POST请求的一个单元测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLogin</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">router := gin.New()</span><br><span class="line">router.POST(<span class="string">&quot;/douyin/user/login&quot;</span>, controller.Login)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个模拟的HTTP请求</span></span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/douyin/user/login?username=Veni&amp;password=asdfghjkl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">resp := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将请求发送到路由引擎处理</span></span><br><span class="line">router.ServeHTTP(resp, req)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证响应</span></span><br><span class="line"><span class="keyword">if</span> resp.Code != <span class="number">200</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Expected status code 200, but got %d&quot;</span>, resp.Code)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h4><p>由于本项目将<code>main_test.go</code>文件放在了test包中，那么就不能直接运行go test指令来启动测试了，取而代之的是go test .&#x2F;test，此时test目录相当于一个项目的根目录，会运行<code>main_test.go</code>之后自动扫描其他的test文件中的测试函数，一次运行的结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308241826655.webp" alt="image-20230824182624455"></p><p>这里返回了422编码，表明用户不存在，因为测试数据库中并没有这个用户记录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本次Gin框架的基础教程了，部分代码截自<a href="https://github.com/Veni222987/DoushengABCD.git">我的第一个go项目</a>，大家可以到仓库里面看具体代码，如果对大家有帮助，不妨在github点个star或者给这篇文章点个赞。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Exp】Git的正确使用姿势与最佳实践</title>
      <link href="/2023/07/31/%E3%80%90Exp%E3%80%91Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/07/31/%E3%80%90Exp%E3%80%91Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>先问一下屏幕前的你，是不是还在使用压缩包传代码？是不是还在重命名一个“_备份”文件来保存修改，又或者说，对git的使用只停留在IDE的GUI上。当然作为一个合格的大一新生，这些事情估计都是常态。那么话不多说，我们直接开始——Git的正确使用姿势和最佳实践。<span id="more"></span></p><h1 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h1><p>先来看看百度百科的介绍：</p><p>Git（读音为&#x2F;gɪt&#x2F;）是一个<strong>开源</strong>的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><p>Wiki讲得更清晰一点：</p><p><strong>Git</strong> (<a href="https://en.wikipedia.org/wiki/Help:IPA/English">&#x2F;ɡɪt&#x2F;</a>) is a <a href="https://en.wikipedia.org/wiki/Distributed_version_control">distributed version control</a> system that tracks changes in any set of <a href="https://en.wikipedia.org/wiki/Computer_file">computer files</a>, usually used for coordinating work among programmers who are collaboratively developing <a href="https://en.wikipedia.org/wiki/Source_code">source code</a> during <a href="https://en.wikipedia.org/wiki/Software_development">software development</a>. Its goals include speed, <a href="https://en.wikipedia.org/wiki/Data_integrity">data integrity</a>, and support for <a href="https://en.wikipedia.org/wiki/Distributed_computing">distributed</a>, non-linear workflows (thousands of parallel <a href="https://en.wikipedia.org/wiki/Branching_(version_control)">branches</a> running on different computers).</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021410465.webp" alt="image-20230802141015329"></p><p>简单点说，就是一套开源的分布式版本控制系统。有了它，把代码改崩了也不害怕。</p><h1 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h1><h2 id="windows操作系统"><a href="#windows操作系统" class="headerlink" title="windows操作系统"></a>windows操作系统</h2><p>打开<a href="https://git-scm.com/">git官网</a>，找到右边的Download for Windows，进去之后选择对应的版本即可。下载之后打开下载器，一定安装git bash，一直点next，最后就安装完成了，当然也可以进行个性化安装。我的建议是一开始直接next到底即可，反正你自己也不知道哪个有没有用，等自己用熟悉了git之后，重装系统或者换电脑的时候你就信手拈来了。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021513783.webp" alt="image-20230802151343476"></p><h2 id="Linux操作系统（以Debian为例）"><a href="#Linux操作系统（以Debian为例）" class="headerlink" title="Linux操作系统（以Debian为例）"></a>Linux操作系统（以Debian为例）</h2><p>更新软件库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>下载git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h2 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h2><p>在windows系统下，右键打开GitBash(Windows下安装的时候推荐安装GitBash)，就是一个特殊的shell，输入指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021523361.webp" alt="image-20230802152339257"></p><p>有出现版本号就代表安装成功。在Linux操作系统下同理：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021525433.webp" alt="image-20230802152509361"></p><h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><h2 id="个人信息配置"><a href="#个人信息配置" class="headerlink" title="个人信息配置"></a>个人信息配置</h2><p>在git安装完成之后，需要先进行一些基本的配置操作，个人信息配置主要包括用户名，账号邮箱，账号密码三部分。</p><p>配置方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Veni&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;123456789@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.password <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p>把email和密码换成自己github注册的时候使用的邮箱和密码，这样做有两个原因：</p><ul><li>如果正确设置了账号密码，每次clone和pull自己的私有分支的时候就不用再输入一次，没设置好的话操作远程分支会很麻烦。</li><li>设置好了邮箱，github上面的contributions才能正确统计，如果没设置，哪怕你干了活人家github也不知道是你干的，就不会帮你统计提交了。</li></ul><p>另外，设置用户名主要是为了仓库管理员可以清楚地看到每个人修改了什么，发生错误的时候可以正常回退，然后抓出来问一顿，bug说不定就解决了。</p><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p>有些小朋友总是说github同步代码速度慢，这里有两种方法，一种是使用魔法（施法工具得自己找），另一种是使用国内的gitee。当使用魔法的时候，就需要对git的代理进行设置。</p><ul><li>首先看看自己的代理ip和端口号，一般长这样：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308030945337.webp" alt="image-20230803094551162"></p><ul><li>然后设置全局的http和https代理：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>把–global去掉之后就是只设置当前仓库的代理，原理是只修改当前仓库.git&#x2F;config文件里面的配置，而使用全局设置之后就是直接修改git安装目录下的.gitconfig文件。</p><ul><li>当你当前仓库使用了代理之后，那么你就必须一直开着魔法工具才能正常使用，否则会报错。</li></ul><h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><p>想要看自己设置有没有打错，可以自行查看一下，命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p>出来的结果长这样：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308030954198.webp" alt="image-20230803095444121"></p><p>如果检查完毕之后没什么问题，那就可以愉快地使用了。</p><h2 id="使用SSH连接"><a href="#使用SSH连接" class="headerlink" title="使用SSH连接"></a>使用SSH连接</h2><p>除了配置HTTP代理之外，我们还可以采用另外一种方式连接，即SSH连接。</p><p>首先，你需要将检查自己的电脑是否有SSH密钥，打开用户的home目录，里面有一个.ssh隐藏文件夹，打开之后，如果有类似xxx.pub(一般是id_rsa.pub)这样的文件，表明自己的电脑已经有一对密钥对了，其中的pub表示的是公钥，顾名思义就是给别人用来加密的。如果没有，那就执行下面的指令，生成一对密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>如不想定义，直接一路回车即可。之后打开.ssh文件夹，你就会看到.pub文件了。</p><p>下一步是将ssh的公钥放到github上面。</p><p>打开github-&gt;Setting-&gt;SSH and GPG keys，将刚才的pub文件里面的公钥粘贴进去就好了。之后就可以使用ssh连接了。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240315113906350.png" alt="image-20240315113906350"></p><h1 id="git分区"><a href="#git分区" class="headerlink" title="git分区"></a>git分区</h1><p>先来了解一下Git的分区，不然下面的指令有可能会看不懂。首先来看一下Git的架构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/3670077-b97c6a8e14d1dafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p><p>在这个架构图中，工作区、暂存区和本地仓库（或者说提交区）是最重要的三个部分。由于Git是一个分布式的版本控制系统，它不需要一个集中的版本号，所以没有远程仓库其实也可以工作。</p><p>工作区是.git文件夹及其子文件夹的所有文件的区域，可以理解为工作区就是一个目录里面的所有文件组成的分区，没有被索引的文件都在工作区总。add指令可以将工作区中的内容添加到暂存区，暂存区里面的文件都是被tracked的文件，也就是说，任何一次commit都会对暂存区的文件做一次快照。经过commit之后，暂存区的修改就会被提交到本地仓库，本地仓库中的记录就是一个个版本，可以被回退或者创建分支。</p><p>远程仓库是一个可以实现多机共同协作的地方，每个人都可以把本地仓库里面的commit推送到远程仓库，别人也可以从远程仓库中拉取最新的代码。常见的远程仓库网站有：Github、Gitee等等，甚至也可以自己在服务器上搭建一个git仓库。</p><h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><p>这里用git的常用命令组织文章结构，这样写的好处是应用性较强。我推荐看看<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的git教程</a>，他使用一个仓库管理的实例和故事性的结构讲述git，我认为十分通俗易懂。</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>在项目的根目录下创建一个git仓库，git会对整个目录范围内的代码进行管理。比如，我在桌面创建一个example目录，然后打开目录，右键Open Git Bash here，输入指令<code>git init</code>即可初始化一个git仓库。初始化完成之后，可以打开.git隐藏文件夹，里面就有一些文件是记录当前仓库的信息的，比如config记录当前仓库设置，HEAD记录代码提交。</p><p>这个文件里面的东西不需要自己写！！！</p><p>这个文件里面的东西不需要自己写！！！</p><p>这个文件里面的东西不需要自己写！！！</p><p>重要的事情说三遍，不要自己修改把仓库玩坏了，一般来说是不用打开.git目录的，处于学习的目的可以进去研究一下。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code>指令的作用是将文件或者目录添加到暂存区，包括新增的，删除的，修改的。这里以刚刚创建的example文件夹为例，我创建了一个hello_world.txt文件，里面写上hello world。然后保存退出。使用git add指令将其添加到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>.表示当前目录，它会自动把当前目录的所有文件及其子目录里面的文件都加入暂存区，执行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031017260.webp" alt="image-20230803101729190"></p><p>是的，你没有看错，它什么也没有发生。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>刚才使用的<code>git add</code>指令只是将其添加到git暂存区，而不是提交修改到仓库。也就是说，你自己<code>git add</code>多少次都没有影响仓库里面的东西，那么要提交的话就需要使用<code>git commit</code>指令。</p><p><code>git commit</code>指令将暂存区提交到了仓库，仓库会为当前修改创建一个节点，每一次的commit都是仓库版本回退的节点，那些add但是没有commit的修改是不能回退的。使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m<span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>-m后面的双引号就是本次提交的消息，一般用来记录修改了什么，执行结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031025317.webp" alt="image-20230803102546243"></p><p>接下来我们修改一下hello_world.txt里面的内容，再提交一次，修改的内容为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">hello git!</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m<span class="string">&quot;hello git&quot;</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031029096.webp" alt="image-20230803102954025"></p><p>那么接下来我们看一下自己的这两次修改：打开.git&#x2F;log&#x2F;HEAD，里面有我们的修改记录：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031031132.webp" alt="image-20230803103148007"></p><p>当然这些东西直接使用<code>git log</code>指令也可以直接看到：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031247530.webp" alt="image-20230803124739397"></p><p>commit后面的十六进制数字串就是版本号，后面是修改人的名字和邮箱，修改日期以及修改评语等。后面可以根据这个版本号直接回退到彼时的仓库状态。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>如果再某一次的修改中，代码直接崩掉无法运作了，就可以使用<code>git reset</code>指令，坐上时光机回到过去。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031257570.webp" alt="image-20230803125719486"></p><p>使用的时候它也会提醒你”Unstaged changes after reset:”，这个时候是仓库工作区（也就是代码内容）并没有回退成功的，只是撤销了最后一次提交，并且将HEAD指针移动到上一次更改，这个时候你可以加上<code>--hard</code>指令强制整个仓库（包括工作区）回退到指定的版本号。但是有一点需要注意，这个时光机是不能带着未来的东西回去的。也就是说，你后面写的代码都会被丢失，使用reset –hard指令之后，整个仓库都会回到过去的一个commit的状态。你可以打开文件看看是不是回去了。</p><p>此外，如果只是要回退一个版本号，那么不需要查版本号，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>HEAD^代替了上一个版本号。</p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>暂存用于当前某一件事情做了一半的情况下，需要切换到另外一个分支处理另一个事情的时候把当前的工作区保存起来。例如，当前你正在开发一个新功能，但是突然leader说原来的版本有一个bug需要切换到另外一个分支解决，这个时候直接checkout是不会成功的，因为当前工作区发生了改变，会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">**************</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><ul><li>如何存储？</li></ul><p>使用<code>git stash</code>可以简单粗暴地存储当前的工作区，但是推荐使用<code>git stash save &quot;msg&quot;</code>的方式，可以对存储内容进行描述，使用<code>git stash list</code>可以查看曾经存储的进度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS M:\MyProjects\ILOVEJava&gt; git stash list </span><br><span class="line">stash@&#123;0&#125;: On newb: 添加测试</span><br></pre></td></tr></table></figure><p>On ***表示再某个分支，一般情况下，从stash中恢复的时候推荐从原来stash的分支恢复，避免发生冲突。</p><ul><li>如何恢复</li></ul><p>使用<code>git stash pop</code>可以快速恢复暂存区的最新内容，<code>git stash pop stash@&#123;1&#125;</code>可以恢复到指定内容。</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>上面讲的都是在本地仓库使用Git的操作，接下来我们来用一下远程仓库，这里以Github为例。</p><ul><li>首先，新建一个空仓库，建完之后长这样：</li></ul><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031326922.webp" alt="image-20230803132631654"></p><p>如果使用了模板创建的话，仓库在创建之初就会有一些文件，比如README.md，.gitignore等等。</p><ul><li>将本地仓库与远程仓库进行关联：</li></ul><p>每一个仓库都会有一个个人地址，将地址copy下来之后，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Veni222987/example.git</span><br></pre></td></tr></table></figure><p>然后使用<code>git remote</code>指令可以查看所有远程仓库。</p><ul><li>将本地仓库上面的东西上传到远程仓库：</li></ul><p>使用<code>git push</code>指令可以将本地仓库上面的东西推送到远程仓库中，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>执行结果长这样：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031336488.webp" alt="image-20230803133602402"></p><p>之后到github上面就可以看到东西已经提交上去了。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031346455.webp" alt="image-20230803134614334"></p><p>细心的朋友可能会发现，这次提交的东西怎么是hello world呢？后来不是写了个hello git吗？这是因为，我们在上一步的时候把版本回退到了第一个版本，也就是整个仓库都是第一次提交的状态，那么push上去自然也就是那个时候的状态了。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p><code>git pull</code>指令用于把远程仓库上的代码拉取到本地仓库，执行pull指令需要注意：</p><ul><li><code>git pull</code>指令相当于<code>git fetch</code>和<code>git merge</code>指令，会把远程分支和本地分支进行合并，如果远程分支包含本地分支的修改，即远程分支比本地分支先进，就会更新本地分支。</li></ul><p>首先，在txt文件中加一行hello remote1，然后commit的消息为”add remote1”，再在txt文件中加一行hello remote2，然后commit消息”add remote2”，此时的文件应该是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello remote1</span><br><span class="line">hello remote2</span><br></pre></td></tr></table></figure><p>将add remote2的commit推送给到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>然后版本回退到remote1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>此时仓库的状态是远程分支领先当前分支一个commit，使用pull可以将远程仓库的更新拉下来并且自动更新本地工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>下图展示了一个单分支模型的pull过程：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040925411.webp" alt="image-20230804092501173"></p><ul><li>当远程仓库和本地仓库处在两个不同的分支时，在merge的时候就可能会出现冲突：</li></ul><p>在刚才的修改基础上，我们再退回去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>然后添加一行：hello remote3，即文件变成了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello remote1</span><br><span class="line">hello remote3</span><br></pre></td></tr></table></figure><p>commit当前修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m<span class="string">&quot;add remote3&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候，本地分支比远程分支领先1个commit，落后1个commit，而且修改的是同一个文件的同一行，会引发合并冲突：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040948792.webp" alt="image-20230804094839690"></p><p>此时需要我们手动合并冲突。出现合并冲突窗口后，不要急着关闭bash窗口，查看所有的CONFICT所在的文件，打开之后找到带有分隔符（&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;以及&gt;&gt;&gt;）的代码段或文本段：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040950461.webp" alt="image-20230804095051321"></p><p>选择一种方案保留，（推荐使用vscode打开，可以一键选择），我这里选择了保留当前更改，然后回到git bash，此时的仓库处于MERGING状态，需要手动修改完所有冲突文件之后再commit一次才能退出该状态，然后将此修改推送到远程仓库，此时两个仓库又处于同步状态了。</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040954824.webp" alt="image-20230804095453725"></p><p>本次合并的示意图如下：</p><pre class="mermaid">---title: 合并分支示意图---gitGraph   commit id: "init"   commit id: "add remote1"   branch origin_main   checkout origin_main   commit id: "add remote2"   checkout main   commit id: "add remote3"   merge origin_main   commit id: "merge confict"</pre><p>如果将本地分支push到远程分支，则会将远程分支的HEAD指针指向merge conflict：</p><p><img src="https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040959347.webp" alt="image-20230804095928183"></p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>git checkout用于切换仓库的工作状态，比如切换到指定分支或指定提交。常见的用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>上述指令用于切换到指定分支。一般来说，在实际开发中，一个仓库会有不同的分支，不同的人管理不同的分支。使用<code>git chekout -b &lt;branch_name&gt;</code>可以以当前分支为基础创建并切换到新的分支；使用<code>git branch -a</code>显示所有分支。</p><p>当在不同分支工作的时候，可以相互合并分支的代码，比如本地main分支合并远程dev分支（默认为origin&#x2F;dev），则可以在main分支下使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br></pre></td></tr></table></figure><p>前面我们说过，<code>git pull</code>相当于<code>git fetch+git merge</code>，<code>git fetch</code>指令就是将远程分支中的内容取到本地，而git merge则用于合并。一般情况下，git会使用自带的合并策略自动完成合并，出现冲突则需要手动处理并重新提交。</p><p>如果是本地分支合并另一个分支的代码，则无需使用pull指令，而是直接使用<code>git merge</code>。比如主分支合并本地dev分支，在main分支下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>git还有其他的用法，比如<code>git checkout</code>，<code>git merge</code>等等，实际上掌握了上面的常用指令之后就可以满足日常的合作开发需求了。学习git的最佳实践就是反复练习使用上面的指令，最终能够达到还没执行指令就知道会发生什么的境界，那就代表自己是真的理解了。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
