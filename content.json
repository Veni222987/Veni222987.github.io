[{"title":"【精】如何在项目中开启上帝视角——由浅入深研究监控系统","date":"2024-07-15T14:03:34.000Z","path":"2024/07/15/【精】如何在项目中开启上帝视角——由浅入深研究监控系统/","text":"监控系统俗称“第三只眼”，几乎是我们每天都会打交道的系统。本文将会从一个简单的监控系统开始，讲解系统模块组成，监控数据流向，由浅入深，研究典型监控系统的设计，最后比较一下两个监控系统的架构设计和场景表现。由于作者本人也是刚入门的新手，文章中如有错漏，欢迎随时指正。 监控系统的工作原理关于监控系统信息的分类，目前还没有比较统一的说法。本文将监控信息分为三类：基本信息、主机（容器）资源信息和应用（服务）信息，上述三种分类刚好对应了三类具有不同特点的信息： 分类 特点 举例 基本信息 由计算机本身确定、长期不变、通常只需要采集一次 CPU频率、内存大小、磁盘空间、网络地址等 主机（容器）资源信息 随时改变、客观存在、用户不可定义和修改 CPU利用率、内存利用率、磁盘利用率、网络传输速率等 应用（服务）信息 类型多样、用户可自定义和修改、每台主机都不一样 服务技术栈，metrics信息 Prometheus对于Metrics的定义如下： Metrics are numerical measurements in layperson terms. The term time series refers to the recording of changes over time. …… For a web server, it could be request times; for a database, it could be the number of active connections or active queries, and so on. 简单来说，metrics就是一系列随着时间改变的测量数据。可以是接口请求次数，也可以是数据库的连接次数。 监控系统基本框架下面是一个简单的监控系统(PiMonitor)整体架构图，包含四个模块： PiMetric模块用于采集和导出指标监控信息。 Agent部署在用户的计算机上，用于获取计算机的基本信息、资源利用率、和本机所有服务指标监控信息。 Server模块负责存储和查询数据，和Agent、Web两端交互。 Web模块负责数据的展示。 这一部分内容将会以PiMonitor监控系统为例，聚焦于Agent模块、PiMetric模块和数据层（主要是时序数据库InfluxDB），讲述监控系统的工作原理。其他次要模块（帐号系统、团队系统和Web展示模块）不会多做介绍。 上述架构图源于我的一个课程设计，麻雀虽小五脏俱全，它省略了抓取池、注册表等概念，简化了Metric设计，用最简单的例子说明监控系统的工作原理。有相关基础的读者可以选择性跳过部分内容。 感兴趣话可以看看这里：https://github.com/Veni222987/PiMonitor 监控信息从哪里来监控信息的获取主要有两大类的方法：非侵入式和侵入式的。非侵入式是指不在业务逻辑中写监控信息记录有关的代码，例如获取内存大小和利用率这类信息只需要调用系统接口获取即可。而侵入式是指需要在业务逻辑中写监控代码，例如统计某个接口的调用次数，通常的做法是在调用接口的时候对计数器进行自增操作。接下来我们看看上述三种分类信息是如何获取的。 基本信息和主机（容器）资源信息主要是使用系统提供的接口获取的，当然也可以使用第三方工具（如psutil获取）。例如，使用gopsutil可以获取系统的基本信息和资源信息。 gopsutil (go process and system utilities): Go语言主流的系统与进程信息获取工具，目前GitHub上已有10k+ stars。 GitHub地址：https://github.com/shirou/gopsutil 在引入了gopsutil的mem模块之后，获取计算机内存总量的代码十分简洁： 1234func getMemory() (uint64, error) &#123; memStat, _ := mem.VirtualMemory() return memStat.Total, nil&#125; 获取内存利用率的代码也类似： 123// 获取内存使用率memStat, _ := mem.VirtualMemory()pfm.MemPercent = memStat.UsedPercent 可以观察到，获取内存总量和获取内存利用率实际上都是由mem包的VirtualMemory获取的，但是在我们自己搭建监控系统的时候，一定不想把CPU型号、核数、频率等长期不变的数据每一次都上传一份重复的信息。因此，通常的设计是计算机运行一个agent，由这个agent分开获取不同类型的数据，计算机信息单独获取并且调用对应的接口获取一次，资源利用率、应用（服务）监控等信息由一个单独的协程持续获取并且上传。 应用（服务）信息获取一般都是侵入式的，简单来说，就是当我们想要在某个一业务中往监控系统中记录信息的时候，这里必须要写一些和监控系统操作相关的代码。例如：想要获取某一个接口的调用次数，就需要在调用接口之后对计数器进行自增操作： 1234567// 调用接口传出去if err := repo.UploadPerformance(pfm); err != nil &#123;// (省略部分代码)...... &#125;// metrics自增pimstore.CounterOf(&quot;send_message_counter&quot;).Incr() 总结一下监控信息从哪里来这个问题： 对于由计算机本身确定的信息，无论是基本信息还是资源信息，都可以通过gopsutil这类工具直接从系统获取。其中基本信息可以一次性获取，资源利用率信息需要一个单独的协程持续获取。 对于应用（服务）的信息，通常是需要在代码中侵入式地接入对应的监控系统模块，埋点记录监控指标对应的值，然后持续获取、存储和上传。 根据上面的描述，作出时序图如下： 这个时候再回头看看上面的监控系统架构图中的Agent模块，基本信息、资源监控、指标监控三个子模块应该就好理解多了。左侧的是辅助包，顶部repo用于上传数据到服务端，剩下的三个子模块就是获取三类不同监控信息的模块。 监控信息如何导出和传输上面说完了监控信息是如何获取的，接下来我们看一下监控信息是如何导出的。还是以上面提到的pimetric为例，理解一下监控信息如何从应用到agent。 当监控系统获取到监控信息的时候，就需要先把信息展示保存起来。最简单的方式就是直接在内存中保存起来，当数据导出的时候再清理并释放内存。在pimetric中，我采用了最简单直接的方法：使用map保存不同类型的metric数据。 当我们可以保存和获取监控数据之后，下一步就可以考虑如何把这些监控数据导出给用户。通常的做法是：在服务中引用这个模块，对外提供监控数据，通过一个agent收集本机的数据并且通过push或pull的形式上传到服务器作持久化存储（下面会讲）。这里先看一下数据是如何导出的。 在pimetric中，主要有两种方式导出数据： 只导出一个handler，由服务自行注册到对应的监听端口上，通常适用于http服务。下面的代码片段展示了如何生成一个handler并且在项目中使用。 1234567891011121314151617// GenHandler 指定appName生成handler，可以绑定到已有端口的特定路由上func GenHandler(appName string) func(w http.ResponseWriter, r *http.Request) &#123; return func(w http.ResponseWriter, r *http.Request) &#123; w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;) resBytes, err := json.Marshal(Metricx&#123; // ...... &#125;) if err != nil &#123; w.Write([]byte(err.Error())) return &#125; w.Write(resBytes) &#125;&#125;// 使用示例：// http.HandleFunc(&quot;/metrics&quot;, pimetric.GenHandler(&quot;gateway_svr&quot;)) 监听新端口导出数据，适用于不开放http端口的服务，例如RPC服务、消费者服务等等。 1234567891011// ExportMetrics 监听新端口导出数据func ExportMetrics(appName string) &#123; http.HandleFunc(&quot;/metrics&quot;, GenHandler(appName)) err := http.ListenAndServe(&quot;:62888&quot;, nil) for err != nil &#123; err = http.ListenAndServe(getRandomPort(), nil) &#125;&#125;// 使用示例：// pimetric.ExportMetrics(gateway_svr) 当这些信息全部都可以通过本地接口调用获取的时候，Agent就会扫描本机的端口，获取本机所有监控信息。这样用户侧的工作基本完成了，这时候再回顾上文的架构图中用户侧的两个模块，基本上就能理解Agent模块和PiMetric模块是如何协调工作的了。 监控信息如何持久化存储上面的局部图中有一个REST API，这个API就是用来做监控信息持久化存储的。Agent采用主动push的方式，每隔一段时间就会向监控系统服务器推送本机的所有监控数据。服务端收到上传的数据之后，经过Agent注册信息等检测，就会将数据写到Kafka中，再由Kafka消费者写入InfluxDB。 InfluxDB是一个时序数据库，它采用了一种时间序列数据模型，这意味着它特别适合存储与时间有关的数据。要理解InfluxDB需要理解几个比较关键的概念： measurement：一组测量数据，相当于SQL中的一张表。 point：一个数据记录点，相当于SQL中的一行数据。 field：测量值，一般而言是数据，没有索引，不可以根据field查找。 tag：标签，可以理解成为SQL中带有索引的列，可以根据tag快速查找。 与SQL不同的是，InfluxDB不需要预先定义measurement，而是在插入数据的时候自动处理field，这就是“时间就是一切”的思想，文档中有这样一句话： InfluxDB还会认识到您的schema可能随时间而改变。在InfluxDB中，您不需要在前面定义schema。数据点可以有一个measurement的field的一个，也可以有这个measurement的所有field，或其间的任何数字。 您可以在写数据的时候为该measurement添加一个新的field。 理解了上述几个概念之后，我们可以制定三类数据的持久化存储方式： 数据类型 存储模块 存储方式设计 计算机基本信息 MySQL 一个agent对应记录一行数据，包括CPU型号、频率、内存、磁盘等字段 资源利用率信息 InfluxDB 一台agent对应一个measurement，fields是CPU利用率，内存利用率等信息，每次push上传一次数据作为一个point 应用（服务）信息 InfluxDB 一台agent对应一个measurement，使用tag区分不同的服务，fields是不同的服务对应的metrics。 例如，Metric在InfluxDB中存储的形式是这样的： 12345678name: agent1_metricstags: service=gateway_svrtime #_counter.http_request #_gauge.tcp_connection---- ------------ ------------2015-04-16T12:00:00Z 0 12015-04-16T12:00:01Z 3 12015-04-16T12:00:02Z 15 22015-04-16T12:00:03Z 15 3 小结这一部分主要以一个简单的监控系统(PiMonitor)入手，逐步解析了监控系统的模块设计和数据结构，能看懂上面的四个小节基本上就能理解监控系统的工作原理了。接下来将会研究一下目前主流的监控系统Prometheus设计。 Prometheus设计研究现在最主流的监控系统应该就是Promethues+Grafana搭建的监控系统了。其中Promethues负责数据采集与存储，Grafana负责数据的展示。下面我们将会深入看一下这一套监控系统的设计细节。首先看看Prometheus的架构图： 数据传输方式设计Prometheus提供了两种数据传输的方式：分别是pull模式和push模式。这里主要讲讲pull模式是如何工作的。 Prometehus使用了一个target类型的结构记录一个监控节点，target类型的结构包括节点的标签、上次拉取时间、Metric元数据等等： 1234567891011121314151617// Target refers to a singular HTTP or HTTPS endpoint.type Target struct &#123; // Labels before any processing. discoveredLabels labels.Labels // Any labels that are added to this target and its metrics. labels labels.Labels // Additional URL parameters that are part of the target URL. params url.Values mtx sync.RWMutex lastError error lastScrape time.Time lastScrapeDuration time.Duration health TargetHealth //表示节点健康状态的字符串 metadata MetricMetadataStore //包含节点metric数据的大小、metric数据切片等结构&#125; 除了target，Prometehus的数据拉取模块还有几个关键的结构： Manager: 负责管理所有抓取任务和target集合的更新，包括加载配置，启动和停止循环等。Manager根据配置文件创建scrapePool，然后交给scrapePool负责具体的抓取工作，期间可能会执行Sync同步配置文件的target更新。 scrapePool: 管理一组目标抓取任务，通常对应一个抓取配置分组。scrapePool为targetGroup下的每个target，创建1个scrapeLoop，然后让scrapeLoop抓取数据。 scrapeLoop: 负责定期从target中抓取监控数据，包括scrape抓取数据，append写入存储模块等等。 用户通过一个yaml配置文件管理一个Manager，Manager依次往下管理scrapePool，scrapeLoop，最后把请求发到target。不同的Loop使用不同的协程独立获取target信息，确保了系统的高效性和稳定性。下面的示意图可以很清楚地展示服务端拉取数据的工作流程： Prometheus的服务端仓库的地址：https://github.com/prometheus/prometheus Prometheus对不同的语言提供了不同的客户端，go语言版本的仓库地址：https://github.com/prometheus/client_golang 看完了server侧的拉取原理，接下来看看client侧的工作原理。同样的，先介绍一下client侧几个重要的概念： Registry：用于注册和管理所有的指标。可以使用默认的全局注册表，也可以创建自定义注册表，注册表是指标数据的集合体。 Collector：表示可以被 Prometheus 收集的指标，包括Describe和Collect函数，Registry 实现了Collector接口。client_golang内置了一些Collector，例如GoCollector，ProcessCollector等。 Gatherer****：用于收集所有注册的指标。Registry 实现了 Gatherer 接口，包含一个Gather函数，该函数返回一个MetricFamily结构体，包含各种类型的Metric信息，结构体定义可以自行到源码中查看。 client_golang中，监听HTTP端口并且暴露metrics端点的代码如下，reg是一个Registry注册表，当用户发送一个HTTP GET请求到 *ip:port&#x2F;metrics* 的时候，请求的返回结果就是这个注册表中的Metrics。 12345678m := http.NewServeMux()// Create HTTP handler for Prometheus metrics.m.Handle(&quot;/metrics&quot;, promhttp.HandlerFor( reg, promhttp.HandlerOpts&#123; // Opt into OpenMetrics e.g. to support exemplars. EnableOpenMetrics: true, &#125;,)) 至此，client侧的工作原理也基本清楚了，整理得出client侧工作流程图如下，最终形成的target就是上文中服务侧scrapeLoop需要调用的target。 由于暂时没有深入研究prometheus的push模式源码，这里只做简单的描述，prometheus的push模式实现方法是：对于一些短作业，把监控数据push到一个专门的gateway，再由服务器从这个gateway拉取数据。感兴趣的读者也可以自己阅读学习一下。 Metric类型设计从宏观角度看，所有的metric都包含一个对外导出的接口，以及一个实现该接口的结构体。这里挑了三个最具代表性的类型详细研究一下，分别是：counter, gauge和histogram。 Countercounter是一种只能上升的指标，通常用于记录接口的请求次数，失败次数等。因此，Counter接口只包含了两个自定义函数：Inc和Add。Counter类型的接口还继承了Metric接口和Collector接口，Metric接口用于获取Metric的描述等信息。 1234567type Counter interface &#123; Metric Collector Inc() Add(float64)&#125; 下面是Counter接口的实现结构，有几个值得关注的地方： 为什么有两个val值？而且均使用了uint64结构？ valBits代表一个float64的比特位，valInt代表一个精确的整数，两者均用uint64表示是为了在原子操作中保持一致。 selfCollector是什么？有什么作用？ counter并没有直接实现Collector接口，而是由selfCollector实现了Collector接口，selfCollector是一个与Metric无关的结构体，在其他Metric中也存在，这样的设计简化了代码。 exemplar是什么？ exemplar是一个基于原子量进行读写的结构，可以为metrics添加trace信息，这样metrics和tracing就可以关联起来。不过我认为，Prometheus对于trace的支持不是很好，这一部分可以去看看其他的监控系统。 123456789101112type counter struct &#123; valBits uint64 valInt uint64 selfCollector desc *Desc createdTs *timestamppb.Timestamp labelPairs []*dto.LabelPair exemplar atomic.Value // Containing nil or a *dto.Exemplar. now func() time.Time&#125; Gaugegauge类型的接口设计如下，同样继承了Metric和Collector两个接口，并且定义了一些gauge类型独有的操作。 1234567891011type Gauge interface &#123; Metric Collector Set(float64) Inc() Dec() Add(float64) Sub(float64) SetToCurrentTime()&#125; gauge类型的结构体定义如下，valBits也是使用unit64记录的float64值，相比于counter，gauge结构体少了valInt，exemplar等，因为gauge本身的定义就是一系列随时间变化的测量数据，绝大多数情况下是非整形的，所以只需要一个float64类型的数据即可。 123456789type gauge struct &#123; valBits uint64 selfCollector desc *Desc labelPairs []*dto.LabelPair&#125; Histogramhistogram相当于统计数据，一般适用于记录一些能够做成统计直方图的数据。histogram类型同样继承了Metric和Collector接口，并且只包含一个Observe函数，该函数用于将一个观测值加入到histogram统计数据中。 12345678910111213type Histogram interface &#123; Metric Collector // Observe adds a single observation to the histogram. Observations are // usually positive or zero. Negative observations are accepted but // prevent current versions of Prometheus from properly detecting // counter resets in the sum of observations. (The experimental Native // Histograms handle negative observations properly.) See // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations // for details. Observe(float64)&#125; histogram的结构体比较复杂，包含的数据结构很多，重点关注一下countAndHotIdx, counts, upperBounds这几个与数据存储紧密相关的字段下面主要讲histogram类型的数据存储的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type histogram struct &#123; // countAndHotIdx enables lock-free writes with use of atomic updates. // The most significant bit is the hot index [0 or 1] of the count field // below. Observe calls update the hot one. All remaining bits count the // number of Observe calls. Observe starts by incrementing this counter, // and finish by incrementing the count field in the respective // histogramCounts, as a marker for completion. // // Calls of the Write method (which are non-mutating reads from the // perspective of the histogram) swap the hot–cold under the writeMtx // lock. A cooldown is awaited (while locked) by comparing the number of // observations with the initiation count. Once they match, then the // last observation on the now cool one has completed. All cold fields must // be merged into the new hot before releasing writeMtx. // // Fields with atomic access first! See alignment constraint: // http://golang.org/pkg/sync/atomic/#pkg-note-BUG countAndHotIdx uint64 selfCollector desc *Desc // Only used in the Write method and for sparse bucket management. mtx sync.Mutex // Two counts, one is &quot;hot&quot; for lock-free observations, the other is // &quot;cold&quot; for writing out a dto.Metric. It has to be an array of // pointers to guarantee 64bit alignment of the histogramCounts, see // http://golang.org/pkg/sync/atomic/#pkg-note-BUG. counts [2]*histogramCounts upperBounds []float64 labelPairs []*dto.LabelPair exemplars []atomic.Value // One more than buckets (to include +Inf), each a *dto.Exemplar. nativeHistogramSchema int32 // The initial schema. Set to math.MinInt32 if no sparse buckets are used. nativeHistogramZeroThreshold float64 // The initial zero threshold. nativeHistogramMaxZeroThreshold float64 nativeHistogramMaxBuckets uint32 nativeHistogramMinResetDuration time.Duration // lastResetTime is protected by mtx. It is also used as created timestamp. lastResetTime time.Time // resetScheduled is protected by mtx. It is true if a reset is // scheduled for a later time (when nativeHistogramMinResetDuration has // passed). resetScheduled bool nativeExemplars nativeExemplars // now is for testing purposes, by default it&#x27;s time.Now. now func() time.Time // afterFunc is for testing purposes, by default it&#x27;s time.AfterFunc. afterFunc func(time.Duration, func()) *time.Timer&#125; 我们将从它唯一的Observe函数入手，研究一下数据的存储方式。首先我们假定已经定义好了存储桶bucket，存储桶是一系列的用于分隔数据范围的浮点数，例如默认的存储桶为： 1var DefBuckets = []float64&#123;.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10&#125; 然后观察Observe函数的实现，Observe函数接受唯一的float64类型输入，表示一个观测值，findBucket函数用于查找当前的观测值位于哪一个存储桶中： 123func (h *histogram) Observe(v float64) &#123; h.observe(v, h.findBucket(v))&#125; 获取存储桶的序号之后，就会调用一个内部函数observe，该函数的实现如下，n是一个原子自增的计数器，后面的右移63位表示只根据最高位取出热桶(热桶只有两个，可以看上面的结构体定义中的counts字段)，然后调用该热桶的observe方法。doSparse是判断是否使用稀疏桶的布尔值，用于处理一些边界数据。 1234567891011121314// observe is the implementation for Observe without the findBucket part.func (h *histogram) observe(v float64, bucket int) &#123; // Do not add to sparse buckets for NaN observations. doSparse := h.nativeHistogramSchema &gt; math.MinInt32 &amp;&amp; !math.IsNaN(v) // We increment h.countAndHotIdx so that the counter in the lower // 63 bits gets incremented. At the same time, we get the new value // back, which we can use to find the currently-hot counts. n := atomic.AddUint64(&amp;h.countAndHotIdx, 1) hotCounts := h.counts[n&gt;&gt;63] hotCounts.observe(v, bucket, doSparse) if doSparse &#123; h.limitBuckets(hotCounts, v, bucket) &#125;&#125; 最终的存储单位是histogramCounts的buckets，这个切片记录了每一个bucket区间内的数据总量。histogram并不保存原始数据，只关心数据的分布状况，因此会产生一定程度的信息丢失。如果在展示中出现的有关histogram的统计数值，一般是使用数学模型拟合出来的，与原始数据存在误差。 1234567891011func (hc *histogramCounts) observe(v float64, bucket int, doSparse bool) &#123; if bucket &lt; len(hc.buckets) &#123; atomic.AddUint64(&amp;hc.buckets[bucket], 1) &#125; atomicAddFloat(&amp;hc.sumBits, v) if doSparse &amp;&amp; !math.IsNaN(v) &#123; // 省略中间的稀疏桶处理逻辑 &#125; // Increment count last as we take it as a signal that the observation is complete. atomic.AddUint64(&amp;hc.count, 1)&#125; 这一部分介绍了三种主要的Metric的设计，总的来说还是有许多值得参考学习的地方的。其他Metric和一些具体细节也可以自己到client_golang源码中查看。 TSDB与PromQLPrometheus有一个专用的时间序列数据库，位于prometheus&#x2F;tsdb目录下，此外，他还提供了一种针对这个时序数据库的查询语言，称为PromQL，位于prometheus&#x2F;promql目录下。由于上一部分中已经介绍过了InfluxDB，并且这两部分的源代码比较复杂，这里就简单介绍一下TSDB和PromQL的特性和功能。 在TSDB中，时间序列中的每一个点称为一个样本（sample），样本由以下三部分组成: 指标(metric)：metric name和描述当前样本特征的labelsets; 时间戳(timestamp)：毫秒级时间戳; 样本值(value)： 一个float64的浮点型数据表示当前样本的值。 例如： 123456789&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417560938 =&gt; 94355http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417561287 =&gt; 94334http_request_total&#123;status=&quot;404&quot;, method=&quot;GET&quot;&#125;@1434417560938 =&gt; 38473http_request_total&#123;status=&quot;404&quot;, method=&quot;GET&quot;&#125;@1434417561287 =&gt; 38544http_request_total&#123;status=&quot;200&quot;, method=&quot;POST&quot;&#125;@1434417560938 =&gt; 4748http_request_total&#123;status=&quot;200&quot;, method=&quot;POST&quot;&#125;@1434417561287 =&gt; 4785 由于prometheus的TSDB是专门为它自己服务的，所以整体设计上会比InfluxDB要简单一些。它使用了Metric代替InfluxDB的measurement的概念，原生支持记录Metric的时间序列记录，减少了自己转换结构和设计数据字段的工作。 当数据存入TSDB之后，就可以使用PromQL查询某个Metric数据。这里有两个关键的概念： Engine: 负责管理多次查询的整个生命周期，可以配置超时时间、日志等。 Query: 是一个接口，负责管理一次查询，包括查询语句、执行、取消、关闭等操作。 本质上，PromQL(Prometheus Query Language)就是一个针对TSDB的QL，其功能和用法都类似SQL，一般而言在搭建可视化平台的时候就写好的，后期改动较少，这里就不加赘述了。 架构差异与功能比较上文介绍了两个监控系统：PiMonitor和Prometheus，两者的架构设计最大的区别在于是否有单独Agent代理，这个区别导致了某些场景下两个监控系统有不同的表现： 功能 PiMonitor Prometheus 计算机信息采集 原生支持采集计算机基本信息和资源利用率 需要启动额外的Exporter 服务与框架集成 需要在服务中手动指定所有监控指标 许多服务和框架都预留了Prometheus监控集成功能 信息传输方式 仅支持通过Agent上传的push模式 以pull模式为主，push模式为辅 新增服务 可以监控所有使用pimetric模块的服务，启动后无需额外操作 每次增加新服务都需要修改服务端拉取目标的配置文件 总结本文由浅入深，从自己的监控系统入手，讲述了监控系统的基本组成部分和数据流向，让读者对于监控系统的工作原理有了基本的认识。然后研究了社区最活跃的监控系统Prometheus，学习其架构设计和底层实现，尽管只研究了冰山一角，但也让人获益匪浅。 本文也有一定的局限性，由于Prometheus是一个以Metric为核心的监控系统，对于日志(Log)、调用链(Trace)的支持不佳，难以打造一个全方位的监控系统，这篇文章也因此缺少了这两部分可观测对象监控的工作原理。 感谢大家的阅读，如有错误，欢迎指出。 参考资料 Prometheus官方文档：https://prometheus.io/docs/introduction/overview/ InfluxDB中文文档：https://jasper-zhang1.gitbooks.io/influxdb/content/ 技术文章： exemplar：https://segmentfault.com/a/1190000043394360 监控系统选型：https://www.cnblogs.com/qdhxhz/p/16289758.html histogram：https://juejin.cn/post/7152837166190739486","content":"<p>监控系统俗称“第三只眼”，几乎是我们每天都会打交道的系统。本文将会从一个简单的监控系统开始，讲解系统模块组成，监控数据流向，由浅入深，研究典型监控系统的设计，最后比较一下两个监控系统的架构设计和场景表现。由于作者本人也是刚入门的新手，文章中如有错漏，欢迎随时指正。</p>\n<h1 id=\"监控系统的工作原理\"><a href=\"#监控系统的工作原理\" class=\"headerlink\" title=\"监控系统的工作原理\"></a>监控系统的工作原理</h1><p>关于监控系统信息的分类，目前还没有比较统一的说法。本文将监控信息分为三类：基本信息、主机（容器）资源信息和应用（服务）信息，上述三种分类刚好对应了三类具有不同特点的信息：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>特点</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基本信息</td>\n<td>由计算机本身确定、长期不变、通常只需要采集一次</td>\n<td>CPU频率、内存大小、磁盘空间、网络地址等</td>\n</tr>\n<tr>\n<td>主机（容器）资源信息</td>\n<td>随时改变、客观存在、用户不可定义和修改</td>\n<td>CPU利用率、内存利用率、磁盘利用率、网络传输速率等</td>\n</tr>\n<tr>\n<td>应用（服务）信息</td>\n<td>类型多样、用户可自定义和修改、每台主机都不一样</td>\n<td>服务技术栈，metrics信息</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Prometheus对于Metrics的定义如下：</p>\n<p>Metrics are numerical measurements in layperson terms. The term time series refers to the recording of changes over time.</p>\n<p>……</p>\n<p>For a web server, it could be request times; for a database, it could be the number of active connections or active queries, and so on.</p>\n<p>简单来说，metrics就是一系列随着时间改变的测量数据。可以是接口请求次数，也可以是数据库的连接次数。</p>\n</blockquote>\n<h2 id=\"监控系统基本框架\"><a href=\"#监控系统基本框架\" class=\"headerlink\" title=\"监控系统基本框架\"></a>监控系统基本框架</h2><p>下面是一个简单的监控系统(PiMonitor)整体架构图，包含四个模块：</p>\n<ol>\n<li>PiMetric模块用于采集和导出指标监控信息。</li>\n<li>Agent部署在用户的计算机上，用于获取计算机的基本信息、资源利用率、和本机所有服务指标监控信息。</li>\n<li>Server模块负责存储和查询数据，和Agent、Web两端交互。</li>\n<li>Web模块负责数据的展示。</li>\n</ol>\n<p>这一部分内容将会以PiMonitor监控系统为例，聚焦于Agent模块、PiMetric模块和数据层（主要是时序数据库InfluxDB），讲述监控系统的工作原理。其他次要模块（帐号系统、团队系统和Web展示模块）不会多做介绍。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715220848894.png\" alt=\"image-20240715220848894\"></p>\n<blockquote>\n<p>上述架构图源于我的一个课程设计，麻雀虽小五脏俱全，它省略了抓取池、注册表等概念，简化了Metric设计，用最简单的例子说明监控系统的工作原理。有相关基础的读者可以选择性跳过部分内容。</p>\n<p>感兴趣话可以看看这里：<a href=\"https://github.com/Veni222987/PiMonitor\">https://github.com/Veni222987/PiMonitor</a></p>\n</blockquote>\n<h2 id=\"监控信息从哪里来\"><a href=\"#监控信息从哪里来\" class=\"headerlink\" title=\"监控信息从哪里来\"></a>监控信息从哪里来</h2><p>监控信息的获取主要有两大类的方法：非侵入式和侵入式的。非侵入式是指不在业务逻辑中写监控信息记录有关的代码，例如获取内存大小和利用率这类信息只需要调用系统接口获取即可。而侵入式是指需要在业务逻辑中写监控代码，例如统计某个接口的调用次数，通常的做法是在调用接口的时候对计数器进行自增操作。接下来我们看看上述三种分类信息是如何获取的。</p>\n<p>基本信息和主机（容器）资源信息主要是使用系统提供的接口获取的，当然也可以使用第三方工具（如psutil获取）。例如，使用gopsutil可以获取系统的基本信息和资源信息。</p>\n<blockquote>\n<p><strong>gopsutil (go process and system utilities):</strong> Go语言主流的系统与进程信息获取工具，目前GitHub上已有10k+ stars。</p>\n<p>GitHub地址：<a href=\"https://github.com/shirou/gopsutil\">https://github.com/shirou/gopsutil</a></p>\n</blockquote>\n<p>在引入了gopsutil的mem模块之后，获取计算机内存总量的代码十分简洁：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getMemory</span><span class=\"params\">()</span></span> (<span class=\"type\">uint64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tmemStat, _ := mem.VirtualMemory()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> memStat.Total, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取内存利用率的代码也类似：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取内存使用率</span></span><br><span class=\"line\">memStat, _ := mem.VirtualMemory()</span><br><span class=\"line\">pfm.MemPercent = memStat.UsedPercent</span><br></pre></td></tr></table></figure>\n\n<p>可以观察到，获取内存总量和获取内存利用率实际上都是由mem包的VirtualMemory获取的，但是在我们自己搭建监控系统的时候，一定不想把CPU型号、核数、频率等长期不变的数据每一次都上传一份重复的信息。因此，通常的设计是计算机运行一个agent，由这个agent分开获取不同类型的数据，计算机信息单独获取并且调用对应的接口获取一次，资源利用率、应用（服务）监控等信息由一个单独的协程持续获取并且上传。</p>\n<p>应用（服务）信息获取一般都是侵入式的，简单来说，就是当我们想要在某个一业务中往监控系统中记录信息的时候，这里必须要写一些和监控系统操作相关的代码。例如：想要获取某一个接口的调用次数，就需要在调用接口之后对计数器进行自增操作：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用接口传出去</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := repo.UploadPerformance(pfm); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// (省略部分代码)......    </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// metrics自增</span></span><br><span class=\"line\">pimstore.CounterOf(<span class=\"string\">&quot;send_message_counter&quot;</span>).Incr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结一下监控信息从哪里来这个问题：</p>\n<ol>\n<li>对于由计算机本身确定的信息，无论是基本信息还是资源信息，都可以通过gopsutil这类工具直接从系统获取。其中基本信息可以一次性获取，资源利用率信息需要一个单独的协程持续获取。</li>\n<li>对于应用（服务）的信息，通常是需要在代码中侵入式地接入对应的监控系统模块，埋点记录监控指标对应的值，然后持续获取、存储和上传。</li>\n</ol>\n<p>根据上面的描述，作出时序图如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715221237749.png\" alt=\"image-20240715221237749\"></p>\n<p>这个时候再回头看看上面的监控系统架构图中的Agent模块，基本信息、资源监控、指标监控三个子模块应该就好理解多了。左侧的是辅助包，顶部repo用于上传数据到服务端，剩下的三个子模块就是获取三类不同监控信息的模块。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715221255928.png\" alt=\"image-20240715221255928\"></p>\n<h2 id=\"监控信息如何导出和传输\"><a href=\"#监控信息如何导出和传输\" class=\"headerlink\" title=\"监控信息如何导出和传输\"></a>监控信息如何导出和传输</h2><p>上面说完了监控信息是如何获取的，接下来我们看一下监控信息是如何导出的。还是以上面提到的pimetric为例，理解一下监控信息如何从应用到agent。</p>\n<p>当监控系统获取到监控信息的时候，就需要先把信息展示保存起来。最简单的方式就是直接在内存中保存起来，当数据导出的时候再清理并释放内存。在pimetric中，我采用了最简单直接的方法：使用map保存不同类型的metric数据。</p>\n<p>当我们可以保存和获取监控数据之后，下一步就可以考虑如何把这些监控数据导出给用户。通常的做法是：在服务中引用这个模块，对外提供监控数据，通过一个agent收集本机的数据并且通过push或pull的形式上传到服务器作持久化存储（下面会讲）。这里先看一下数据是如何导出的。</p>\n<p>在pimetric中，主要有两种方式导出数据：</p>\n<ol>\n<li>只导出一个handler，由服务自行注册到对应的监听端口上，通常适用于http服务。下面的代码片段展示了如何生成一个handler并且在项目中使用。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GenHandler 指定appName生成handler，可以绑定到已有端口的特定路由上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GenHandler</span><span class=\"params\">(appName <span class=\"type\">string</span>)</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tw.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">\t\tresBytes, err := json.Marshal(Metricx&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tw.Write([]<span class=\"type\">byte</span>(err.Error()))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw.Write(resBytes)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例：</span></span><br><span class=\"line\"><span class=\"comment\">// http.HandleFunc(&quot;/metrics&quot;, pimetric.GenHandler(&quot;gateway_svr&quot;))</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>监听新端口导出数据，适用于不开放http端口的服务，例如RPC服务、消费者服务等等。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ExportMetrics 监听新端口导出数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ExportMetrics</span><span class=\"params\">(appName <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/metrics&quot;</span>, GenHandler(appName))</span><br><span class=\"line\">\terr := http.ListenAndServe(<span class=\"string\">&quot;:62888&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = http.ListenAndServe(getRandomPort(), <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例：</span></span><br><span class=\"line\"><span class=\"comment\">// pimetric.ExportMetrics(gateway_svr)</span></span><br></pre></td></tr></table></figure>\n\n<p>当这些信息全部都可以通过本地接口调用获取的时候，Agent就会扫描本机的端口，获取本机所有监控信息。这样用户侧的工作基本完成了，这时候再回顾上文的架构图中用户侧的两个模块，基本上就能理解Agent模块和PiMetric模块是如何协调工作的了。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715221421845.png\" alt=\"image-20240715221421845\"></p>\n<h2 id=\"监控信息如何持久化存储\"><a href=\"#监控信息如何持久化存储\" class=\"headerlink\" title=\"监控信息如何持久化存储\"></a>监控信息如何持久化存储</h2><p>上面的局部图中有一个REST API，这个API就是用来做监控信息持久化存储的。Agent采用主动push的方式，每隔一段时间就会向监控系统服务器推送本机的所有监控数据。服务端收到上传的数据之后，经过Agent注册信息等检测，就会将数据写到Kafka中，再由Kafka消费者写入InfluxDB。</p>\n<p>InfluxDB是一个时序数据库，它采用了一种时间序列数据模型，这意味着它特别适合存储与时间有关的数据。要理解InfluxDB需要理解几个比较关键的概念：</p>\n<ul>\n<li><p>measurement：一组测量数据，相当于SQL中的一张表。</p>\n</li>\n<li><p>point：一个数据记录点，相当于SQL中的一行数据。</p>\n</li>\n<li><p>field：测量值，一般而言是数据，没有索引，不可以根据field查找。</p>\n</li>\n<li><p>tag：标签，可以理解成为SQL中带有索引的列，可以根据tag快速查找。</p>\n</li>\n</ul>\n<p>与SQL不同的是，InfluxDB不需要预先定义measurement，而是在插入数据的时候自动处理field，这就是“时间就是一切”的思想，文档中有这样一句话：</p>\n<p>InfluxDB还会认识到您的schema可能随时间而改变。在InfluxDB中，您不需要在前面定义schema。数据点可以有一个measurement的field的一个，也可以有这个measurement的所有field，或其间的任何数字。 您可以在写数据的时候为该measurement添加一个新的field。</p>\n<p>理解了上述几个概念之后，我们可以制定三类数据的持久化存储方式：</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>存储模块</th>\n<th>存储方式设计</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机基本信息</td>\n<td>MySQL</td>\n<td>一个agent对应记录一行数据，包括CPU型号、频率、内存、磁盘等字段</td>\n</tr>\n<tr>\n<td>资源利用率信息</td>\n<td>InfluxDB</td>\n<td>一台agent对应一个measurement，fields是CPU利用率，内存利用率等信息，每次push上传一次数据作为一个point</td>\n</tr>\n<tr>\n<td>应用（服务）信息</td>\n<td>InfluxDB</td>\n<td>一台agent对应一个measurement，使用tag区分不同的服务，fields是不同的服务对应的metrics。</td>\n</tr>\n</tbody></table>\n<p>例如，Metric在InfluxDB中存储的形式是这样的：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: agent1_metrics</span><br><span class=\"line\">tags: service=gateway_svr</span><br><span class=\"line\">time                           #_counter.http_request    #_gauge.tcp_connection</span><br><span class=\"line\">----                           ------------              ------------</span><br><span class=\"line\">2015-04-16T12:00:00Z           0                        1</span><br><span class=\"line\">2015-04-16T12:00:01Z           3                        1</span><br><span class=\"line\">2015-04-16T12:00:02Z           15                       2</span><br><span class=\"line\">2015-04-16T12:00:03Z           15                       3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这一部分主要以一个简单的监控系统(PiMonitor)入手，逐步解析了监控系统的模块设计和数据结构，能看懂上面的四个小节基本上就能理解监控系统的工作原理了。接下来将会研究一下目前主流的监控系统Prometheus设计。</p>\n<h1 id=\"Prometheus设计研究\"><a href=\"#Prometheus设计研究\" class=\"headerlink\" title=\"Prometheus设计研究\"></a>Prometheus设计研究</h1><p>现在最主流的监控系统应该就是Promethues+Grafana搭建的监控系统了。其中Promethues负责数据采集与存储，Grafana负责数据的展示。下面我们将会深入看一下这一套监控系统的设计细节。首先看看Prometheus的架构图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715221708799.png\" alt=\"image-20240715221708799\"></p>\n<h2 id=\"数据传输方式设计\"><a href=\"#数据传输方式设计\" class=\"headerlink\" title=\"数据传输方式设计\"></a>数据传输方式设计</h2><p>Prometheus提供了两种数据传输的方式：分别是pull模式和push模式。这里主要讲讲pull模式是如何工作的。</p>\n<p>Prometehus使用了一个target类型的结构记录一个监控节点，target类型的结构包括节点的标签、上次拉取时间、Metric元数据等等：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Target refers to a singular HTTP or HTTPS endpoint.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Target <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Labels before any processing.</span></span><br><span class=\"line\">\tdiscoveredLabels labels.Labels</span><br><span class=\"line\">\t<span class=\"comment\">// Any labels that are added to this target and its metrics.</span></span><br><span class=\"line\">\tlabels labels.Labels</span><br><span class=\"line\">\t<span class=\"comment\">// Additional URL parameters that are part of the target URL.</span></span><br><span class=\"line\">\tparams url.Values</span><br><span class=\"line\"></span><br><span class=\"line\">\tmtx                sync.RWMutex</span><br><span class=\"line\">\tlastError          <span class=\"type\">error</span></span><br><span class=\"line\">\tlastScrape         time.Time</span><br><span class=\"line\">\tlastScrapeDuration time.Duration       </span><br><span class=\"line\">\thealth             TargetHealth        <span class=\"comment\">//表示节点健康状态的字符串</span></span><br><span class=\"line\">\tmetadata           MetricMetadataStore <span class=\"comment\">//包含节点metric数据的大小、metric数据切片等结构</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>除了target，Prometehus的数据拉取模块还有几个关键的结构：</p>\n<ul>\n<li><strong>Manager:</strong> 负责管理所有抓取任务和target集合的更新，包括加载配置，启动和停止循环等。Manager根据配置文件创建scrapePool，然后交给scrapePool负责具体的抓取工作，期间可能会执行Sync同步配置文件的target更新。</li>\n<li><strong>scrapePool:</strong> 管理一组目标抓取任务，通常对应一个抓取配置分组。scrapePool为targetGroup下的每个target，创建1个scrapeLoop，然后让scrapeLoop抓取数据。</li>\n<li><strong>scrapeLoop:</strong> 负责定期从target中抓取监控数据，包括scrape抓取数据，append写入存储模块等等。</li>\n</ul>\n<p>用户通过一个yaml配置文件管理一个Manager，Manager依次往下管理scrapePool，scrapeLoop，最后把请求发到target。不同的Loop使用不同的协程独立获取target信息，确保了系统的高效性和稳定性。下面的示意图可以很清楚地展示服务端拉取数据的工作流程：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715221829516.png\" alt=\"image-20240715221829516\"></p>\n<blockquote>\n<p>Prometheus的服务端仓库的地址：<a href=\"https://github.com/prometheus/prometheus\">https://github.com/prometheus/prometheus</a></p>\n<p>Prometheus对不同的语言提供了不同的客户端，go语言版本的仓库地址：<a href=\"https://github.com/prometheus/client_golang\">https://github.com/prometheus/client_golang</a></p>\n</blockquote>\n<p>看完了server侧的拉取原理，接下来看看client侧的工作原理。同样的，先介绍一下client侧几个重要的概念：</p>\n<ul>\n<li><strong>Registry</strong>：用于注册和管理所有的指标。可以使用默认的全局注册表，也可以创建自定义注册表，注册表是指标数据的集合体。</li>\n<li><strong>Collector：</strong>表示可以被 Prometheus 收集的指标，包括Describe和Collect函数，Registry 实现了Collector接口。client_golang内置了一些Collector，例如GoCollector，ProcessCollector等。</li>\n<li><strong>Gatherer****：</strong>用于收集所有注册的指标。Registry 实现了 Gatherer 接口，包含一个Gather函数，该函数返回一个MetricFamily结构体，包含各种类型的Metric信息，结构体定义可以自行到源码中查看。</li>\n</ul>\n<p>client_golang中，监听HTTP端口并且暴露metrics端点的代码如下，reg是一个Registry注册表，当用户发送一个HTTP GET请求到 *<strong>ip:port&#x2F;metrics*</strong> 的时候，请求的返回结果就是这个注册表中的Metrics。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := http.NewServeMux()</span><br><span class=\"line\"><span class=\"comment\">// Create HTTP handler for Prometheus metrics.</span></span><br><span class=\"line\">m.Handle(<span class=\"string\">&quot;/metrics&quot;</span>, promhttp.HandlerFor(</span><br><span class=\"line\">  reg, promhttp.HandlerOpts&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Opt into OpenMetrics e.g. to support exemplars.</span></span><br><span class=\"line\">    EnableOpenMetrics: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n\n<p>至此，client侧的工作原理也基本清楚了，整理得出client侧工作流程图如下，最终形成的target就是上文中服务侧scrapeLoop需要调用的target。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240715222027951.png\" alt=\"image-20240715222027951\"></p>\n<p>由于暂时没有深入研究prometheus的push模式源码，这里只做简单的描述，prometheus的push模式实现方法是：对于一些短作业，把监控数据push到一个专门的gateway，再由服务器从这个gateway拉取数据。感兴趣的读者也可以自己阅读学习一下。</p>\n<h2 id=\"Metric类型设计\"><a href=\"#Metric类型设计\" class=\"headerlink\" title=\"Metric类型设计\"></a>Metric类型设计</h2><p>从宏观角度看，所有的metric都包含一个对外导出的接口，以及一个实现该接口的结构体。这里挑了三个最具代表性的类型详细研究一下，分别是：counter, gauge和histogram。</p>\n<h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>counter是一种只能上升的指标，通常用于记录接口的请求次数，失败次数等。因此，Counter接口只包含了两个自定义函数：Inc和Add。Counter类型的接口还继承了Metric接口和Collector接口，Metric接口用于获取Metric的描述等信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Counter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tMetric</span><br><span class=\"line\">\tCollector</span><br><span class=\"line\"></span><br><span class=\"line\">\tInc()</span><br><span class=\"line\">\tAdd(<span class=\"type\">float64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是Counter接口的实现结构，有几个值得关注的地方：</p>\n<ul>\n<li>为什么有两个val值？而且均使用了uint64结构？</li>\n</ul>\n<p>valBits代表一个float64的比特位，valInt代表一个精确的整数，两者均用uint64表示是为了在原子操作中保持一致。</p>\n<ul>\n<li>selfCollector是什么？有什么作用？</li>\n</ul>\n<p>counter并没有直接实现Collector接口，而是由selfCollector实现了Collector接口，selfCollector是一个与Metric无关的结构体，在其他Metric中也存在，这样的设计简化了代码。</p>\n<ul>\n<li>exemplar是什么？</li>\n</ul>\n<p>exemplar是一个基于原子量进行读写的结构，可以为metrics添加trace信息，这样metrics和tracing就可以关联起来。不过我认为，Prometheus对于trace的支持不是很好，这一部分可以去看看其他的监控系统。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> counter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalBits <span class=\"type\">uint64</span></span><br><span class=\"line\">\tvalInt  <span class=\"type\">uint64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tselfCollector</span><br><span class=\"line\">\tdesc *Desc</span><br><span class=\"line\"></span><br><span class=\"line\">\tcreatedTs  *timestamppb.Timestamp</span><br><span class=\"line\">\tlabelPairs []*dto.LabelPair</span><br><span class=\"line\">\texemplar   atomic.Value <span class=\"comment\">// Containing nil or a *dto.Exemplar.</span></span><br><span class=\"line\">\tnow <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> time.Time</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h3><p>gauge类型的接口设计如下，同样继承了Metric和Collector两个接口，并且定义了一些gauge类型独有的操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Gauge <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tMetric</span><br><span class=\"line\">\tCollector</span><br><span class=\"line\"></span><br><span class=\"line\">\tSet(<span class=\"type\">float64</span>)</span><br><span class=\"line\">\tInc()</span><br><span class=\"line\">\tDec()</span><br><span class=\"line\">\tAdd(<span class=\"type\">float64</span>)</span><br><span class=\"line\">\tSub(<span class=\"type\">float64</span>)</span><br><span class=\"line\">\tSetToCurrentTime()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>gauge类型的结构体定义如下，valBits也是使用unit64记录的float64值，相比于counter，gauge结构体少了valInt，exemplar等，因为gauge本身的定义就是一系列随时间变化的测量数据，绝大多数情况下是非整形的，所以只需要一个float64类型的数据即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> gauge <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalBits <span class=\"type\">uint64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tselfCollector</span><br><span class=\"line\"></span><br><span class=\"line\">\tdesc       *Desc</span><br><span class=\"line\">\tlabelPairs []*dto.LabelPair</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h3><p>histogram相当于统计数据，一般适用于记录一些能够做成统计直方图的数据。histogram类型同样继承了Metric和Collector接口，并且只包含一个Observe函数，该函数用于将一个观测值加入到histogram统计数据中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Histogram <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tMetric</span><br><span class=\"line\">\tCollector</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Observe adds a single observation to the histogram. Observations are</span></span><br><span class=\"line\">\t<span class=\"comment\">// usually positive or zero. Negative observations are accepted but</span></span><br><span class=\"line\">\t<span class=\"comment\">// prevent current versions of Prometheus from properly detecting</span></span><br><span class=\"line\">\t<span class=\"comment\">// counter resets in the sum of observations. (The experimental Native</span></span><br><span class=\"line\">\t<span class=\"comment\">// Histograms handle negative observations properly.) See</span></span><br><span class=\"line\">\t<span class=\"comment\">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span></span><br><span class=\"line\">\t<span class=\"comment\">// for details.</span></span><br><span class=\"line\">\tObserve(<span class=\"type\">float64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>histogram的结构体比较复杂，包含的数据结构很多，重点关注一下countAndHotIdx, counts, upperBounds这几个与数据存储紧密相关的字段下面主要讲histogram类型的数据存储的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> histogram <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// countAndHotIdx enables lock-free writes with use of atomic updates.</span></span><br><span class=\"line\">\t<span class=\"comment\">// The most significant bit is the hot index [0 or 1] of the count field</span></span><br><span class=\"line\">\t<span class=\"comment\">// below. Observe calls update the hot one. All remaining bits count the</span></span><br><span class=\"line\">\t<span class=\"comment\">// number of Observe calls. Observe starts by incrementing this counter,</span></span><br><span class=\"line\">\t<span class=\"comment\">// and finish by incrementing the count field in the respective</span></span><br><span class=\"line\">\t<span class=\"comment\">// histogramCounts, as a marker for completion.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// Calls of the Write method (which are non-mutating reads from the</span></span><br><span class=\"line\">\t<span class=\"comment\">// perspective of the histogram) swap the hot–cold under the writeMtx</span></span><br><span class=\"line\">\t<span class=\"comment\">// lock. A cooldown is awaited (while locked) by comparing the number of</span></span><br><span class=\"line\">\t<span class=\"comment\">// observations with the initiation count. Once they match, then the</span></span><br><span class=\"line\">\t<span class=\"comment\">// last observation on the now cool one has completed. All cold fields must</span></span><br><span class=\"line\">\t<span class=\"comment\">// be merged into the new hot before releasing writeMtx.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// Fields with atomic access first! See alignment constraint:</span></span><br><span class=\"line\">\t<span class=\"comment\">// http://golang.org/pkg/sync/atomic/#pkg-note-BUG</span></span><br><span class=\"line\">\tcountAndHotIdx <span class=\"type\">uint64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tselfCollector</span><br><span class=\"line\">\tdesc *Desc</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Only used in the Write method and for sparse bucket management.</span></span><br><span class=\"line\">\tmtx sync.Mutex</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Two counts, one is &quot;hot&quot; for lock-free observations, the other is</span></span><br><span class=\"line\">\t<span class=\"comment\">// &quot;cold&quot; for writing out a dto.Metric. It has to be an array of</span></span><br><span class=\"line\">\t<span class=\"comment\">// pointers to guarantee 64bit alignment of the histogramCounts, see</span></span><br><span class=\"line\">\t<span class=\"comment\">// http://golang.org/pkg/sync/atomic/#pkg-note-BUG.</span></span><br><span class=\"line\">\tcounts [<span class=\"number\">2</span>]*histogramCounts</span><br><span class=\"line\"></span><br><span class=\"line\">\tupperBounds                     []<span class=\"type\">float64</span></span><br><span class=\"line\">\tlabelPairs                      []*dto.LabelPair</span><br><span class=\"line\">\texemplars                       []atomic.Value <span class=\"comment\">// One more than buckets (to include +Inf), each a *dto.Exemplar.</span></span><br><span class=\"line\">\tnativeHistogramSchema           <span class=\"type\">int32</span>          <span class=\"comment\">// The initial schema. Set to math.MinInt32 if no sparse buckets are used.</span></span><br><span class=\"line\">\tnativeHistogramZeroThreshold    <span class=\"type\">float64</span>        <span class=\"comment\">// The initial zero threshold.</span></span><br><span class=\"line\">\tnativeHistogramMaxZeroThreshold <span class=\"type\">float64</span></span><br><span class=\"line\">\tnativeHistogramMaxBuckets       <span class=\"type\">uint32</span></span><br><span class=\"line\">\tnativeHistogramMinResetDuration time.Duration</span><br><span class=\"line\">\t<span class=\"comment\">// lastResetTime is protected by mtx. It is also used as created timestamp.</span></span><br><span class=\"line\">\tlastResetTime time.Time</span><br><span class=\"line\">\t<span class=\"comment\">// resetScheduled is protected by mtx. It is true if a reset is</span></span><br><span class=\"line\">\t<span class=\"comment\">// scheduled for a later time (when nativeHistogramMinResetDuration has</span></span><br><span class=\"line\">\t<span class=\"comment\">// passed).</span></span><br><span class=\"line\">\tresetScheduled  <span class=\"type\">bool</span></span><br><span class=\"line\">\tnativeExemplars nativeExemplars</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// now is for testing purposes, by default it&#x27;s time.Now.</span></span><br><span class=\"line\">\tnow <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> time.Time</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// afterFunc is for testing purposes, by default it&#x27;s time.AfterFunc.</span></span><br><span class=\"line\">\tafterFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(time.Duration, <span class=\"keyword\">func</span>()</span></span>) *time.Timer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将从它唯一的Observe函数入手，研究一下数据的存储方式。首先我们假定已经定义好了存储桶bucket，存储桶是一系列的用于分隔数据范围的浮点数，例如默认的存储桶为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DefBuckets = []<span class=\"type\">float64</span>&#123;<span class=\"number\">.005</span>, <span class=\"number\">.01</span>, <span class=\"number\">.025</span>, <span class=\"number\">.05</span>, <span class=\"number\">.1</span>, <span class=\"number\">.25</span>, <span class=\"number\">.5</span>, <span class=\"number\">1</span>, <span class=\"number\">2.5</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后观察Observe函数的实现，Observe函数接受唯一的float64类型输入，表示一个观测值，findBucket函数用于查找当前的观测值位于哪一个存储桶中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *histogram)</span></span> Observe(v <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\th.observe(v, h.findBucket(v))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取存储桶的序号之后，就会调用一个内部函数observe，该函数的实现如下，n是一个原子自增的计数器，后面的右移63位表示只根据最高位取出热桶(热桶只有两个，可以看上面的结构体定义中的counts字段)，然后调用该热桶的observe方法。doSparse是判断是否使用稀疏桶的布尔值，用于处理一些边界数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observe is the implementation for Observe without the findBucket part.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *histogram)</span></span> observe(v <span class=\"type\">float64</span>, bucket <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Do not add to sparse buckets for NaN observations.</span></span><br><span class=\"line\">\tdoSparse := h.nativeHistogramSchema &gt; math.MinInt32 &amp;&amp; !math.IsNaN(v)</span><br><span class=\"line\">\t<span class=\"comment\">// We increment h.countAndHotIdx so that the counter in the lower</span></span><br><span class=\"line\">\t<span class=\"comment\">// 63 bits gets incremented. At the same time, we get the new value</span></span><br><span class=\"line\">\t<span class=\"comment\">// back, which we can use to find the currently-hot counts.</span></span><br><span class=\"line\">\tn := atomic.AddUint64(&amp;h.countAndHotIdx, <span class=\"number\">1</span>)</span><br><span class=\"line\">\thotCounts := h.counts[n&gt;&gt;<span class=\"number\">63</span>]</span><br><span class=\"line\">\thotCounts.observe(v, bucket, doSparse)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> doSparse &#123;</span><br><span class=\"line\">\t\th.limitBuckets(hotCounts, v, bucket)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终的存储单位是histogramCounts的buckets，这个切片记录了每一个bucket区间内的数据总量。histogram并不保存原始数据，只关心数据的分布状况，因此会产生一定程度的信息丢失。如果在展示中出现的有关histogram的统计数值，一般是使用数学模型拟合出来的，与原始数据存在误差。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(hc *histogramCounts)</span></span> observe(v <span class=\"type\">float64</span>, bucket <span class=\"type\">int</span>, doSparse <span class=\"type\">bool</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bucket &lt; <span class=\"built_in\">len</span>(hc.buckets) &#123;</span><br><span class=\"line\">\t\tatomic.AddUint64(&amp;hc.buckets[bucket], <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tatomicAddFloat(&amp;hc.sumBits, v)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> doSparse &amp;&amp; !math.IsNaN(v) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 省略中间的稀疏桶处理逻辑</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Increment count last as we take it as a signal that the observation is complete.</span></span><br><span class=\"line\">\tatomic.AddUint64(&amp;hc.count, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一部分介绍了三种主要的Metric的设计，总的来说还是有许多值得参考学习的地方的。其他Metric和一些具体细节也可以自己到client_golang源码中查看。</p>\n<h2 id=\"TSDB与PromQL\"><a href=\"#TSDB与PromQL\" class=\"headerlink\" title=\"TSDB与PromQL\"></a>TSDB与PromQL</h2><p>Prometheus有一个专用的时间序列数据库，位于prometheus&#x2F;tsdb目录下，此外，他还提供了一种针对这个时序数据库的查询语言，称为PromQL，位于prometheus&#x2F;promql目录下。由于上一部分中已经介绍过了InfluxDB，并且这两部分的源代码比较复杂，这里就简单介绍一下TSDB和PromQL的特性和功能。</p>\n<p>在TSDB中，时间序列中的每一个点称为一个样本（sample），样本由以下三部分组成:</p>\n<ul>\n<li>指标(metric)：metric name和描述当前样本特征的labelsets;</li>\n<li>时间戳(timestamp)：毫秒级时间戳;</li>\n<li>样本值(value)： 一个float64的浮点型数据表示当前样本的值。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;</span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;200&quot;</span>, method=<span class=\"string\">&quot;GET&quot;</span>&#125;@<span class=\"number\">1434417560938</span> =&gt; <span class=\"number\">94355</span></span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;200&quot;</span>, method=<span class=\"string\">&quot;GET&quot;</span>&#125;@<span class=\"number\">1434417561287</span> =&gt; <span class=\"number\">94334</span></span><br><span class=\"line\"></span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;404&quot;</span>, method=<span class=\"string\">&quot;GET&quot;</span>&#125;@<span class=\"number\">1434417560938</span> =&gt; <span class=\"number\">38473</span></span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;404&quot;</span>, method=<span class=\"string\">&quot;GET&quot;</span>&#125;@<span class=\"number\">1434417561287</span> =&gt; <span class=\"number\">38544</span></span><br><span class=\"line\"></span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;200&quot;</span>, method=<span class=\"string\">&quot;POST&quot;</span>&#125;@<span class=\"number\">1434417560938</span> =&gt; <span class=\"number\">4748</span></span><br><span class=\"line\">http_request_total&#123;status=<span class=\"string\">&quot;200&quot;</span>, method=<span class=\"string\">&quot;POST&quot;</span>&#125;@<span class=\"number\">1434417561287</span> =&gt; <span class=\"number\">4785</span></span><br></pre></td></tr></table></figure>\n\n<p>由于prometheus的TSDB是专门为它自己服务的，所以整体设计上会比InfluxDB要简单一些。它使用了Metric代替InfluxDB的measurement的概念，原生支持记录Metric的时间序列记录，减少了自己转换结构和设计数据字段的工作。</p>\n<p>当数据存入TSDB之后，就可以使用PromQL查询某个Metric数据。这里有两个关键的概念：</p>\n<ul>\n<li>Engine: 负责管理多次查询的整个生命周期，可以配置超时时间、日志等。</li>\n<li>Query: 是一个接口，负责管理一次查询，包括查询语句、执行、取消、关闭等操作。</li>\n</ul>\n<p>本质上，PromQL(Prometheus Query Language)就是一个针对TSDB的QL，其功能和用法都类似SQL，一般而言在搭建可视化平台的时候就写好的，后期改动较少，这里就不加赘述了。</p>\n<h1 id=\"架构差异与功能比较\"><a href=\"#架构差异与功能比较\" class=\"headerlink\" title=\"架构差异与功能比较\"></a>架构差异与功能比较</h1><p>上文介绍了两个监控系统：PiMonitor和Prometheus，两者的架构设计最大的区别在于是否有单独Agent代理，这个区别导致了某些场景下两个监控系统有不同的表现：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>PiMonitor</th>\n<th>Prometheus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机信息采集</td>\n<td>原生支持采集计算机基本信息和资源利用率</td>\n<td>需要启动额外的Exporter</td>\n</tr>\n<tr>\n<td>服务与框架集成</td>\n<td>需要在服务中手动指定所有监控指标</td>\n<td>许多服务和框架都预留了Prometheus监控集成功能</td>\n</tr>\n<tr>\n<td>信息传输方式</td>\n<td>仅支持通过Agent上传的push模式</td>\n<td>以pull模式为主，push模式为辅</td>\n</tr>\n<tr>\n<td>新增服务</td>\n<td>可以监控所有使用pimetric模块的服务，启动后无需额外操作</td>\n<td>每次增加新服务都需要修改服务端拉取目标的配置文件</td>\n</tr>\n</tbody></table>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文由浅入深，从自己的监控系统入手，讲述了监控系统的基本组成部分和数据流向，让读者对于监控系统的工作原理有了基本的认识。然后研究了社区最活跃的监控系统Prometheus，学习其架构设计和底层实现，尽管只研究了冰山一角，但也让人获益匪浅。</p>\n<p>本文也有一定的局限性，由于Prometheus是一个以Metric为核心的监控系统，对于日志(Log)、调用链(Trace)的支持不佳，难以打造一个全方位的监控系统，这篇文章也因此缺少了这两部分可观测对象监控的工作原理。</p>\n<p>感谢大家的阅读，如有错误，欢迎指出。</p>\n<blockquote>\n<p>参考资料</p>\n<p>Prometheus官方文档：<a href=\"https://prometheus.io/docs/introduction/overview/\">https://prometheus.io/docs/introduction/overview/</a></p>\n<p>InfluxDB中文文档：<a href=\"https://jasper-zhang1.gitbooks.io/influxdb/content/\">https://jasper-zhang1.gitbooks.io/influxdb/content/</a></p>\n<p>技术文章：</p>\n<ul>\n<li><p>exemplar：<a href=\"https://segmentfault.com/a/1190000043394360\">https://segmentfault.com/a/1190000043394360</a></p>\n</li>\n<li><p>监控系统选型：<a href=\"https://www.cnblogs.com/qdhxhz/p/16289758.html\">https://www.cnblogs.com/qdhxhz/p/16289758.html</a></p>\n</li>\n<li><p>histogram：<a href=\"https://juejin.cn/post/7152837166190739486\">https://juejin.cn/post/7152837166190739486</a></p>\n</li>\n</ul>\n</blockquote>\n","categories":[{"name":"Exp","slug":"Exp","permalink":"https://veni222987.github.io/categories/Exp/"}],"tags":[{"name":"监控系统","slug":"监控系统","permalink":"https://veni222987.github.io/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://veni222987.github.io/tags/Prometheus/"}]},{"title":"【Exp】深入理解Go语言函数与方法","date":"2024-04-11T05:24:42.000Z","path":"2024/04/11/【Exp】深入理解Go语言函数与方法/","text":"函数Go语言的函数有四个组成部分：函数名、形参列表、返回值列表、函数体。一个最标准的函数形式如下： 123func twoSum(x, y int) int &#123; return x + y&#125; 函数的前三个组成部分构成了函数的签名，可以使用如下方式查看签名，其中%T是Go语言的占位符，用于打印变量的类型。 1234f := twoSumfmt.Printf(&quot;%T\\n&quot;, f)// 输出结果：// func(int, int) int 函数在Go语言中也是一种数据类型，具有地址。可以通过函数名或者&amp;运算符来获取函数的地址，并将其赋值给函数类型的变量。这使得在Go语言中可以像操作其他类型一样操作函数，例如将函数作为参数传递给其他函数或存储函数的地址。所以，可以使用函数作为参数传递实现回调函数，也可以将返回值设置为函数实现闭包，后面会详细讲。在我看来，函数可以理解成为一个特殊的引用数据类型，其零值为nil，可以取址、可以作为赋值符号的右操作数。 接下来文章将按照函数的四个组成部分逐步深入理解函数。 形参参数列表可以简写，例如： 1func twoSum(x int, y int) int &#123;&#125; 可以简写成为： 1func twoSum(x, y int) int &#123;&#125; 但是省略的条件是同一类型的形参放在一块。注意形参都是有序的，Go语言没有参数默认值，在传递实参的时候，必须严格按照形参列表顺序传递。所以，在开发中需要注意入参顺序，写好函数注释。有人会说，没有默认参数值多不方便啊，如果一个函数有十几个参数，没有默认参数怎么办呢？这就是工程架构设计的问题了，需要拆分接口，分步实现，或者采用结构体等形式实现默认操作。 可变参数可变参数是通过在参数类型前加上省略符...来定义的。这表示该参数可以接受零个或多个值，这些值将被作为切片（slice）传递给函数。 123456func sumOfAll(nums ...int) (res int) &#123; for _, value := range nums &#123; res += value &#125; return&#125; 可变参数在一个函数里面只能使用一次，并且必须放在参数列表的最后一个位置。如果使用两次或者不将其放在最后一个位置（其实使用两个可变参数就必然会导致其中一个可变参数不位于最后一个位置），将会无法通过编译：Can only use &#39;...&#39; as the final argument in the list。 函数的参数传递对于Go而言，函数的参数传递方式只有值传递。这对于熟悉Java的人来说比较难以理解，因为对他们而言引用传递可能更深入人心。其实除了基本数据类型以外，函数传递的都是该变量在内存中的地址值，当程序访问变量的时候，都是通过地址访问的，也就是说，引用类型在修改数据的时候都是间接修改了内存中的值，从而使得修改对于所有其他的引用都是可见的。”Go语言圣经“原话是这么说的： Arguments are passed by value, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affec ted by any modifications the function makes to variables indirectly referred to by the argument. 回调函数回调函数是一种编程模式，其中一个函数作为参数传递给另一个函数，并且在特定的事件发生或条件满足时被调用。下面的函数展示了Go语言的回调函数的使用方法，其中passingFunc接受一个func(int) int类型的回调函数，然后传入一个numDouble函数将data数据翻倍，最后在主函数调用。 1234567891011121314151617func passingFunc(data []int, callback func(int) int) &#123; for _, d := range data &#123; fmt.Println(callback(d)) &#125;&#125;func numDouble(num int) int &#123; return num * 2&#125;func main() &#123; data := make([]int, 5) for i, _ := range data &#123; data[i] = i &#125; passingFunc(data, numDouble)&#125; 上述代码输出结果为：0 2 4 6 8 。（空格为换行，为省略空间表示为这种形式）。 函数名Go不允许函数重载，也就是说，函数名是一个函数的唯一标识，不存在同一个函数名不同参数的情况（C++、Java都有）。 省略函数名——匿名函数12345678910111213141516func main() &#123; // 定义一个匿名函数并立即调用 result := func(a, b int) int &#123; return a + b &#125;(3, 4) fmt.Println(&quot;结果:&quot;, result) // 将匿名函数赋值给变量 subtract := func(a, b int) int &#123; return a - b &#125; result = subtract(10, 5) fmt.Println(&quot;结果:&quot;, result)&#125; 使用匿名函数作为参数传递给回调函数会使得代码更加简洁，例如上面回调函数的示例代码中，可以不用定义numDouble函数，而是直接将其作为匿名函数传入。 123passingFunc(data, func(num int) int &#123; return num * 2&#125;) 匿名函数与作用域匿名函数可以获取作用域外的变量，使用的方法是直接在函数体内声明并使用该匿名函数，例如： 12345678x := 10func() &#123; fmt.Println(&quot;x的值为:&quot;, x) x += 5 fmt.Println(&quot;修改后:&quot;, x)&#125;()fmt.Println(&quot;匿名函数执行后:&quot;, x)//执行结果（省略版）： 10 15 15 也可以将匿名函数赋值给一个变量让其多次调用，这里就不举例了。从上述代码看可以看到，匿名函数可以在函数体内部调用，并且在函数作用域内的变量都可以被该匿名函数访问和修改。当返回值为函数时，这种作用域将会被保留称为闭包的引用环境。 匿名函数与闭包有这么一个对闭包的总结： 闭包&#x3D;函数+引用环境。因此闭包的核心就是：函数和引用环境。[Go语言基础知识 —— Closure(闭包)]: https://zhuanlan.zhihu.com/p/645853924 下面先看一段代码： 12345678910111213141516func newCounter() func() int &#123; count := 0 return func() int &#123; count++ return count &#125;&#125;func main() &#123; f := newCounter() fmt.Println(f()) //1 fmt.Println(f()) //2 f1 := newCounter() fmt.Println(f1()) //1 fmt.Println(f1()) //2&#125; 一开始看到可能会觉得很抽象，但是没关系，接下来会慢慢讲解。首先观察newCounter这个函数的返回值是一个函数类型，意味着什么呢？意味着这段代码使用newCounter创建了一个函数。观察函数体内，可以发现，返回的是一个匿名函数并没有包含count变量。那为什么多次调用count会实现自增功能呢？那是因为在创建函数的时候用到了count，所以每一次执行newCount都会创建一个count的副本和一个匿名函数，实现了将这个匿名函数绑定到当时环境的功能，而被创建出来的函数，就是一个闭包。 所以，再回顾一下上面那句话：闭包&#x3D;函数+引用环境。闭包其实就是一个特殊函数，他可以捕获函数内部变量和参数，并将它们与函数创建的环境绑定在一起。 返回值函数的单返回值就不多说了，下面重点讲讲多返回值。多返回值常常结合错误处理使用，一般而言，函数的第一个返回值是函数本身具有实际意义的返回结果，最后一个返回值通常是错误，错误的类型往往是error。一般设计上，Go语言的多返回值都是两个，但是Go本身支持两个以上的返回值，例如整数除法就可以同时返回商、余数、近似值等。 error是Go语言内置的类型，以字符串的形式简要报告了错误，提供了灵活的处理方式。 命名返回值的return带操作数会被覆盖吗当我们在return语句中显式指定了返回值时，它将覆盖函数体中的命名返回值，举个例子： 123456789101112func plus2(x int) (res int) &#123; res = x defer func() &#123; res++ &#125;() return res * 2 /* 等价于 res = res * 2 return */&#125; 上面的函数中，我们在参数列表预定义了返回结果，按理来说只需要写return就好，后面不需要跟任何操作数。但是如果写了操作数的话就相当于对操作数进行了一次赋值，也就是用后来的结果覆盖了原结果。 实际上，return语句并不是原子操作，它执行的逻辑是：保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数。 函数体延迟函数调用与defer语句defer是一个功能强大的关键字，表示延迟函数调用。从使用形式上看 ，defer就是一个普通的函数或方法调用，注意defer必须跟一个函数或方法调用，如果不是，那么请将其改为匿名函数形式。它将defer后面的代码执行完毕之后再执行defer语句，无论是后面的代码会return还是宕机。当然，如果陷入了死循环是无法执行defer后面的代码的。defer一般用于一对操作，例如打开和关闭文件、加锁和释放锁等等。当同一个函数里面有多个defer的时候，按照栈的顺序执行，即先进后出。使用方法如下： 1234567var mu sync.Mutexvar m = make(map[string]int)func lookup(key string) int &#123; mu.Lock() defer mu.Unlock() return m[key]&#125; 上述代码使用defer实现了加锁和释放锁，从而保证了对map的互斥访问。 在defer后面修改返回值会怎样还记得上面说过的return语句执行顺序吗？保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数。这个就决定了defer语句是否影响返回值。所以结果就是：defer语句会修改指针类型和命名返回值的返回结果，而不会影响匿名返回值的结果。从实现原理来看，匿名返回值在保存返回变量的阶段就已经被保存下来了，后面的操作都会被忽略。 12345678910111213141516171819202122232425262728293031func plus(x int) int &#123; defer func() &#123; x++ &#125;() return x * 2&#125;func plus2(x int) (res int) &#123; res = x defer func() &#123; res++ &#125;() return res * 2&#125;func plus3(x *int) *int &#123; defer func() &#123; *x++ &#125;() *x = *x * 2 return x&#125;func main() &#123; x := 1 fmt.Println(plus(x)) fmt.Println(plus2(x)) fmt.Println(*plus3(&amp;x))&#125;//输出结果：2 3 3 宕机与恢复如何使用之所以把它放在函数体这一部分，是因为Go的程序就是由函数组成的，其最外层入口就是main函数，程序的宕机是由函数的宕机造成的。panic和其他语言的运行时异常有点相似，如果不加以处理 ，最终都会导致程序终止执行。在发生panic之后，程序会终止执行，然后运行所有的defer函数，最后在程序退出之前打印调用堆栈。 panic除了由函数在运行时造成以外，还可以自己生成，因为panic本身就是一个函数，函数原型为：func panic(v any)。其中any代表了panic可以传入任何类型的参数，但是要求能够描述panic的原因，所以一般情况下使用string类参数。自己抛出panic的demo如下： 12345func doSomething() &#123; // ......业务代码 // 产生panic panic(&quot;发生了错误：输入条件无意义&quot;)&#125; 当然，除了把panic直接抛出以外，还可以从panic中恢复(recover)，并且recover必须放在defer中才有意义，例如： 12345678910111213141516func recoverFromPanic() &#123; if r := recover(); r != nil &#123; fmt.Println(&quot;捕获到panic:&quot;, r) &#125;&#125;func doSomething() &#123; defer recoverFromPanic() // 产生panic panic(&quot;发生了错误：&quot;)&#125;func main() &#123; doSomething() fmt.Println(&quot;程序继续执行&quot;)&#125; recover就相当于异常处理机制的catch语句，recover可以捕获内层函数没有recover的panic。一个合理的做法是将部分可预见的panic封装称为error向上返回，使其不影响程序的执行。但是必须做好错误提醒，因为一旦将panic封装为error之后，将会默认隐藏调用堆栈，从而加大debug难度。 方法和函数一样，我们可以把Go语言的方法拆分成五个组成部分：接收者、方法名、形参列表、返回值列表、方法体。方法比函数多了一个接收者，有点类似传统OOP语言的成员函数，声明的时候放在方法名前面，例如： 123456789101112type Point struct &#123; X, Y float64&#125;func (p Point) distanceTo(q Point) float64 &#123; return math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))&#125;func main() &#123; p := Point&#123;1, 2&#125; fmt.Printf(&quot;%.2f&quot;, p.distanceTo(Point&#123;2, 3&#125;))&#125; Go要求自定义接收名，例如p Point，在Go中不使用类似this或者self这种隐式指针或者引用，但可以自己将其命名称为类似的名字，推荐命名尽量简短，因为方法可能需要频繁操作自身变量，推荐使用该类型的首字母小写。 方法名和成员变量名冲突吗Go的方法和类型成员同在一个命名空间内，所以不能起和成员变量一样的方法名，例如，我们在上述代码段中尝试加入一个名称为X的方法，编译器将会报错： 但是包级别函数名和方法名不冲突，也就是说，可以同时声明func (a TypeA) A()&#123;&#125;和func A()&#123;&#125;。 哪些类型可以声明方法我们可以为同一个包内基本数据类型和引用类型声明方法，指针类型和接口类型无法增加方法。例如： 123456789101112131415161718192021222324252627// 基本类型增加方法type age intfunc (a age) olderThan(b age) bool &#123; return a &gt; b&#125;// 引用类型增加方法type myPoint []float64func (p myPoint) distanceTo(q myPoint) float64 &#123; return math.Sqrt((p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1]))&#125;// 接口类型无法定义方法，（error是内置的接口类型）以下代码将会无法编译：/*type myError errorfunc (e myError) function()&#123;&#125;*/// 同理，指针类型也无法定义方法：下面的代码会报错/*type pInt *intfunc (p pInt) function()&#123; &#125;*/ 指针接收者方法接收者分为值接收者和指针接收者两种。指针接收者方法就是把所属类型的接收对象改为指针的形式，例如，我们为Point类创建指针接收者方法可以写成这样： 123func (p *Point) distance2(q *Point) float64 &#123; // ......&#125; 也就是把方法绑定的变量改成了该类型的指针形式。如果直接在原来的基础上增加一个指针接收者方法，那编译器将会出现提醒：Struct Point has methods on both value and pointer receivers. Such usage is not recommended by the Go Documentation. 也就是说不推荐同时存在两种接收者。所以，一旦该类型有一个指针接收者方法，那么其余所有方法都应该使用指针作为接收者。 由于指针接收者的存在，所以Go语言不允许指针类型定义方法，防止混淆，因为编译器会对两种接收者进行隐式转换，见下面的代码。 12345678910111213141516171819202122232425262728293031323334353637// 值接收者类型type Point struct &#123; X, Y float64&#125;func (p Point) distanceTo(q Point) float64 &#123; return math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))&#125;// 指针接收者类型type Point2 struct &#123; X, Y float64&#125;func (p *Point2) scaleBy(size float64) &#123; p.X, p.Y = size*p.X, size*p.Y&#125;func (p *Point2) distanceTo(q *Point2) float64 &#123; return math.Sqrt(((*p).X-(*q).X)*((*p).X-(*q).X) + (p.Y-q.Y)*(p.Y-q.Y))&#125;// 自动隐式转换示例，看起来可能有点绕，但是记住这个例子是为了证明方法接收者会进行隐式转换，从而不允许为指针定义方法func main() &#123; p := Point&#123;1, 2&#125; // 变量值 fmt.Printf(&quot;%.2f\\n&quot;, p.distanceTo(Point&#123;2, 3&#125;)) fmt.Printf(&quot;%.2f\\n&quot;, (&amp;p).distanceTo(Point&#123;2, 3&#125;)) p2 := &amp;Point2&#123;1, 2&#125; // 变量指针 p2.scaleBy(2) // 直接调用 fmt.Printf(&quot;%.2f\\n&quot;, p2.distanceTo(&amp;Point2&#123;0, 0&#125;)) fmt.Printf(&quot;%.2f\\n&quot;, (*p2).distanceTo(&amp;Point2&#123;0, 0&#125;)) (*p2).scaleBy(0.5) // 类型转换后调用 fmt.Printf(&quot;%.2f\\n&quot;, p2.distanceTo(&amp;Point2&#123;0, 0&#125;)) fmt.Printf(&quot;%.2f\\n&quot;, (*p2).distanceTo(&amp;Point2&#123;0, 0&#125;))&#125; nil也是一个合法的接收者 对于常见的OOP语言而言，空指针null是无法调用任何成员函数的。但是在Go中，nil是一个合法的接收者，当调用者的值为nil的时候，也可以有对应操作： 123456func (p *Point2) length() float64 &#123; if p==nil &#123; return 0 &#125; return p.X*p.X+p.Y*p.Y&#125; 在这种情况下，即使使用一个*Point2类型的空指针作为接收者，也可以调用length，返回长度为0。 方法变量可以将一个结构体的方法转换成为普通函数使用 和函数变量类似，方法变量也是将某一个方法赋值到变量中，后面使用变量调用这个方法，可以直接像函数一样使用，但是使用较少，此处就省略了。 总结本文主要讲述了Go中的函数和方法的使用要点和注意事项，以实验的方法验证了部分特性。函数和方法是Go中最重要的两个概念。Go不是传统意义上的OOP语言，它通常通过包级别来实现封装功能，而包内使用函数式编程，并对外提供服务。总而言之，用好函数和方法是用好Go的关键。","content":"<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>Go语言的函数有四个组成部分：函数名、形参列表、返回值列表、函数体。一个最标准的函数形式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数的前三个组成部分构成了函数的签名，可以使用如下方式查看签名，其中%T是Go语言的占位符，用于打印变量的类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f := twoSum</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%T\\n&quot;</span>, f)</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">// func(int, int) int</span></span><br></pre></td></tr></table></figure>\n\n<p>函数在Go语言中也是一种数据类型，具有地址。可以通过函数名或者<code>&amp;</code>运算符来获取函数的地址，并将其赋值给函数类型的变量。这使得在Go语言中可以像操作其他类型一样操作函数，例如将函数作为参数传递给其他函数或存储函数的地址。所以，可以使用函数作为参数传递实现回调函数，也可以将返回值设置为函数实现闭包，后面会详细讲。在我看来，函数可以<strong>理解成为一个特殊的引用数据类型</strong>，其零值为<code>nil</code>，可以取址、可以作为赋值符号的右操作数。</p>\n<p>接下来文章将按照函数的四个组成部分逐步深入理解函数。</p>\n<h2 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h2><p>参数列表可以简写，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以简写成为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是省略的条件是同一类型的形参放在一块。注意形参都是<strong>有序的</strong>，Go语言<strong>没有参数默认值</strong>，在传递实参的时候，必须严格按照形参列表顺序传递。所以，在开发中需要注意入参顺序，写好函数注释。有人会说，没有默认参数值多不方便啊，如果一个函数有十几个参数，没有默认参数怎么办呢？这就是工程架构设计的问题了，需要拆分接口，分步实现，或者采用结构体等形式实现默认操作。</p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>可变参数是通过在参数类型前加上省略符<code>...</code>来定义的。这表示该参数可以接受零个或多个值，这些值将被作为<strong>切片（slice）</strong>传递给函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sumOfAll</span><span class=\"params\">(nums ...<span class=\"type\">int</span>)</span></span> (res <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, value := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\tres += value</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可变参数在一个函数里面只能使用一次，并且必须放在参数列表的最后一个位置。如果使用两次或者不将其放在最后一个位置（其实使用两个可变参数就必然会导致其中一个可变参数不位于最后一个位置），将会无法通过编译：<code>Can only use &#39;...&#39; as the final argument in the list</code>。</p>\n<h3 id=\"函数的参数传递\"><a href=\"#函数的参数传递\" class=\"headerlink\" title=\"函数的参数传递\"></a>函数的参数传递</h3><p>对于Go而言，函数的参数传递方式只有值传递。这对于熟悉Java的人来说比较难以理解，因为对他们而言引用传递可能更深入人心。其实除了基本数据类型以外，函数传递的都是该变量在内存中的地址值，当程序访问变量的时候，都是通过地址访问的，也就是说，引用类型在修改数据的时候都是间接修改了内存中的值，从而使得修改对于所有其他的引用都是可见的。”Go语言圣经“原话是这么说的：</p>\n<blockquote>\n<p>Arguments are passed by value, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affec ted by any modifications the function makes to variables indirectly referred to by the argument.</p>\n</blockquote>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>回调函数是一种编程模式，其中一个<strong>函数作为参数传递给另一个函数</strong>，并且在<strong>特定的事件发生或条件满足时被调用</strong>。下面的函数展示了Go语言的回调函数的使用方法，其中<code>passingFunc</code>接受一个<code>func(int) int</code>类型的回调函数，然后传入一个numDouble函数将data数据翻倍，最后在主函数调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">passingFunc</span><span class=\"params\">(data []<span class=\"type\">int</span>, callback <span class=\"keyword\">func</span>(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, d := <span class=\"keyword\">range</span> data &#123;</span><br><span class=\"line\">       fmt.Println(callback(d))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numDouble</span><span class=\"params\">(num <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdata := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, _ := <span class=\"keyword\">range</span> data &#123;</span><br><span class=\"line\">\t\tdata[i] = i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpassingFunc(data, numDouble)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码输出结果为：<code>0 2 4 6 8</code> 。（空格为换行，为省略空间表示为这种形式）。</p>\n<h2 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h2><p>Go不允许函数重载，也就是说，函数名是一个函数的唯一标识，不存在同一个函数名不同参数的情况（C++、Java都有）。</p>\n<h3 id=\"省略函数名——匿名函数\"><a href=\"#省略函数名——匿名函数\" class=\"headerlink\" title=\"省略函数名——匿名函数\"></a>省略函数名——匿名函数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个匿名函数并立即调用</span></span><br><span class=\"line\">    result := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    &#125;(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;结果:&quot;</span>, result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将匿名函数赋值给变量</span></span><br><span class=\"line\">    subtract := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    result = subtract(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;结果:&quot;</span>, result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用匿名函数作为参数传递给回调函数会使得代码更加简洁，例如上面回调函数的示例代码中，可以不用定义numDouble函数，而是直接将其作为匿名函数传入。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passingFunc(data, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(num <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"匿名函数与作用域\"><a href=\"#匿名函数与作用域\" class=\"headerlink\" title=\"匿名函数与作用域\"></a>匿名函数与作用域</h3><p>匿名函数可以获取作用域外的变量，使用的方法是直接在函数体内声明并使用该匿名函数，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;x的值为:&quot;</span>, x)</span><br><span class=\"line\">    x += <span class=\"number\">5</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;修改后:&quot;</span>, x)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;匿名函数执行后:&quot;</span>, x)</span><br><span class=\"line\"><span class=\"comment\">//执行结果（省略版）： 10 15 15</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以将匿名函数赋值给一个变量让其多次调用，这里就不举例了。从上述代码看可以看到，匿名函数可以在函数体内部调用，并且在函数作用域内的变量都可以被该匿名函数访问和修改。当返回值为函数时，这种作用域将会被保留称为闭包的引用环境。</p>\n<h3 id=\"匿名函数与闭包\"><a href=\"#匿名函数与闭包\" class=\"headerlink\" title=\"匿名函数与闭包\"></a>匿名函数与闭包</h3><p>有这么一个对闭包的总结： <strong>闭包&#x3D;函数+引用环境</strong>。因此闭包的核心就是：<strong>函数</strong>和<strong>引用环境</strong>。<br>[Go语言基础知识 —— Closure(闭包)]: <a href=\"https://zhuanlan.zhihu.com/p/645853924\">https://zhuanlan.zhihu.com/p/645853924</a></p>\n<p>下面先看一段代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCounter</span><span class=\"params\">()</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    count := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">       count++</span><br><span class=\"line\">       <span class=\"keyword\">return</span> count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    f := newCounter()</span><br><span class=\"line\">    fmt.Println(f()) <span class=\"comment\">//1</span></span><br><span class=\"line\">    fmt.Println(f()) <span class=\"comment\">//2</span></span><br><span class=\"line\">    f1 := newCounter()</span><br><span class=\"line\">    fmt.Println(f1()) <span class=\"comment\">//1</span></span><br><span class=\"line\">    fmt.Println(f1()) <span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一开始看到可能会觉得很抽象，但是没关系，接下来会慢慢讲解。首先观察newCounter这个函数的返回值是一个函数类型，意味着什么呢？意味着这段代码使用newCounter创建了一个函数。观察函数体内，可以发现，返回的是一个匿名函数并没有包含count变量。那为什么多次调用count会实现自增功能呢？那是因为在创建函数的时候用到了count，所以每一次执行newCount都会创建一个count的副本和一个匿名函数，实现了将这个匿名函数绑定到当时环境的功能，而被创建出来的函数，就是一个闭包。</p>\n<p>所以，再回顾一下上面那句话：<strong>闭包&#x3D;函数+引用环境</strong>。闭包其实就是一个特殊函数，他可以捕获函数内部变量和参数，并将它们与函数创建的环境绑定在一起。</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>函数的单返回值就不多说了，下面重点讲讲多返回值。多返回值常常结合错误处理使用，一般而言，函数的第一个返回值是函数本身具有实际意义的返回结果，最后一个返回值通常是错误，错误的类型往往是error。一般设计上，Go语言的多返回值都是两个，但是Go本身支持两个以上的返回值，例如整数除法就可以同时返回商、余数、近似值等。</p>\n<blockquote>\n<p>error是Go语言内置的类型，以字符串的形式简要报告了错误，提供了灵活的处理方式。</p>\n</blockquote>\n<h3 id=\"命名返回值的return带操作数会被覆盖吗\"><a href=\"#命名返回值的return带操作数会被覆盖吗\" class=\"headerlink\" title=\"命名返回值的return带操作数会被覆盖吗\"></a>命名返回值的return带操作数会被覆盖吗</h3><p>当我们在return语句中显式指定了返回值时，它将覆盖函数体中的命名返回值，举个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">plus2</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> (res <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    res = x</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">       res++</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       等价于</span></span><br><span class=\"line\"><span class=\"comment\">       res = res * 2</span></span><br><span class=\"line\"><span class=\"comment\">       return</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的函数中，我们在参数列表预定义了返回结果，按理来说只需要写<code>return</code>就好，后面不需要跟任何操作数。但是如果写了操作数的话就相当于对操作数进行了一次赋值，也就是用后来的结果覆盖了原结果。</p>\n<p>实际上，return语句并不是原子操作，它执行的逻辑是：<strong>保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数</strong>。</p>\n<h2 id=\"函数体\"><a href=\"#函数体\" class=\"headerlink\" title=\"函数体\"></a>函数体</h2><h3 id=\"延迟函数调用与defer语句\"><a href=\"#延迟函数调用与defer语句\" class=\"headerlink\" title=\"延迟函数调用与defer语句\"></a>延迟函数调用与defer语句</h3><p>defer是一个功能强大的关键字，表示延迟函数调用。从使用形式上看 ，defer就是一个普通的函数或方法调用，注意defer必须跟一个函数或方法调用，如果不是，那么请将其改为匿名函数形式。它将defer后面的代码执行完毕之后再执行defer语句，无论是后面的代码会return还是宕机。当然，如果陷入了死循环是无法执行defer后面的代码的。defer一般用于一对操作，例如打开和关闭文件、加锁和释放锁等等。当同一个函数里面有多个defer的时候，按照栈的顺序执行，即先进后出。使用方法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lookup</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[key]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码使用defer实现了加锁和释放锁，从而保证了对map的互斥访问。</p>\n<h3 id=\"在defer后面修改返回值会怎样\"><a href=\"#在defer后面修改返回值会怎样\" class=\"headerlink\" title=\"在defer后面修改返回值会怎样\"></a>在defer后面修改返回值会怎样</h3><p>还记得上面说过的return语句执行顺序吗？<strong>保存返回变量-&gt;执行defer语句-&gt;执行ret返回调用函数</strong>。这个就决定了defer语句是否影响返回值。所以结果就是：<strong>defer语句会修改指针类型和命名返回值的返回结果，而不会影响匿名返回值的结果</strong>。从实现原理来看，匿名返回值在保存返回变量的阶段就已经被保存下来了，后面的操作都会被忽略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">plus</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">       x++</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">plus2</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> (res <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    res = x</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">       res++</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">plus3</span><span class=\"params\">(x *<span class=\"type\">int</span>)</span></span> *<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">       *x++</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    *x = *x * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    x := <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Println(plus(x))</span><br><span class=\"line\">    fmt.Println(plus2(x))</span><br><span class=\"line\">    fmt.Println(*plus3(&amp;x))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出结果：2 3 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"宕机与恢复如何使用\"><a href=\"#宕机与恢复如何使用\" class=\"headerlink\" title=\"宕机与恢复如何使用\"></a>宕机与恢复如何使用</h3><p>之所以把它放在函数体这一部分，是因为Go的程序就是由函数组成的，其最外层入口就是main函数，程序的宕机是由函数的宕机造成的。panic和其他语言的运行时异常有点相似，如果不加以处理 ，最终都会导致程序终止执行。在发生panic之后，程序会终止执行，然后运行所有的defer函数，最后在程序退出之前打印调用堆栈。</p>\n<p>panic除了由函数在运行时造成以外，还可以自己生成，因为panic本身就是一个函数，函数原型为：<code>func panic(v any)</code>。其中any代表了panic可以传入任何类型的参数，但是要求能够描述panic的原因，所以一般情况下使用string类参数。自己抛出panic的demo如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ......业务代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 产生panic</span></span><br><span class=\"line\">  <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;发生了错误：输入条件无意义&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，除了把panic直接抛出以外，还可以从panic中恢复(recover)，并且recover必须放在defer中才有意义，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverFromPanic</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">       fmt.Println(<span class=\"string\">&quot;捕获到panic:&quot;</span>, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> recoverFromPanic()</span><br><span class=\"line\">    <span class=\"comment\">// 产生panic</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;发生了错误：&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    doSomething()</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;程序继续执行&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>recover就相当于异常处理机制的catch语句，recover可以捕获内层函数没有recover的panic。一个合理的做法是将部分可预见的panic封装称为error向上返回，使其不影响程序的执行。但是必须做好错误提醒，因为一旦将panic封装为error之后，将会默认隐藏调用堆栈，从而加大debug难度。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>和函数一样，我们可以把Go语言的方法拆分成五个组成部分：接收者、方法名、形参列表、返回值列表、方法体。方法比函数多了一个接收者，有点类似传统OOP语言的成员函数，声明的时候放在方法名前面，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> distanceTo(q Point) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%.2f&quot;</span>, p.distanceTo(Point&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go要求自定义接收名，例如<code>p Point</code>，在Go中不使用类似this或者self这种隐式指针或者引用，但可以自己将其命名称为类似的名字，推荐命名尽量简短，因为方法可能需要频繁操作自身变量，推荐使用该类型的首字母小写。</p>\n<h2 id=\"方法名和成员变量名冲突吗\"><a href=\"#方法名和成员变量名冲突吗\" class=\"headerlink\" title=\"方法名和成员变量名冲突吗\"></a>方法名和成员变量名冲突吗</h2><p>Go的方法和类型成员同在一个命名空间内，所以不能起和成员变量一样的方法名，例如，我们在上述代码段中尝试加入一个名称为X的方法，编译器将会报错：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240414172852308.png\" alt=\"image-20240414172852308\"></p>\n<p>但是包级别函数名和方法名不冲突，也就是说，可以同时声明<code>func (a TypeA) A()&#123;&#125;</code>和<code>func A()&#123;&#125;</code>。</p>\n<h2 id=\"哪些类型可以声明方法\"><a href=\"#哪些类型可以声明方法\" class=\"headerlink\" title=\"哪些类型可以声明方法\"></a>哪些类型可以声明方法</h2><p>我们可以为<strong>同一个包</strong>内<strong>基本数据类型和引用类型声明方法</strong>，指针类型和接口类型无法增加方法。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型增加方法</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> age <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a age)</span></span> olderThan(b age) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用类型增加方法</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> myPoint []<span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p myPoint)</span></span> distanceTo(q myPoint) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt((p[<span class=\"number\">0</span>]-q[<span class=\"number\">0</span>])*(p[<span class=\"number\">0</span>]-q[<span class=\"number\">0</span>]) + (p[<span class=\"number\">1</span>]-q[<span class=\"number\">1</span>])*(p[<span class=\"number\">1</span>]-q[<span class=\"number\">1</span>]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口类型无法定义方法，（error是内置的接口类型）以下代码将会无法编译：</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type myError error</span></span><br><span class=\"line\"><span class=\"comment\">func (e myError) function()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同理，指针类型也无法定义方法：下面的代码会报错</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type pInt *int</span></span><br><span class=\"line\"><span class=\"comment\">func (p pInt) function()&#123;\t</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指针接收者方法\"><a href=\"#指针接收者方法\" class=\"headerlink\" title=\"指针接收者方法\"></a>指针接收者方法</h2><p>接收者分为<strong>值接收者</strong>和<strong>指针接收者</strong>两种。指针接收者方法就是把所属类型的接收对象改为指针的形式，例如，我们为Point类创建指针接收者方法可以写成这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point)</span></span> distance2(q *Point) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是把方法绑定的变量改成了该类型的指针形式。如果直接在原来的基础上增加一个指针接收者方法，那编译器将会出现提醒：<code>Struct Point has methods on both value and pointer receivers. Such usage is not recommended by the Go Documentation. </code>也就是说不推荐同时存在两种接收者。所以，<strong>一旦该类型有一个指针接收者方法，那么其余所有方法都应该使用指针作为接收者</strong>。</p>\n<p>由于指针接收者的存在，所以Go语言不允许指针类型定义方法，防止混淆，因为编译器会对两种接收者进行隐式转换，见下面的代码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 值接收者类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> distanceTo(q Point) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指针接收者类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point2 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point2)</span></span> scaleBy(size <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tp.X, p.Y = size*p.X, size*p.Y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point2)</span></span> distanceTo(q *Point2) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Sqrt(((*p).X-(*q).X)*((*p).X-(*q).X) + (p.Y-q.Y)*(p.Y-q.Y))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动隐式转换示例，看起来可能有点绕，但是记住这个例子是为了证明方法接收者会进行隐式转换，从而不允许为指针定义方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tp := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 变量值</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, p.distanceTo(Point&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, (&amp;p).distanceTo(Point&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">\tp2 := &amp;Point2&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 变量指针</span></span><br><span class=\"line\">\tp2.scaleBy(<span class=\"number\">2</span>) <span class=\"comment\">// 直接调用</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, p2.distanceTo(&amp;Point2&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, (*p2).distanceTo(&amp;Point2&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">\t(*p2).scaleBy(<span class=\"number\">0.5</span>) <span class=\"comment\">// 类型转换后调用</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, p2.distanceTo(&amp;Point2&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, (*p2).distanceTo(&amp;Point2&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>nil也是一个合法的接收者</strong></li>\n</ul>\n<p>对于常见的OOP语言而言，空指针null是无法调用任何成员函数的。但是在Go中，nil是一个合法的接收者，当调用者的值为nil的时候，也可以有对应操作：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point2)</span></span> length() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> p==<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.X*p.X+p.Y*p.Y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，即使使用一个*Point2类型的空指针作为接收者，也可以调用length，返回长度为0。</p>\n<ul>\n<li><strong>方法变量可以将一个结构体的方法转换成为普通函数使用</strong></li>\n</ul>\n<p>和函数变量类似，方法变量也是将某一个方法赋值到变量中，后面使用变量调用这个方法，可以直接像函数一样使用，但是使用较少，此处就省略了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文主要讲述了Go中的函数和方法的使用要点和注意事项，以实验的方法验证了部分特性。函数和方法是Go中最重要的两个概念。Go不是传统意义上的OOP语言，它通常通过包级别来实现封装功能，而包内使用函数式编程，并对外提供服务。总而言之，用好函数和方法是用好Go的关键。</p>\n","categories":[{"name":"Exp","slug":"Exp","permalink":"https://veni222987.github.io/categories/Exp/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://veni222987.github.io/tags/Go/"}]},{"title":"Java内置集合框架及其线程安全性","date":"2024-02-22T11:41:30.000Z","path":"2024/02/22/Java内置集合框架及其线程安全性/","text":"首先需要了解一下Java的集合框架，主要包含三部分：Collection, Iterator和Map。Collection是集合，包括List, Set, Queue等等。Iterator是迭代器，Map是映射。本文不会讲解他们的基本使用和常用方法，主要针对特性和彼此的异同进行研究。我们先来看一下Java的集合框架的总览图： 这里面的数据结构非常多，一开始可能会一无所措，但是其实慢慢拆解发现也没那么难。 CollectionColletion是最常用的集合工具，下面这张图表现了Collection中的主要接口和类及其特点。 Collection Interface先来看一下Collection接口的源码都有哪些函数吧。 不难发现，Collection的这些操作都是集合的常见操作，尤其是contains, clear, add, remove等等。这些接口在不同的数据结构中有不同的实现，例如对于一个List而言，remove就是直接移除队首元素，而对于一个堆（或者说优先队列）而言，remove就是移除堆顶元素，然后将最后一个元素放上来往下筛。 List先说List。从实现方式上面看，ArrayList和Vector是基于数组的，这两者比较相似，而LinkedList是基于链表的。但是从线程安全性看，Vector又是相对于ArrayList和LinkedList更独特的。Vector的函数中使用了synchronized关键字，例如下面的addElement函数。synchronized关键字确保了在多线程的情况下，Vector的方法是同步的，同一时间只能有一个线程访问Vector的方法。 1234public synchronized void addElement(E obj) &#123; modCount++; add(obj, elementData, elementCount);&#125; 下面我们将写一段代码验证一下Vector的线程安全。首先写一个线程类，实现Runnable接口，并且重写run()函数。构造函数传入一个List。注意List是一个接口，可以实例化为ArrayList，LinkedList和Vector。 1234567891011121314static class ListThread implements Runnable &#123; private List&lt;Integer&gt; list; public ListThread(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; list.add(i); &#125; &#125;&#125; 接下来我们会创建一个共享的List变量，然后实例化两个线程并将List传进去，每个线程往List中加入10000个元素（这个动作是由上面的run函数决定的，也可以测试其他的函数）。 123456789101112131415161718192021222324public static void main(String[] args) &#123; // 创建一个共享的List对象 List&lt;Integer&gt; sharedList = new Vector&lt;&gt;(); // 这里可以修改成为ArrayList、LinkedList试一下 // 创建两个线程，分别对共享的List进行操作 Thread thread1 = new Thread(new ListThread(sharedList)); Thread thread2 = new Thread(new ListThread(sharedList)); // 启动线程 thread1.start(); thread2.start(); // 等待线程执行完毕 try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 打印最终的List内容 System.out.println(sharedList); System.out.println(sharedList.size());&#125; 如果List是实例化为Vector的话，那么最终的sharedList.size始终是20000的，但是实例化为ArrayList和LinkedList则基本上不可能达到20000。 测试线程安全性的一般步骤是：创建共享对象-&gt;写一个线程类并传入共享对象-&gt;创建多个线程调用对象方法-&gt;观察结果。 Set回到上面的图，常用的Set包括HashSet，TreeSet和LinkedHashSet。很遗憾，这三者都是非线程安全的，后面会讲如何在多线程中安全地使用Set。 HashSet基于哈希表实现，其增加、查找和删除元素都是O(1)的，并且允许存储null元素。LinkedHashSet是在HashSet的基础上添加了链表实现，使得迭代器迭代顺序和插入顺序一致。而TreeSet是基于红黑树实现的，时间复杂度是O(logn)，不允许存储null元素。 HashSet是如何保证元素的唯一性的 使用HashSet存储自定义的类时，一般都要重写hashCode()函数和equals(Object obj)函数。 先写一个自定义的Person类： 123456789101112131415161718192021222324class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age &amp;&amp; name.equals(person.name); &#125; @Override public int hashCode() &#123; return java.util.Objects.hash(name, age); &#125;&#125; 然后new三个对象，其中两个的字段完全一样，将其加入set中： 12345678910111213public static void main(String[] args) &#123; HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); Person person1 = new Person(&quot;Alice&quot;, 25); Person person2 = new Person(&quot;Bob&quot;, 30); Person person3 = new Person(&quot;Alice&quot;, 25); set.add(person1); set.add(person2); set.add(person3); System.out.println(&quot;HashSet size: &quot; + set.size()); &#125; 观察结果，如果重写了equals方法和hashcode方法，那么size将会是2。任何一个没有重写都会是3。 在Java中，equals和hashCode应该是一致的，即equals为true的对象，其hashcode也应该为true。默认情况下，equals比较的是内存地址，而hashCode则是根据地址算出来的一个数。所以上面的例子中不重写的情况下，size为3。 TreeSet是如何保证元素的唯一性的 TreeSet是基于红黑树的有序集合，它在插入元素时会根据元素的排序规则进行插入，从而保证元素的有序性。使用TreeSet存储自定义的类，也是需要满足一定的规范。在定义类的时候，需要实现Comparable&lt;E&gt;接口，重写compareTo函数，例如一个Person类根据年龄比较大小。 Queue队列的使用其实比较简单，在Java中一般使用双端队列Deque，Deque实现了Queue的接口，而LinkedList实现了Deque的接口，所以Deque一般都实例化为LinkedList。注意几对操作：push和pop可以当作stack使用；add和remove，offer和poll可以当作queue使用，后面两组queue操作的区别在于返回类型，remove会抛出错误，而poll会返回布尔值。 Collections工具Java.utils中Collections类包含许多常用的静态工具函数，例如对于List的reverse和sort等等。 上面我们提到的Set都是非线程安全的，那么想要使用线程安全的Set怎么办呢？那就可以用到Collections里面的synchronizedSet将普通的Set升级为线程安全的Set: 123456789101112131415161718// 创建一个普通的SetSet&lt;String&gt; set = new HashSet&lt;&gt;();// 使用Collections.synchronizedSet()方法创建一个线程安全的SetSet&lt;String&gt; synchronizedSet = Collections.synchronizedSet(set);// 在多个线程中同时操作synchronizedSetRunnable runnable = () -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; synchronizedSet.add(&quot;Element &quot; + i); &#125;&#125;;// 创建多个线程并启动Thread thread1 = new Thread(runnable);Thread thread2 = new Thread(runnable);thread1.start();thread2.start(); 无论运行多少次输出size为1000(因为Set过滤相同元素)，表明在多线程中确实所有修改都是同步的。 Map讲完了Collection，下面讲讲Map。还是一张图大概了解一下Map家族。 HashMap比HashTable单机性能要好，但是牺牲了线程安全性。Collections.synchronizedMap也可以将HashMap升级为线程安全的，用法和HashSet一样。 HashMap使用开哈希实现，同位置可以存储多个元素，最初使用链表的形式，在Java8中添加了红黑树，当链表中元素超过8个以后，同一位置的查找速度从O(n)变为O(logn)。 ConcurrentHashMap则弥补了HashMap的缺点，它使用了一个Segment数组来对HashMap实现加锁，从而保证了线程安全，因为分段加锁，也不会牺牲太多的速度。用法如下，直接new实例化即可： 12345678910111213141516171819202122import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class ConcurrentMapExample &#123; public static void main(String[] args) &#123; // 创建一个线程安全的Map Map&lt;String, Integer&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;(); // 在多个线程中同时操作concurrentMap Runnable runnable = () -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; concurrentMap.put(&quot;Key &quot; + i, i); &#125; &#125;; // 创建多个线程并启动 Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); &#125;&#125; TreeMap是可排序的，和TreeSet类似，都需要实现Comparable接口。当使用Iterator遍历TreeMap的时候，得到的记录是排过序的。 Iterator迭代器(Iterator)是一个接口，提供了一套遍历集合（这里的集合是广义集合，包括List, Set和Map）元素的方法。遍历List或许是一件比较简单的事情，但是遍历Set和Map则不然。所以迭代器就是在这样的需求下出现的。 通过调用集合对象的iterator()方法，可以获取到一个实现了Iterator接口的迭代器对象。主要操作包括hasNext和Next。 以ArrayList为例，其内部包括了一个私有类并且实现了迭代器接口，这里面的逻辑代码可以不必深究，知道迭代器实现的整体框架即可。 123456789101112131415161718192021222324private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // prevent creating a synthetic constructor Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; 在调用iterator的时候，会new一个Itr并且返回： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 注意到代码中迭代器可能会抛出两个异常：ConcurrentModificationException和NoSuchElementException。后者容易理解，每次调用next之前用hasNext判断即可。那么ConcurrentModificationException是什么意思呢？这是为了保证在多线程环境下的安全性。expectedModCount就是预期修改的次数，在多线程中，如果一个迭代器正在迭代，此时另一个线程对集合进行了修改，那么就会抛出这个异常。尽管设计是防止多线程的不一致性，在实际应用中，单线程情况下也会出现这个异常，那就是在迭代器迭代的时候修改了集合，例如remove，这样也是不允许的。 123456while (iterator.hasNext()) &#123; String fruit = iterator.next(); if (fruit.equals(&quot;Banana&quot;)) &#123; fruits.remove(fruit); // 在迭代过程中修改集合 &#125;&#125; 在某些场景需要对List从后往前遍历，并可能删除元素的情况下，不能使用迭代器遍历。 总结本文总结了Java的集合框架的分类和特点。Java迭代至今，每一个类都是有存在的理由的。根据不同的场景使用不同的集合类，可以避免很多隐藏的错误，或者提升程序的运行效率。","content":"<p>首先需要了解一下Java的集合框架，主要包含三部分：Collection, Iterator和Map。Collection是集合，包括List, Set, Queue等等。Iterator是迭代器，Map是映射。本文不会讲解他们的基本使用和常用方法，主要针对特性和彼此的异同进行研究。我们先来看一下Java的集合框架的总览图：</p>\n<p><img src=\"https://pdai.tech/images/java_collections_overview.png\"></p>\n<p>这里面的数据结构非常多，一开始可能会一无所措，但是其实慢慢拆解发现也没那么难。</p>\n<h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>Colletion是最常用的集合工具，下面这张图表现了Collection中的主要接口和类及其特点。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240222215904059.png\" alt=\"image-20240222215904059\"></p>\n<h2 id=\"Collection-Interface\"><a href=\"#Collection-Interface\" class=\"headerlink\" title=\"Collection Interface\"></a>Collection Interface</h2><p>先来看一下Collection接口的源码都有哪些函数吧。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240305144742171.png\" alt=\"image-20240305144742171\"></p>\n<p>不难发现，Collection的这些操作都是集合的常见操作，尤其是<code>contains, clear, add, remove</code>等等。这些接口在不同的数据结构中有不同的实现，例如对于一个List而言，remove就是直接移除队首元素，而对于一个堆（或者说优先队列）而言，remove就是移除堆顶元素，然后将最后一个元素放上来往下筛。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>先说List。从实现方式上面看，ArrayList和Vector是基于数组的，这两者比较相似，而LinkedList是基于链表的。但是从线程安全性看，Vector又是相对于ArrayList和LinkedList更独特的。Vector的函数中使用了<code>synchronized</code>关键字，例如下面的addElement函数。<code>synchronized</code>关键字确保了在多线程的情况下，Vector的方法是同步的，同一时间只能有一个线程访问Vector的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addElement</span><span class=\"params\">(E obj)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    add(obj, elementData, elementCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们将写一段代码验证一下Vector的线程安全。首先写一个线程类，实现Runnable接口，并且重写run()函数。构造函数传入一个List。注意List是一个接口，可以实例化为ArrayList，LinkedList和Vector。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Integer&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ListThread</span><span class=\"params\">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.list = list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们会创建一个共享的List变量，然后实例化两个线程并将List传进去，每个线程往List中加入10000个元素（这个动作是由上面的run函数决定的，也可以测试其他的函数）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个共享的List对象</span></span><br><span class=\"line\">    List&lt;Integer&gt; sharedList = <span class=\"keyword\">new</span> <span class=\"title class_\">Vector</span>&lt;&gt;(); <span class=\"comment\">// 这里可以修改成为ArrayList、LinkedList试一下</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建两个线程，分别对共享的List进行操作</span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ListThread</span>(sharedList));</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ListThread</span>(sharedList));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待线程执行完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        thread1.join();</span><br><span class=\"line\">        thread2.join();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印最终的List内容</span></span><br><span class=\"line\">    System.out.println(sharedList);</span><br><span class=\"line\">    System.out.println(sharedList.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果List是实例化为Vector的话，那么最终的sharedList.size始终是20000的，但是实例化为ArrayList和LinkedList则基本上不可能达到20000。</p>\n<blockquote>\n<p>测试线程安全性的一般步骤是：创建共享对象-&gt;写一个线程类并传入共享对象-&gt;创建多个线程调用对象方法-&gt;观察结果。</p>\n</blockquote>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>回到上面的图，常用的Set包括HashSet，TreeSet和LinkedHashSet。很遗憾，这三者都是非线程安全的，后面会讲如何在多线程中安全地使用Set。</p>\n<p>HashSet基于哈希表实现，其增加、查找和删除元素都是O(1)的，并且允许存储null元素。LinkedHashSet是在HashSet的基础上添加了链表实现，使得迭代器迭代顺序和插入顺序一致。而TreeSet是基于红黑树实现的，时间复杂度是O(logn)，不允许存储null元素。</p>\n<ul>\n<li><strong>HashSet是如何保证元素的唯一性的</strong></li>\n</ul>\n<p>使用HashSet存储自定义的类时，一般都要重写hashCode()函数和equals(Object obj)函数。</p>\n<p>先写一个自定义的Person类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == obj)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj == <span class=\"literal\">null</span> || getClass() != obj.getClass())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person) obj;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age == person.age &amp;&amp; name.equals(person.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> java.util.Objects.hash(name, age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后new三个对象，其中两个的字段完全一样，将其加入set中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    HashSet&lt;Person&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">person1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">person2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"type\">Person</span> <span class=\"variable\">person3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    set.add(person1);</span><br><span class=\"line\">    set.add(person2);</span><br><span class=\"line\">    set.add(person3);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;HashSet size: &quot;</span> + set.size()); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察结果，如果重写了equals方法和hashcode方法，那么size将会是2。任何一个没有重写都会是3。</p>\n<blockquote>\n<p>在Java中，equals和hashCode应该是一致的，即equals为true的对象，其hashcode也应该为true。默认情况下，equals比较的是内存地址，而hashCode则是根据地址算出来的一个数。所以上面的例子中不重写的情况下，size为3。</p>\n</blockquote>\n<ul>\n<li><strong>TreeSet是如何保证元素的唯一性的</strong></li>\n</ul>\n<p>TreeSet是基于红黑树的有序集合，它在插入元素时会根据元素的排序规则进行插入，从而保证元素的有序性。使用TreeSet存储自定义的类，也是需要满足一定的规范。在定义类的时候，需要实现<code>Comparable&lt;E&gt;</code>接口，重写<code>compareTo</code>函数，例如一个Person类根据年龄比较大小。</p>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>队列的使用其实比较简单，在Java中一般使用双端队列Deque，Deque实现了Queue的接口，而LinkedList实现了Deque的接口，所以Deque一般都实例化为LinkedList。注意几对操作：push和pop可以当作stack使用；add和remove，offer和poll可以当作queue使用，后面两组queue操作的区别在于返回类型，remove会抛出错误，而poll会返回布尔值。</p>\n<h2 id=\"Collections工具\"><a href=\"#Collections工具\" class=\"headerlink\" title=\"Collections工具\"></a>Collections工具</h2><p>Java.utils中Collections类包含许多常用的静态工具函数，例如对于List的reverse和sort等等。</p>\n<p>上面我们提到的Set都是非线程安全的，那么想要使用线程安全的Set怎么办呢？那就可以用到Collections里面的synchronizedSet将普通的Set升级为线程安全的Set:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个普通的Set</span></span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Collections.synchronizedSet()方法创建一个线程安全的Set</span></span><br><span class=\"line\">Set&lt;String&gt; synchronizedSet = Collections.synchronizedSet(set);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在多个线程中同时操作synchronizedSet</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">        synchronizedSet.add(<span class=\"string\">&quot;Element &quot;</span> + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多个线程并启动</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">thread1.start();</span><br><span class=\"line\">thread2.start();</span><br></pre></td></tr></table></figure>\n\n<p>无论运行多少次输出size为1000(因为Set过滤相同元素)，表明在多线程中确实所有修改都是同步的。</p>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>讲完了Collection，下面讲讲Map。还是一张图大概了解一下Map家族。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240222233725940.png\" alt=\"image-20240222233725940\"></p>\n<p>HashMap比HashTable单机性能要好，但是牺牲了线程安全性。Collections.synchronizedMap也可以将HashMap升级为线程安全的，用法和HashSet一样。</p>\n<blockquote>\n<p>HashMap使用开哈希实现，同位置可以存储多个元素，最初使用链表的形式，在Java8中添加了红黑树，当链表中元素超过8个以后，同一位置的查找速度从O(n)变为O(logn)。</p>\n</blockquote>\n<p>ConcurrentHashMap则弥补了HashMap的缺点，它使用了一个Segment数组来对HashMap实现加锁，从而保证了线程安全，因为分段加锁，也不会牺牲太多的速度。用法如下，直接new实例化即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcurrentMapExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个线程安全的Map</span></span><br><span class=\"line\">        Map&lt;String, Integer&gt; concurrentMap = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在多个线程中同时操作concurrentMap</span></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                concurrentMap.put(<span class=\"string\">&quot;Key &quot;</span> + i, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建多个线程并启动</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TreeMap是可排序的，和TreeSet类似，都需要实现Comparable接口。当使用Iterator遍历TreeMap的时候，得到的记录是排过序的。</p>\n<h1 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h1><p>迭代器(Iterator)是一个接口，提供了一套遍历集合（这里的集合是广义集合，包括List, Set和Map）元素的方法。遍历List或许是一件比较简单的事情，但是遍历Set和Map则不然。所以迭代器就是在这样的需求下出现的。</p>\n<p>通过调用集合对象的<code>iterator()</code>方法，可以获取到一个实现了<code>Iterator</code>接口的迭代器对象。主要操作包括hasNext和Next。</p>\n<p>以ArrayList为例，其内部包括了一个私有类并且实现了迭代器接口，这里面的逻辑代码可以不必深究，知道迭代器实现的整体框架即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cursor;       <span class=\"comment\">// index of next element to return</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">lastRet</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>; <span class=\"comment\">// index of last element returned; -1 if no such</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">expectedModCount</span> <span class=\"operator\">=</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prevent creating a synthetic constructor</span></span><br><span class=\"line\">    Itr() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor != size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> cursor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchElementException</span>();</span><br><span class=\"line\">        Object[] elementData = ArrayList.<span class=\"built_in\">this</span>.elementData;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= elementData.length)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentModificationException</span>();</span><br><span class=\"line\">        cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[lastRet = i];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调用<code>iterator</code>的时候，会new一个Itr并且返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Itr</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到代码中迭代器可能会抛出两个异常：ConcurrentModificationException和NoSuchElementException。后者容易理解，每次调用next之前用hasNext判断即可。那么ConcurrentModificationException是什么意思呢？这是为了保证在多线程环境下的安全性。expectedModCount就是预期修改的次数，在多线程中，如果一个迭代器正在迭代，此时另一个线程对集合进行了修改，那么就会抛出这个异常。尽管设计是防止多线程的不一致性，在实际应用中，单线程情况下也会出现这个异常，那就是在迭代器迭代的时候修改了集合，例如remove，这样也是不允许的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">fruit</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fruit.equals(<span class=\"string\">&quot;Banana&quot;</span>)) &#123;</span><br><span class=\"line\">        fruits.remove(fruit); <span class=\"comment\">// 在迭代过程中修改集合</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在某些场景需要对List从后往前遍历，并可能删除元素的情况下，不能使用迭代器遍历。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文总结了Java的集合框架的分类和特点。Java迭代至今，每一个类都是有存在的理由的。根据不同的场景使用不同的集合类，可以避免很多隐藏的错误，或者提升程序的运行效率。</p>\n","categories":[{"name":"Java","slug":"Java","permalink":"https://veni222987.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://veni222987.github.io/tags/Java/"}]},{"title":"Docker部署项目指南","date":"2024-01-24T05:41:18.000Z","path":"2024/01/24/Docker部署项目指南/","text":"Docker简介这篇文章是新手向的Docker使用文章。所以现在介绍一下Docker吧。根据Docker官方的说法： Docker helps developers build, share, run, and verify applications anywhere — without tedious environment configuration or management. 简单来说就是一个帮助开发者构建、运行和分享应用的容器，它可以让你无需考虑在不同的机器上运行的时候的环境配置问题。想象一下你自己写好的一个软件，但是到了别人的计算机无法运行，又找不到环境配置哪里没配好，那个情景有多难受。这时候，如果使用了Docker，你就会明白什么叫纵享丝滑部署。 Docker安装这里的Docker安装指的是安装Docker-CE(Community Edition)。根据Docker官方指导，有四种安装方法，这里介绍两种。 Docker Desktop 主要适用于带有桌面的计算机，如Windows，Ubuntu桌面等。安装了DockerDesktop就相当于安装了Docker-CE, Docker-CLI等一系列工具。对于WSL，只需要在Windows主系统安装DockerDesktop并勾选适用WSL。 安装包安装(apt、yum等) 大陆用户推荐使用阿里云镜像安装，根据指导执行对应的shell脚本即可。 如果安装过程出现了任何问题，都可以阅读上面的官方指导链接里面的内容寻找解决方法。 Docker基本使用先搞清楚Docker的三个概念：镜像、容器和进程： 镜像（Image）：Docker镜像是一个只读的模板，它包含了运行容器所需的所有文件系统、应用程序代码、依赖项和配置信息。镜像是用于创建Docker容器的基础。 查看镜像： 1docker images 删除镜像： 1docker rmi &lt;镜像名或id&gt; 创建镜像后面详细说。 容器（Container）：Docker容器是从Docker镜像创建的运行实例。容器是独立且轻量级的，它包含了运行应用程序所需的所有内容，包括文件系统、代码、依赖项和配置。这一层的操作是最重要的，只有熟悉容器的操作，才能用好Docker。 查看容器： 1docker ps 查看容器端口映射： 1docker port &lt;容器名&gt; 从镜像创建容器并运行： 123docker run &lt;镜像名&gt;# 运行时指定端口映射docker run -p &lt;主机端口&gt;:&lt;容器端口&gt; &lt;镜像名称&gt; 删除容器： 1docker rm &lt;容器名字或id&gt; 重启容器： 1docker restart &lt;容器名或id&gt; 进入容器内部： 1docker exec -it &lt;容器ID或名称&gt; /bin/bash 进程（Process）：在Docker容器中运行的应用程序被视为一个或多个进程。容器内部的进程与宿主机的进程隔离，它们在自己的命名空间中运行，并且只能访问容器内部的资源。 部署Docker镜像部署Docker Hub镜像Docker Hub是一个面向Docker开发者和用户的公共注册表服务。它是一个集中存储、分享和管理Docker镜像的平台。我们可以从Docker Hub中拉取镜像，也可以上传自己的创建的镜像。 下面将以部署Redis为例，讲一下如何部署他人已经上传的镜像。上文说到过，要创建一个容器必须要有镜像，所以第一步就是将容器镜像从docker hub上拉下来： 1docker pull redis 具体的指令一般都会在镜像对应页面的右上角： 执行完成之后，可以用docker images指令查看本地镜像。如果有对应的镜像，那就可以run了。一般来说，Docker hub上有对应的启动和配置教程，细心阅读即可。按照默认运行，设置端口映射可以执行如下指令： 1docker run --name redis -p 6379:6379 -d redis 然后ps一下看看有没有成功运行就可以了。总的来说，部署他人的容器镜像比较简单，耐心阅读指导就可以了。 自己创建镜像部署自己创建镜像需要编写Dockerfile，定义和描述如何创建Docker镜像。例如，创建一个Spring boot镜像的Dockerfile可以写成如下形式： 12345FROM openjdk:17WORKDIR /vshopCOPY . /vshopEXPOSE 8080CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/vshop/vshop.jar&quot;,&quot;&gt;&gt;&quot;,&quot;/vshop/log.log&quot;,&quot;&amp;&quot;] 下面是Dockerfile中的一些常见配置： FROM：定义基础镜像，确定构建的起点 WORKDIR：容器中的工作目录 RUN、ADD、COPY：安装软件包，依赖项和文件到镜像中 EXPOSE：配置端口 ENV：配置容器中的环境变量 CMD：启动容器时执行的指令 编写完Dockerfile之后，将Dockerfile和打包完成的jar包放在新建目录下，然后执行如下指令： 1docker build -t vshop . -t指定了打包的名字和标签，. 表示在当前目录下寻找Dockerfile并且打包。打包完成之后，使用docker images查看镜像即可。上面的案例仅作一个简单的示例，事实上Dockerfile大部分都是不通用的，例如将Spring boot项目打包成为war包然后运行在Tomcat容器中，则需要进行两层构建，第一层基于Tomcat构建基础镜像，第二层构建最终的镜像。当需要打包不同类型的项目的时候，可以查阅官方文档或者自行Google一下。 发布Docker镜像前面介绍过Docker Hub了，现在讲讲如何将自己构建的Docker项目发布到Docker Hub上。首先需要自己注册一个Docker账号并且执行一下docker login登录Docker。然后的操作就和Git推送到GitHub差不多。 使用docker tag给镜像添加标签： 1docker tag &lt;镜像ID&gt; &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt; 然后直接push到Docker Hub即可： 1docker push &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt; 当push完成以后，在另外一台电脑（如服务器）上运行这个项目就回到了部署那一部分的内容了。现在你已经掌握了Docker构建和部署项目的基本流程了。","content":"<h1 id=\"Docker简介\"><a href=\"#Docker简介\" class=\"headerlink\" title=\"Docker简介\"></a>Docker简介</h1><p>这篇文章是新手向的Docker使用文章。所以现在介绍一下Docker吧。根据Docker官方的说法：</p>\n<blockquote>\n<p>Docker helps developers build, share, run, and verify applications anywhere — without tedious environment configuration or management.</p>\n</blockquote>\n<p>简单来说就是一个帮助开发者构建、运行和分享应用的容器，它可以让你无需考虑在不同的机器上运行的时候的环境配置问题。想象一下你自己写好的一个软件，但是到了别人的计算机无法运行，又找不到环境配置哪里没配好，那个情景有多难受。这时候，如果使用了Docker，你就会明白什么叫纵享丝滑部署。</p>\n<h2 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h2><p>这里的Docker安装指的是安装Docker-CE(Community Edition)。根据<a href=\"https://docs.docker.com/engine/install/\">Docker官方指导</a>，有四种安装方法，这里介绍两种。</p>\n<ul>\n<li><strong>Docker Desktop</strong></li>\n</ul>\n<p>主要适用于带有桌面的计算机，如Windows，Ubuntu桌面等。安装了DockerDesktop就相当于安装了Docker-CE, Docker-CLI等一系列工具。对于WSL，只需要在Windows主系统安装DockerDesktop并勾选适用WSL。</p>\n<ul>\n<li><strong>安装包安装(apt、yum等)</strong></li>\n</ul>\n<p>大陆用户推荐使用阿里云镜像安装，根据<a href=\"https://developer.aliyun.com/mirror/docker-ce\">指导</a>执行对应的shell脚本即可。</p>\n<p>如果安装过程出现了任何问题，都可以阅读上面的官方指导链接里面的内容寻找解决方法。</p>\n<h2 id=\"Docker基本使用\"><a href=\"#Docker基本使用\" class=\"headerlink\" title=\"Docker基本使用\"></a>Docker基本使用</h2><p>先搞清楚Docker的三个概念：镜像、容器和进程：</p>\n<ul>\n<li><strong>镜像（Image）：</strong>Docker镜像是一个只读的模板，它包含了运行容器所需的所有文件系统、应用程序代码、依赖项和配置信息。镜像是用于创建Docker容器的基础。</li>\n</ul>\n<p>查看镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n\n<p>删除镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi &lt;镜像名或<span class=\"built_in\">id</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>创建镜像后面详细说。</p>\n<ul>\n<li><strong>容器（Container）：</strong>Docker容器是从Docker镜像创建的运行实例。容器是独立且轻量级的，它包含了运行应用程序所需的所有内容，包括文件系统、代码、依赖项和配置。这一层的操作是最重要的，只有熟悉容器的操作，才能用好Docker。</li>\n</ul>\n<p>查看容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n\n<p>查看容器端口映射：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker port &lt;容器名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>从镜像创建容器并运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run &lt;镜像名&gt;</span><br><span class=\"line\"><span class=\"comment\"># 运行时指定端口映射</span></span><br><span class=\"line\">docker run -p &lt;主机端口&gt;:&lt;容器端口&gt; &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>\n\n<p>删除容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> &lt;容器名字或<span class=\"built_in\">id</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>重启容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart &lt;容器名或<span class=\"built_in\">id</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>进入容器内部：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it &lt;容器ID或名称&gt; /bin/bash</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>进程（Process）：</strong>在Docker容器中运行的应用程序被视为一个或多个进程。容器内部的进程与宿主机的进程隔离，它们在自己的命名空间中运行，并且只能访问容器内部的资源。</li>\n</ul>\n<h1 id=\"部署Docker镜像\"><a href=\"#部署Docker镜像\" class=\"headerlink\" title=\"部署Docker镜像\"></a>部署Docker镜像</h1><h2 id=\"部署Docker-Hub镜像\"><a href=\"#部署Docker-Hub镜像\" class=\"headerlink\" title=\"部署Docker Hub镜像\"></a>部署Docker Hub镜像</h2><p>Docker Hub是一个面向Docker开发者和用户的公共注册表服务。它是一个集中存储、分享和管理Docker镜像的平台。我们可以从Docker Hub中拉取镜像，也可以上传自己的创建的镜像。</p>\n<p>下面将以部署Redis为例，讲一下如何部署他人已经上传的镜像。上文说到过，要创建一个容器必须要有镜像，所以第一步就是将容器镜像从docker hub上拉下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis</span><br></pre></td></tr></table></figure>\n\n<p>具体的指令一般都会在镜像对应页面的右上角：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240224143645281.png\" alt=\"image-20240224143645281\"></p>\n<p>执行完成之后，可以用<code>docker images</code>指令查看本地镜像。如果有对应的镜像，那就可以run了。一般来说，Docker hub上有对应的启动和配置教程，细心阅读即可。按照默认运行，设置端口映射可以执行如下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name redis -p 6379:6379 -d redis</span><br></pre></td></tr></table></figure>\n\n<p>然后ps一下看看有没有成功运行就可以了。总的来说，部署他人的容器镜像比较简单，耐心阅读指导就可以了。</p>\n<h2 id=\"自己创建镜像部署\"><a href=\"#自己创建镜像部署\" class=\"headerlink\" title=\"自己创建镜像部署\"></a>自己创建镜像部署</h2><p>自己创建镜像需要编写Dockerfile，定义和描述如何创建Docker镜像。例如，创建一个Spring boot镜像的Dockerfile可以写成如下形式：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /vshop</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /vshop</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;java&quot;</span>,<span class=\"string\">&quot;-jar&quot;</span>,<span class=\"string\">&quot;/vshop/vshop.jar&quot;</span>,<span class=\"string\">&quot;&gt;&gt;&quot;</span>,<span class=\"string\">&quot;/vshop/log.log&quot;</span>,<span class=\"string\">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是Dockerfile中的一些常见配置：</p>\n<ul>\n<li><p>FROM：定义基础镜像，确定构建的起点</p>\n</li>\n<li><p>WORKDIR：容器中的工作目录</p>\n</li>\n<li><p>RUN、ADD、COPY：安装软件包，依赖项和文件到镜像中</p>\n</li>\n<li><p>EXPOSE：配置端口</p>\n</li>\n<li><p>ENV：配置容器中的环境变量</p>\n</li>\n<li><p>CMD：启动容器时执行的指令</p>\n</li>\n</ul>\n<p>编写完Dockerfile之后，将Dockerfile和打包完成的jar包放在新建目录下，然后执行如下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t vshop .</span><br></pre></td></tr></table></figure>\n\n<p>-t指定了打包的名字和标签，. 表示在当前目录下寻找Dockerfile并且打包。打包完成之后，使用<code>docker images</code>查看镜像即可。上面的案例仅作一个简单的示例，事实上Dockerfile大部分都是不通用的，例如将Spring boot项目打包成为war包然后运行在Tomcat容器中，则需要进行两层构建，第一层基于Tomcat构建基础镜像，第二层构建最终的镜像。当需要打包不同类型的项目的时候，可以查阅官方文档或者自行Google一下。</p>\n<h1 id=\"发布Docker镜像\"><a href=\"#发布Docker镜像\" class=\"headerlink\" title=\"发布Docker镜像\"></a>发布Docker镜像</h1><p>前面介绍过Docker Hub了，现在讲讲如何将自己构建的Docker项目发布到Docker Hub上。首先需要自己注册一个Docker账号并且执行一下<code>docker login</code>登录Docker。然后的操作就和Git推送到GitHub差不多。</p>\n<p>使用<code>docker tag</code>给镜像添加标签：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag &lt;镜像ID&gt; &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后直接push到Docker Hub即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push &lt;用户名&gt;/&lt;仓库名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当push完成以后，在另外一台电脑（如服务器）上运行这个项目就回到了部署那一部分的内容了。现在你已经掌握了Docker构建和部署项目的基本流程了。</p>\n","categories":[{"name":"Docker","slug":"Docker","permalink":"https://veni222987.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://veni222987.github.io/tags/Docker/"}]},{"title":"高性能计算与云计算","date":"2023-12-25T09:11:42.000Z","path":"2023/12/25/高性能计算与云计算/","text":"高性能计算与云计算互联网络互联网络分为静态互联网络和动态互联网络。 静态网络是指各节点之间有固定连接的一类网络。程序执行期间，网络连接不改变。动态网络是用开关单元构成的，可以动态改变连接状态的网络。 静态互联网络的特征 网络规模：网络的节点个数 节点度数：单向网络中，入射和出射边之和称为节点度 网络直径：任意两个节点之间的最长距离 对剖宽度：将网络对分所必须移除的边的数目，如果是奇数个的话理解成可以把某个点切开，如二叉树，N&#x3D;3的线性阵列 对称：从任何一个节点观看网络都一样，称为对称。（有限个网络的场景，网孔、线性阵列是非对称的） 静态互联网络特征比较 网络名 网络规模 节点度数 网络直径 对剖宽度 对称 链路数 线性阵列 N 2 N-1 1 非 N-1 环形 N 2 &#x3D;&#x3D;$\\lfloor N&#x2F;2 \\rfloor$&#x3D;&#x3D; 2 是 N &#x3D;&#x3D;2D网孔&#x3D;&#x3D; $N&#x3D;n^2$ 4 &#x3D;&#x3D;2(n-1)&#x3D;&#x3D; n 非 &#x3D;&#x3D;$2(N-n)$&#x3D;&#x3D;先补再减 &#x3D;&#x3D;Illiac网孔&#x3D;&#x3D; $N&#x3D;n^2$ 4 n-1 2n 非 $2n$ &#x3D;&#x3D;2D环绕&#x3D;&#x3D; $N&#x3D;n^2$ 4 $2 \\lfloor n&#x2F;2 \\rfloor$ 2n 是 $2n$ 二叉树 N 3 $2(\\lceil log_2N \\rceil-1)$ 1 非 N-1 星型 N n-1或1 2 $\\lfloor N&#x2F;2 \\rfloor$ 非 N-1 超立方 $N&#x3D;2^n$ $log_2N&#x3D;n$ n N&#x2F;2 是 nN&#x2F;2 k-立方环 $N&#x3D;k*2^k$ 3 $2k-1+\\lfloor k&#x2F;2 \\rfloor$ N&#x2F;(2k) 是 3N&#x2F;2 并行计算的分类Flynn分类又叫指令流&#x2F;数据流分类法，即费林(Flynn)分类法。先来看一些概念： 指令流：机器执行的指令序列 数据流：指令调用的数据序列，包括输入数据、中间结果等 多倍性：在系统性能平静部件上同时处于同一执行阶段的指令或数据的最大可能个数。 于是，根据指令流和数据流的不同组织形式，将计算机系统分为四类： 单指令单数据流（SISD）：硬件不支持任何形式的并行计算 单指令多数据流（SIMD）：有多个处理单元，按照同一指令流的要求为他们分配各不相同的数据流并进行处理。 多指令单数据流（MISD）：每个处理单元按照多条不同的指令要求同时对同一数据流作不同处理。 多指令多数据流（MIMD）：能将指令，数据任务等全方面并行计算的系统，将主任务分解成众多子任务以缩短时间。 MIMD计算机细分MIMD计算机的主要分类如下： 共享内存和分布式内存的系统架构如下： 共享内存的工作原理：具有一个所有处理器都可以访问的全局物理内存，具备有如下性质： 对称性：系统中的任何处理器等效访问内存和IO 单地址：内存中的每个位置都有唯一地址值 低通信延迟：处理器之间的通信可以利用共享内存来交换数据 高速缓存及其一致性：多级缓存可以提高速度，&#x3D;&#x3D;一致性由硬件来增强(?)&#x3D;&#x3D; 两种模型的分类大致如下，下面将会详细介绍这五种内存访问模型： 并行计算机五种访存模型并行计算机访存模型主要有以下五种： UMA(Uniform Memory Access)：均匀存储访问模型 共享内存属于一种经典的均匀访问模型。主要特点：**对称多处理(Symmetric Multiprocessing, SMP)**，使用的是微处理器和高速缓存。每台处理器可以带有私有的Cache，外围设备也可以共享。发生访存竞争的时候，仲裁策略对所有节点平等。所以叫做均匀存储访问模型。（就是计算机组成中的经典模型） 在SMP中，内存模块和处理器对称地分布在互联网络的两侧。并且只有单一的操作系统镜像，负责处理各个处理器的负载，动态将进程分配到不同的处理器，保持各处理器之间的负载平衡。 NUMA(Non-Uniform Memory Access)：非均匀存储访问模型 被共享的存储器在物理上是分布存储在所有处理器中的，其所有本地存储器的集合就组成了全局地址空间。处理器访问存储器的时间是不一样的。 存储器的访问时间是指从发起访问请求到数据可用的时间间隔。简单理解就是，处理器访问离自己比较近的内存速度比其他内存更快。 如果缓存一致性能够得到维护，那么就可以成为CC-NUMA，否则成为NCC-NUMA。 CC-NUMA(Coherent-Cache Nonuniform Memory Access)：高速缓存一致性 非均匀存储访问模型 CC-NUMA使用基于目录的高速缓存一致性协议；保留了SMP结构易于编程的优点，改善常规SMP的可扩放性。实际上是一个分布式共享存储的DSM多处理机系统，最显著的优点是程序员无需明确在节点上分配数据，在运行期间，高速缓存一致性硬件会自动将数据迁移到需要用到的地方。 COMA(Cache-Only Memory Access)：全高速缓存存储访问 COMA各个处理器节点&#x3D;&#x3D;没有存储层次结构&#x3D;&#x3D;。对比NUMA和CC-NUMA，发现：COMA只有cache，NUMA只有memory，CC-NUMA二者兼有，而UMA则是将内存连接在总线上的。 NORMA(No-Remote Memory Access)：非远程存储访问模型。属于分布式内存模型。 架构图如下： 优点：内存可以随着CPU的数量进行等比例扩展；各个处理器可以无冲突地快速访问自己的内存，不存在维护缓存一致性的开销；可以使用商用、现成的处理器和网络。 局限性：程序员要负责所有处理器之间的数据通信细节问题；很难从基于全局内存空间建立其分布式内存管理的映射，写一个程序有一个全局的地址空间，程序员需要建立全局地址空间到分布式内存的管理，也就是解决什么数据去哪里取的问题；非一致性的内存访问时间使远程节点访问比本地节点访问需要更长的时间。 大规模并行处理机(Massively Parallel Processor, MPP)由大规模的紧密互联的节点组成，内存访问属于非远程存储访问模型(NORMA)，也就是属于分布式存储系统。 每个节点配有局部cache，并通过局部总线与局部内存、局部IO相连，通过互联网络与IO相连。各节点之间的内存模块相互独立，且不存在全局内存单元的统一硬件编址。 每个节点都有不同的操作系统映像。 仅支持消息传递等程序设计（如MPI），不支持全局共享的OpenMP并行程序设计模式。 集群（机群）集群是一种松耦合的计算机组成方式，采用分布式存储，每一个节点是完整的计算机。 集群的优点是：投资风险小、系统结构灵活、能充分利用分散的计算资源 集群的缺点是：通信性能和并行编程环境不佳 和MPP的比较如下图，左边是MPP，右边是Cluster，重点关注：有无磁盘、总线类型 Cluster有磁盘，MPP没有；Cluster各点连接在IO总线(IOB)上，而MPP各点连接在存储总线MB上。 DSM(Distributed Shared Memory)属于非一致性内存访问模型(NUMA)，内存模块放在各个节点的内部，并且被所有节点共享。这样，可以较好改善多处理共享存储并行机的可扩展能力。 节点之间通过高性能互联网络连接，内存模块分布在各节点中，避免了SMP中的访问总线的带宽瓶颈。具有单一的内存地址空间（硬件统一编址，各个节点可以相互访问）。 注意和MPP对比，多了一个DIR：Cache Directory。 总结各种访存模型： 五种结构特性： 并行计算模型(LogP重点)将并行计算机的基本特征抽象出来，形成一个抽象的计算模型，作为并行算法分析、设计和性能预测的基础。 主要的并行计算模型有：PRAM模型、BSP模型和logP模型。 PRAM模型：又称SIMD-SM模型，有一个集中的共享存储器和一个指令器，通过SM的R&#x2F;W交换数据，隐式同步计算。模型的架构图如下： 优点是适合并行算法的表示和复杂性分析，易于使用，隐藏了并行机的通讯、同步等区别。 缺点是不适合MIMD并行机，忽略了SM的竞争、通讯延迟等因素。 BSP模型 “块”同步模型，异步MIMD-DM模型，支持消息传递系统，块内异步并行，块间显式同步。 LogP模型（重点掌握） 一种分布存储的、点到点通讯的多处理机模型，其中通讯由一组参数描述，实行隐式同步。 模型参数： L: latency网络延迟 o: 接收和发送时间 g: gap&#x3D;1&#x2F;bandwidth，两个连续通信的最小间隔 P: 处理器数量 前面三个都是表示时间的参数，它们之间的关系如下图： 点到点通信事件：L+2o 读取远程地址：2L+4o 性能评测算法性能评测 加速比：$S_p&#x3D;\\dfrac{串行执行时间}{并行执行时间}$ 并行效率：$E&#x3D;\\dfrac{加速比}{核数}$ 由于通信等因素，一般来说并行效率不会超过1。如果超过了1，那就是超线性加速比。那么什么时候会出现超线性加速比呢？ 可能出现超线性加速比的成因主要是不同处理器的高速缓存足以提供计算需要的存储量，属于硬件特性。 不同约束条件下的加速比： 固定问题规模 固定时间 固定存储 Amdahl定律描述了规模固定的加速比。 该定律指出，系统中对于某一部件采用更快的执行方式所能获得的性能改进程度，取决于这种执行方式被使用的频率。 $W_s$是串行化部分运行的时间，$W_p$是并行化部分采用串行化的方法需要的时间。f是使用串行化的任务占比，p是并行核数。 $S_{pc}&#x3D;\\dfrac{优化前耗时}{优化后耗时}&#x3D;\\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}&#x3D;\\dfrac{f+(1-f)}{f+\\frac{1-f}{p}}&#x3D;\\dfrac{p}{1+f(p-1)}$，当p-&gt;$\\infin$时，等于$1&#x2F;f$。 例如，上图中，f&#x3D;1&#x2F;3，p&#x3D;2，那么加速比就是：Spc&#x3D;6&#x2F;5，也就是300&#x2F;250。 增强的Amdahl定律，考虑了并行和通信的开销，推导式如下： 所以，Amdahl定律用一句话总结就是：&#x3D;&#x3D;并行计算模型的加速比不会超过串行化占比的倒数&#x3D;&#x3D;。 Gustafson定律描述了时间固定的加速比。 Gustafson定律也表明处理器个数、并行比例和加速比之间的关系。它描述了，在串行部分比例固定的前提下，加速比会随着处理器个数增加而增加。 见公式Amdahl推导式的$\\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}$，当p变大的时候，加速比自然变大，但是有渐近线逼近。 考虑到并行开销的Gustafson定律，了解即可。 Sun&amp;Ni定律描述了存储受限的加速比。 推导公式：$\\begin{aligned}S_{MC}&#x3D;\\frac{Work(p)&#x2F;Time(p)}{Work(l)&#x2F;Time(l)}&#x3D;\\frac{fW+(1-f)G(p)W}{fW+(1-f)G(p)W&#x2F;p}&#x3D;\\frac{f+(1-f)G(p)}{f+(1-f)G(p)&#x2F;p}\\end{aligned}$ 当G(p)&#x3D;1的时候就是Amdahl加速定律，G(p)&#x3D;p时变为f+p(1-f)，就是Gustafson加速定律。 可扩展性评测标准增加系统规模（处理器个数）会增大额外开销和降低处理器利用率，所以对于一个特定的并行处理系统（算法或程序），它们能否有效利用不断增加的处理器的能力应是受限的，而度量这种能力的就是可扩展性这一指标。可扩展性更关心在&#x3D;&#x3D;系统规模和数据规模&#x3D;&#x3D;变化时的&#x3D;&#x3D;执行时间&#x3D;&#x3D;，是{性能、系统规模、数据规模}的综合量度。 可扩展性的三种量化方式： 等效率&#x3D;$\\dfrac{加速比}{处理器数}$，分析简单 等速度：每秒处理的数据量，便于通过实验数据得到结果。 平均时延：理想并行时间和实际并行时间的差距，便于通过实验数据得到结果。 等效率函数考虑有并行开销的并行效率，加速比$\\begin{aligned}S&#x3D;\\dfrac{T_e}{T_p}&#x3D;\\dfrac{T_e}{\\dfrac{T_e+T_o}p}&#x3D;\\dfrac{P}{1+\\dfrac{T_o}{T_e}}&#x3D;\\dfrac{P}{1+\\dfrac{W_o}W}\\end{aligned}$，等效率：$\\begin{aligned}E&#x3D;\\frac{S}{P}&#x3D;\\frac{1}{1+\\dfrac{T_o}{T_e}}&#x3D;\\frac{1}{1+\\dfrac{W_o}{W}}\\end{aligned}$。 如果保持问题规模W不变，处理器数目p增加，开销$T_o$增大，$W_o$增大，效率E下降。为了维持等效率，在增加处理器的时候，问题规模W也应该增大。 下图是等效率曲线。曲线1表示可扩放性较好，曲线2表示算法可以扩放，曲线3表示算法不可扩放。 按照等效率函数的定义，对于某一并行算法(或并行程序),为了维持运行效率保持不变，随着处理器数目的增加，若只需增加较小的工作量(即问题规模),比如说$W$随$P$呈线性或亚线性增长，则表示该算法具有良好的可扩放性；若需增加非常大的问题规模，比如说$W$随$P$呈指数级增长，则表示该算法是不可扩放的。 PCAM设计方法学 划分划分可以分为两类划分：域分解（数据分解）和功能分解。域分解划分的是数据，功能分解划分的是计算。 划分之后，研究不同任务所需要的数据。如果这些数据不相交，则划分是成功的，否则需要重新进行域分解。 划分的标准： 划分的任务数，是否至少高于目标机上处理器数量一个量级。（灵活性）若否，则后续的设计步骤缺少灵活性。 是否避免冗余的计算和存储要求（可扩放性）若否，算法的扩放性较差。 划分的任务尺寸是否大致相当（均衡）若否，分配处理器时难以做到工作量均衡。 任务数是否与问题尺寸成正比，理想情况下，问题尺寸的增加应该引起任务数的增加而不是任务尺寸的增加。 通信功能分解决定了各个任务之间的数据流，各任务是并发执行的，通信则限制了这种并发性。 四种通信模式：局结态步 局部&#x2F;全局通信 局部通信是指通信限制在一个邻域内，只与较少的几个近邻通信。 全局通信是指许多任务参与的通信，例如星型，全相联的图。 结构化&#x2F;非结构化通信 结构化通信：每个任务的通信模式是相同的。 非结构化通信：每个任务的通信模式不同，无统一的结构。 静态&#x2F;动态通信 静态通信是指通信伙伴的身份不会随着时间的改变而改变的通信。 动态通信伙伴的身份由计算时的数据决定，并且是可变的。 同步&#x2F;异步通信 同步通信：双方知道何时进行通信，发送方显式地发给接收方 异步通信：接收方明确的从发送方请求数据。 了解通信的标准。 组合组合是抽象到具体的过程，使得任务在同一类并行机上有效地执行。 合并小尺寸的任务，减少任务数，如果任务数恰好等于处理器数量，也就完成了映射的过程。 通信量与任务子集的表面成正比，计算量与任务子集的体积成正比。 增加重复计算有可能减少通讯量。 映射每个任务需要映射到具体的处理器上，定位到运行机器上，存在负载均衡和任务调度的问题。实际上是一个NP完全问题。 映射的目标：减少算法的执行时间。主要有两点原则: 并发的任务：分配到不同的处理器 高通信的任务：分配到相同的处理器 负载均衡的算法： 矩阵乘法有三种并行算法，分别是简单分块算法、Cannons算法和DNS算法，主要学习Cannon矩阵乘法。 Cannon矩阵乘法 起始对准：A矩阵第i行左移i位（i从0开始），B矩阵第i列上移i位（i从0开始）。 循环位移：每次A向左移动，B向上移动一个单位，再做一次乘法然后相加。 OpenMP并行编程OpenMP是&#x3D;&#x3D;共享存储体系&#x3D;&#x3D;上的一个编程模型，应用于unix, Windows等多种平台上。OpenMP的API是基于&#x3D;&#x3D;编译制导&#x3D;&#x3D;，具备简单、移植性好和可扩展等优点，是共享存储系统编程（主要针对SMP平台）的一个工业标准。 编译制导（compiler directive）是一种特殊的注释或指令，用于指导编译器在源代码的编译过程中进行特定的处理或优化。 OpenMP使用FORK-JOIN并行执行模型，所有的OpenMP程序开始于一个单独的主线程，直到遇见第一个并行域，然后并行域中的代码在不同的线程组中并行执行(FORK)。当各个线程在并行域执行完成之后，最后只有主线程在执行(JOIN)。 OpenMP基本用法当计算机上安装了gcc之后，就可以直接开始OpenMP编程了。下面是一个hello_world代码示例： 12345678910111213141516# include &lt;omp.h&gt;# include &lt;stdio.h&gt;void main()&#123; int nthreads,tid; char buf[32]; /* 编译制导语句 */ # pragma omp parallel private(nthreads,tid) &#123; tid=omp_get_thread_num(); printf(&quot;Hello World from thread %d\\n&quot;,tid); if(tid==0)&#123; nthreads=omp_get_num_threads(); printf(&quot;Number of threads = %d\\n&quot;,nthreads); &#125; &#125;&#125; private(nthreads, tid): 这个子句定义了私有变量。在并行执行期间，每个线程都会拥有自己的私有副本。在这个例子中，nthreads和tid是私有变量,私有副本避免了竞争条件。其中由# pragma omp开头的语句就是编译制导语句，编译制导语句格式解释如下： 并行域的写法如下： 一个并行域就是一个能够被多个进程执行的程序块当一个线程运行到parallel的时候，会创建一个线程组并成为该组的主线程，tid为0。当并行域开始时，程序代码被复制，&#x3D;&#x3D;每个线程都会执行该代码&#x3D;&#x3D;。 并行的线程数按照如下因素决定，优先级递减： 使用库函数omp_set_num_threads 设置环境变量OPM_NUM_THREADS 由实现决定的默认值 共享任务结构共享任务结构将它所包含的代码划分给线程组内各个成员执行，不产生新的线程，在共享任务结构的入口处没有路障，但是在任务结束处有一个隐含的路障。共享任务结构有三种类型： for：线程组共享一个循环，表现出“数据并行性” sections：把任务分成离散段，每段由一个线程执行，表现“功能并行性” single：串行执行一段代码 for结构语句格式： schedule子句描述如何将循环的迭代划分给线程组中的线程。其参数type为static类型的时候，循环会被划分成大小为chunk的块，静态分配给各线程，若未指定chunk，则会被尽可能均衡地划分。 下面是一个使用for结构并行计算一个向量的案例： 123456789101112131415void main()&#123; int i; float a[N],b[N],c[N]; for(i=0;i&lt;N;i++) a[i]=b[i]=c[i]=i*1.0; // 使用for结构之前必须先初始化并行域 # pragma omp parallel shared(a,b,c) private(i) &#123; # pragma omp for schedule(dynamic,CHUNKSIZE) nowait for(i=0;i&lt;N;i++) c[i]=a[i]+b[i]; &#125; for(i=0;i&lt;N;i++) printf(&quot;%f\\n&quot;,c[i]);&#125; section结构sections编译制导语句是非迭代共享任务结构，指定内部的代码划分给线程组中的各线程。嵌套在sections语句中的每个section编译制导语句，由线程组中的一个线程执行。 语句格式： 使用两个section计算向量加法，分别计算前后半段。 1234567891011121314151617181920void main()&#123; int i; float a[N],b[N],c[N]; for(i=0;i&lt;N;i++) a[i]=b[i]=c[i]=i*1.0; # pragma omp parallel shared(a,b,c) private(i) &#123; # pragma omp sections nowait &#123; # pragma omp section for(i=0;i&lt;N/2;i++) a[i]=b[i]+c[i]; # pragma omp section for(i=N/2;i&lt;N;i++) a[i]=b[i]+c[i]; &#125; &#125; for(i=0;i&lt;N;i++) printf(&quot;%f\\n&quot;,a[i]);&#125; single结构single编译制导的语句制定内部的代码只有线程组中的一个线程执行，对于非线程安全的代码（比如输入&#x2F;输出），这个语句比较有用。除非是用了nowait语句，否则线程组中没有执行single语句的线程会一直等到代码块结束。 代码格式： parallel for创建一个并行域并包含一个for语句，也就是把parallel和for结合起来。 parallel section创建一个并行域并包含一个sections语句。 同步结构 master master语句指定的代码段将只由主线程执行，该线程组中的其他线程将忽略该代码段。 critical critical指定的代码段在同一时刻只能有一个线程执行。 barrier barrier语句用来同步线程组中的所有线程，在barrier语句处先到达的线程将会被阻塞，直到所有线程到达。 atomic 指定的存储单元将被原子地更新，而不允许多个线程同时执行更新操作。 flush 用于表示一个同步点，确保所有线程都看到一致的存储器视图。 ordered 被指定地代码段如同在船形的处理器上执行，任何时候只能有一个线程执行被ordered所限定的部分。只能出现在for中。 reduction 语法reduction([ reduction-modifier, ] reduction-identifier : list)。归约（reduction）操作用于将多个线程或进程计算得到的部分结果合并为一个最终结果，可以看成是一个不会丢失修改的多线程加法。 计算PI的openMP程序1234567891011121314151617181920212223242526272829303132333435static long steps = 1000000000;double step;int main (int argc, const char *argv[]) &#123; int i,j; double x; double pi, sum = 0.0; double start, delta; step = 1.0/(double) steps; // 从1到MAX_THREADS循环，每次循环设置线程数，计算PI值 for (j=1; j&lt;= MAX_THREADS; j++) &#123; printf(&quot; running on %d threads: &quot;, j); // 设置线程数 omp_set_num_threads(j); sum = 0.0; double start = omp_get_wtime(); /* reduction(+:sum)：变量sum被声明为共享变量，通过+操作符进行归约。 */ #pragma omp parallel for reduction(+:sum) private(x) for (i=0; i &lt; steps; i++) &#123; x = (i+0.5)*step; sum += 4.0 / (1.0+x*x); &#125; // 计算PI值 pi = step * sum; delta = omp_get_wtime() - start; printf(&quot;PI = %.16g computed in %.4g seconds\\n&quot;, pi, delta); &#125;&#125; MPI编程MPI(Message Passing Interface)是&#x3D;&#x3D;分布存储并行模型&#x3D;&#x3D;下的一个消息传递接口。MPI不是一个独立的自包含系统，而是建立在本地并行程序设计环境之上，进程管理和IO均由本地并行程序设计环境提供的。 安装、编译、运行安装：以Debian为例，使用apt安装 1apt install mpich 编译：使用mpicc编译 1mpicc -o out/$1 $1.c 运行：使用mpirun运行 1mpirun -np $2 out/$1 可用参数： -np：指定进程数 -host：指定主机列表 -npernode：每个计算节点的进程数 基本结构一个MPI程序有六个基本函数： MPI启动：调用该函数进入MPI环境，完成初始化工作。 1int MPI_Init(int *argc, char ***argv) MPI结束：调用该函数从MPI环境中退出，是MPI程序的最后一个调用。 1int MPI_Finalize(void) 获取进程编号：获取当前进程在指定通信域中的编号 1int MPI_Comm_rank(MPI_Comm comm, int *rank)// 结果存储在rank中，而不是返回值的int 获取进程数：获取指定通信域中的进程个数 1int MPI_Comm_size(MPI_Comm comm, int *size)// 结果存储在size中 消息发送：MPI_send函数用于发送一个消息到目标进程，将起始地址为buf的count个datatype类型的数据发送给目标进程。 1int MPI_Send(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) 消息接收：MPI_Recv用于接收数据，如果数据大于缓冲区，则会 1int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) MPI_Comm是MPI中表示通信域（communication domain）的数据类型。它用于定义进程之间的通信关系，指定通信操作的参与进程组。通信域可以是全局通信域(MPI_COMM_WORLD)或自定义的子通信域。通信域定义了一组进程，它们可以通过发送和接收消息进行相互通信。 MPI_Status是MPI中表示通信状态的数据类型。它用于在MPI通信操作中存储有关消息的信息，如发送者、接收者、消息长度等。定义如下，了解即可。 1234567typedef struct MPI_Status &#123; int count_lo; int count_hi_and_cancelled; int MPI_SOURCE; int MPI_TAG; int MPI_ERROR;&#125; MPI_Status; 一个MPI程序： 12345678910111213141516171819202122232425262728int main(int argc, char **argv)&#123; int rank, size, tag = 1; int sendData, recvData = 0; // MPI相关接口 MPI_Status status; MPI_Init(&amp;argc, &amp;argv); // MPI初始化 MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); // 该进程的编号 MPI_Comm_size(MPI_COMM_WORLD, &amp;size); // 总进程数目 if (rank == 0) &#123; sendData = 9999; // MPI发送信息 MPI_Send(&amp;sendData, 1, MPI_INT, 1, tag, MPI_COMM_WORLD); // 发送数据到进程1 printf(&quot;%d进程发送\\n&quot;, rank); &#125; else &#123; // MPI接收信息 MPI_Recv(&amp;recvData, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &amp;status); printf(&quot;%d进程接收到：%d\\n&quot;, rank, recvData); &#125; MPI_Finalize(); return 0;&#125; Docker和hadoopHadoop 是一个开源的分布式计算框架，它可以处理大规模数据集并将其分配到多台计算机上进行处理。Hadoop主要掌握两个核心组件、Map&#x2F;Reduce的思想。 Hadoop的两个核心，就是HDFS和MapReduce。HDFS为海量数据提供了存储，而MapReduce为海量数据提供了计算框架。 Hadoop的生态圈示意图如下： Map&#x2F;Reduce 整体结构： extends Mapper&lt;Object, Text, Text, IntWritable&gt;，四个范型参数是输入键、输入值、输出键、输出值。 重写void map(Object key, Text value, Context context)。 extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;，四个范型参数是输入键、输入值、输出键、输出值。 重写void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)。 两种数据类型： IntWritable整形，Text表示字符串，这两种数据结构可以放在context中。 处理逻辑： map函数 12345StringTokenizer itr = new StringTokenizer(value.toString());while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one);&#125; reduce函数 123456int sum = 0;for (IntWritable val : values) &#123; sum += val.get();&#125;result.set(sum);context.write(key, result); 主函数：JJ,MCR,KV,IO 123456789101112131415Configuration conf = new Configuration();Job job = Job.getInstance(conf, &quot;word count&quot;);job.setJarByClass(WordCount.class);job.setMapperClass(TokenizerMapper.class);job.setCombinerClass(IntSumReducer.class);job.setReducerClass(IntSumReducer.class);job.setOutputKeyClass(Text.class);job.setOutputValueClass(IntWritable.class);FileInputFormat.addInputPath(job, new Path(args[0]));FileOutputFormat.setOutputPath(job, new Path(args[1]));System.exit(job.waitForCompletion(true) ? 0 : 1); DockerDocker是开源的容器引擎。容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。 和虚拟机的区别： 部署速度、资源消耗、隔离性、部署管理 服务器虚拟化由多种技术架构，其中主要的四种如下：","content":"<h1 id=\"高性能计算与云计算\"><a href=\"#高性能计算与云计算\" class=\"headerlink\" title=\"高性能计算与云计算\"></a>高性能计算与云计算</h1><h2 id=\"互联网络\"><a href=\"#互联网络\" class=\"headerlink\" title=\"互联网络\"></a>互联网络</h2><p>互联网络分为静态互联网络和动态互联网络。</p>\n<p>静态网络是指各节点之间有固定连接的一类网络。程序执行期间，网络连接不改变。动态网络是用开关单元构成的，可以动态改变连接状态的网络。</p>\n<h3 id=\"静态互联网络的特征\"><a href=\"#静态互联网络的特征\" class=\"headerlink\" title=\"静态互联网络的特征\"></a>静态互联网络的特征</h3><ul>\n<li><p>网络规模：网络的节点个数</p>\n</li>\n<li><p>节点度数：单向网络中，入射和出射边之和称为节点度</p>\n</li>\n<li><p>网络直径：任意两个节点之间的最长距离</p>\n</li>\n<li><p>对剖宽度：将网络对分所必须移除的边的数目，如果是奇数个的话理解成可以把某个点切开，如二叉树，N&#x3D;3的线性阵列</p>\n</li>\n<li><p>对称：从任何一个节点观看网络都一样，称为对称。（有限个网络的场景，网孔、线性阵列是非对称的）</p>\n</li>\n</ul>\n<h3 id=\"静态互联网络特征比较\"><a href=\"#静态互联网络特征比较\" class=\"headerlink\" title=\"静态互联网络特征比较\"></a>静态互联网络特征比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">网络名</th>\n<th align=\"center\">网络规模</th>\n<th align=\"center\">节点度数</th>\n<th align=\"center\">网络直径</th>\n<th align=\"center\">对剖宽度</th>\n<th align=\"center\">对称</th>\n<th align=\"center\">链路数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">线性阵列</td>\n<td align=\"center\">N</td>\n<td align=\"center\">2</td>\n<td align=\"center\">N-1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">非</td>\n<td align=\"center\">N-1</td>\n</tr>\n<tr>\n<td align=\"center\">环形</td>\n<td align=\"center\">N</td>\n<td align=\"center\">2</td>\n<td align=\"center\">&#x3D;&#x3D;$\\lfloor N&#x2F;2 \\rfloor$&#x3D;&#x3D;</td>\n<td align=\"center\">2</td>\n<td align=\"center\">是</td>\n<td align=\"center\">N</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;&#x3D;2D网孔&#x3D;&#x3D;</td>\n<td align=\"center\">$N&#x3D;n^2$</td>\n<td align=\"center\">4</td>\n<td align=\"center\">&#x3D;&#x3D;2(n-1)&#x3D;&#x3D;</td>\n<td align=\"center\">n</td>\n<td align=\"center\">非</td>\n<td align=\"center\">&#x3D;&#x3D;$2(N-n)$&#x3D;&#x3D;先补再减</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;&#x3D;Illiac网孔&#x3D;&#x3D;</td>\n<td align=\"center\">$N&#x3D;n^2$</td>\n<td align=\"center\">4</td>\n<td align=\"center\">n-1</td>\n<td align=\"center\">2n</td>\n<td align=\"center\">非</td>\n<td align=\"center\">$2n$</td>\n</tr>\n<tr>\n<td align=\"center\">&#x3D;&#x3D;2D环绕&#x3D;&#x3D;</td>\n<td align=\"center\">$N&#x3D;n^2$</td>\n<td align=\"center\">4</td>\n<td align=\"center\">$2 \\lfloor n&#x2F;2 \\rfloor$</td>\n<td align=\"center\">2n</td>\n<td align=\"center\">是</td>\n<td align=\"center\">$2n$</td>\n</tr>\n<tr>\n<td align=\"center\">二叉树</td>\n<td align=\"center\">N</td>\n<td align=\"center\">3</td>\n<td align=\"center\">$2(\\lceil log_2N \\rceil-1)$</td>\n<td align=\"center\">1</td>\n<td align=\"center\">非</td>\n<td align=\"center\">N-1</td>\n</tr>\n<tr>\n<td align=\"center\">星型</td>\n<td align=\"center\">N</td>\n<td align=\"center\">n-1或1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">$\\lfloor N&#x2F;2 \\rfloor$</td>\n<td align=\"center\">非</td>\n<td align=\"center\">N-1</td>\n</tr>\n<tr>\n<td align=\"center\">超立方</td>\n<td align=\"center\">$N&#x3D;2^n$</td>\n<td align=\"center\">$log_2N&#x3D;n$</td>\n<td align=\"center\">n</td>\n<td align=\"center\">N&#x2F;2</td>\n<td align=\"center\">是</td>\n<td align=\"center\">nN&#x2F;2</td>\n</tr>\n<tr>\n<td align=\"center\">k-立方环</td>\n<td align=\"center\">$N&#x3D;k*2^k$</td>\n<td align=\"center\">3</td>\n<td align=\"center\">$2k-1+\\lfloor k&#x2F;2 \\rfloor$</td>\n<td align=\"center\">N&#x2F;(2k)</td>\n<td align=\"center\">是</td>\n<td align=\"center\">3N&#x2F;2</td>\n</tr>\n</tbody></table>\n<h2 id=\"并行计算的分类\"><a href=\"#并行计算的分类\" class=\"headerlink\" title=\"并行计算的分类\"></a>并行计算的分类</h2><h3 id=\"Flynn分类\"><a href=\"#Flynn分类\" class=\"headerlink\" title=\"Flynn分类\"></a>Flynn分类</h3><p>又叫指令流&#x2F;数据流分类法，即费林(Flynn)分类法。先来看一些概念：</p>\n<ul>\n<li>指令流：机器执行的指令序列</li>\n<li>数据流：指令调用的数据序列，包括输入数据、中间结果等</li>\n<li>多倍性：在系统性能平静部件上同时处于同一执行阶段的指令或数据的最大可能个数。</li>\n</ul>\n<p>于是，根据指令流和数据流的不同组织形式，将计算机系统分为四类：</p>\n<ul>\n<li>单指令单数据流（SISD）：硬件不支持任何形式的并行计算</li>\n<li>单指令多数据流（SIMD）：有多个处理单元，按照同一指令流的要求为他们<strong>分配各不相同的数据流</strong>并进行处理。</li>\n<li>多指令单数据流（MISD）：每个处理单元按照多条不同的指令要求<strong>同时对同一数据流作不同处理</strong>。</li>\n<li>多指令多数据流（MIMD）：能将指令，数据任务等全方面并行计算的系统，将主任务分解成众多子任务以缩短时间。</li>\n</ul>\n<h3 id=\"MIMD计算机细分\"><a href=\"#MIMD计算机细分\" class=\"headerlink\" title=\"MIMD计算机细分\"></a>MIMD计算机细分</h3><p>MIMD计算机的主要分类如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272020214.webp\" alt=\"image-20231227202042036\"></p>\n<p>共享内存和分布式内存的系统架构如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271451425.webp\" alt=\"image-20231227145130232\"></p>\n<p>共享内存的工作原理：具有一个所有处理器都可以访问的全局物理内存，具备有如下性质：</p>\n<ol>\n<li>对称性：系统中的任何处理器等效访问内存和IO</li>\n<li>单地址：内存中的每个位置都有唯一地址值</li>\n<li>低通信延迟：处理器之间的通信可以利用共享内存来交换数据</li>\n<li>高速缓存及其一致性：多级缓存可以提高速度，&#x3D;&#x3D;一致性由硬件来增强(?)&#x3D;&#x3D;</li>\n</ol>\n<p>两种模型的分类大致如下，下面将会详细介绍这五种内存访问模型：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271721645.webp\" alt=\"image-20231227172148509\"></p>\n<h4 id=\"并行计算机五种访存模型\"><a href=\"#并行计算机五种访存模型\" class=\"headerlink\" title=\"并行计算机五种访存模型\"></a>并行计算机五种访存模型</h4><p>并行计算机访存模型主要有以下五种：</p>\n<ul>\n<li>UMA(Uniform Memory Access)：均匀存储访问模型</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271513171.webp\" alt=\"image-20231227151312065\"></p>\n<p>共享内存属于一种经典的均匀访问模型。主要特点：**对称多处理(Symmetric Multiprocessing, SMP)**，使用的是微处理器和高速缓存。每台处理器可以带有私有的Cache，外围设备也可以共享。发生访存竞争的时候，仲裁策略对所有节点平等。所以叫做均匀存储访问模型。（就是计算机组成中的经典模型）</p>\n<blockquote>\n<p>在SMP中，内存模块和处理器对称地分布在互联网络的两侧。并且只有单一的操作系统镜像，负责处理各个处理器的负载，动态将进程分配到不同的处理器，保持各处理器之间的负载平衡。</p>\n</blockquote>\n<ul>\n<li>NUMA(Non-Uniform Memory Access)：非均匀存储访问模型</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271528446.webp\" alt=\"image-20231227152813342\"></p>\n<p>被共享的存储器在物理上是分布存储在所有处理器中的，其所有本地存储器的集合就组成了全局地址空间。处理器访问存储器的时间是不一样的。</p>\n<blockquote>\n<p>存储器的访问时间是指从发起访问请求到数据可用的时间间隔。简单理解就是，处理器访问离自己比较近的内存速度比其他内存更快。</p>\n</blockquote>\n<p>如果缓存一致性能够得到维护，那么就可以成为CC-NUMA，否则成为NCC-NUMA。</p>\n<ul>\n<li>CC-NUMA(Coherent-Cache Nonuniform Memory Access)：高速缓存一致性 非均匀存储访问模型</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271606334.webp\" alt=\"image-20231227160607209\"></p>\n<p>CC-NUMA使用基于目录的高速缓存一致性协议；保留了SMP结构易于编程的优点，改善常规SMP的可扩放性。实际上是一个分布式共享存储的DSM多处理机系统，最显著的优点是程序员无需明确在节点上分配数据，在运行期间，高速缓存一致性硬件会自动将数据迁移到需要用到的地方。</p>\n<ul>\n<li>COMA(Cache-Only Memory Access)：全高速缓存存储访问</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271618283.webp\" alt=\"image-20231227161837118\"></p>\n<p>COMA各个处理器节点&#x3D;&#x3D;没有存储层次结构&#x3D;&#x3D;。对比NUMA和CC-NUMA，发现：COMA只有cache，NUMA只有memory，CC-NUMA二者兼有，而UMA则是将内存连接在总线上的。</p>\n<ul>\n<li>NORMA(No-Remote Memory Access)：非远程存储访问模型。属于分布式内存模型。</li>\n</ul>\n<p>架构图如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271625818.webp\" alt=\"image-20231227162538671\"></p>\n<p>优点：内存可以随着CPU的数量进行等比例扩展；各个处理器可以无冲突地快速访问自己的内存，不存在维护缓存一致性的开销；可以使用商用、现成的处理器和网络。</p>\n<p>局限性：程序员要负责所有处理器之间的数据通信细节问题；很难从基于全局内存空间建立其分布式内存管理的映射，写一个程序有一个全局的地址空间，程序员需要建立全局地址空间到分布式内存的管理，也就是解决什么数据去哪里取的问题；非一致性的内存访问时间使远程节点访问比本地节点访问需要更长的时间。</p>\n<h4 id=\"大规模并行处理机-Massively-Parallel-Processor-MPP\"><a href=\"#大规模并行处理机-Massively-Parallel-Processor-MPP\" class=\"headerlink\" title=\"大规模并行处理机(Massively Parallel Processor, MPP)\"></a>大规模并行处理机(Massively Parallel Processor, MPP)</h4><p>由大规模的紧密互联的节点组成，内存访问属于非远程存储访问模型(NORMA)，也就是属于分布式存储系统。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271952272.webp\" alt=\"image-20231227195214091\"></p>\n<p>每个节点配有局部cache，并通过局部总线与局部内存、局部IO相连，通过互联网络与IO相连。各节点之间的内存模块相互独立，且不存在全局内存单元的统一硬件编址。</p>\n<p>每个节点都有不同的操作系统映像。</p>\n<p>仅支持消息传递等程序设计（如MPI），不支持全局共享的OpenMP并行程序设计模式。</p>\n<h4 id=\"集群（机群）\"><a href=\"#集群（机群）\" class=\"headerlink\" title=\"集群（机群）\"></a>集群（机群）</h4><p>集群是一种松耦合的计算机组成方式，采用分布式存储，每一个节点是完整的计算机。</p>\n<p>集群的优点是：投资风险小、系统结构灵活、能充分利用分散的计算资源</p>\n<p>集群的缺点是：通信性能和并行编程环境不佳</p>\n<p>和MPP的比较如下图，左边是MPP，右边是Cluster，重点关注：有无磁盘、总线类型</p>\n<p>Cluster有磁盘，MPP没有；Cluster各点连接在IO总线(IOB)上，而MPP各点连接在存储总线MB上。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312271959198.webp\" alt=\"image-20231227195911973\"></p>\n<h4 id=\"DSM-Distributed-Shared-Memory\"><a href=\"#DSM-Distributed-Shared-Memory\" class=\"headerlink\" title=\"DSM(Distributed Shared Memory)\"></a>DSM(Distributed Shared Memory)</h4><p>属于非一致性内存访问模型(NUMA)，<strong>内存模块放在各个节点的内部，并且被所有节点共享</strong>。这样，可以较好改善多处理共享存储并行机的可扩展能力。</p>\n<p>节点之间通过高性能互联网络连接，内存模块分布在各节点中，避免了SMP中的访问总线的带宽瓶颈。具有单一的内存地址空间（硬件统一编址，各个节点可以相互访问）。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272012397.webp\" alt=\"image-20231227201214227\"></p>\n<p><code>注意和MPP对比，多了一个DIR：Cache Directory。</code></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>各种访存模型：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272020214.webp\" alt=\"image-20231227202042036\"></p>\n<p>五种结构特性：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312272022765.webp\" alt=\"image-20231227202227550\"></p>\n<h2 id=\"并行计算模型-LogP重点\"><a href=\"#并行计算模型-LogP重点\" class=\"headerlink\" title=\"并行计算模型(LogP重点)\"></a>并行计算模型(LogP重点)</h2><p>将并行计算机的基本特征抽象出来，形成一个抽象的计算模型，作为并行算法分析、设计和性能预测的基础。</p>\n<p>主要的并行计算模型有：PRAM模型、BSP模型和logP模型。</p>\n<ul>\n<li><strong>PRAM模型</strong>：又称SIMD-SM模型，有一个集中的共享存储器和一个指令器，通过SM的R&#x2F;W交换数据，隐式同步计算。模型的架构图如下：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281427027.webp\" alt=\"image-20231228142714882\"></p>\n<p>优点是适合并行算法的表示和复杂性分析，易于使用，隐藏了并行机的通讯、同步等区别。</p>\n<p>缺点是不适合MIMD并行机，忽略了SM的竞争、通讯延迟等因素。</p>\n<ul>\n<li><strong>BSP模型</strong></li>\n</ul>\n<p>“块”同步模型，异步MIMD-DM模型，支持消息传递系统，块内异步并行，块间显式同步。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281435932.webp\" alt=\"image-20231228143521823\"></p>\n<ul>\n<li><strong>LogP模型（重点掌握）</strong></li>\n</ul>\n<p>一种分布存储的、点到点通讯的多处理机模型，其中通讯由一组参数描述，实行隐式同步。</p>\n<p>模型参数：</p>\n<ol>\n<li>L: latency网络延迟</li>\n<li>o: 接收和发送时间</li>\n<li>g: gap&#x3D;1&#x2F;bandwidth，两个连续通信的最小间隔</li>\n<li>P: 处理器数量</li>\n</ol>\n<p>前面三个都是表示时间的参数，它们之间的关系如下图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281441216.webp\" alt=\"image-20231228144121112\"></p>\n<p>点到点通信事件：L+2o</p>\n<p>读取远程地址：2L+4o</p>\n<h2 id=\"性能评测\"><a href=\"#性能评测\" class=\"headerlink\" title=\"性能评测\"></a>性能评测</h2><h3 id=\"算法性能评测\"><a href=\"#算法性能评测\" class=\"headerlink\" title=\"算法性能评测\"></a>算法性能评测</h3><ul>\n<li><p>加速比：$S_p&#x3D;\\dfrac{串行执行时间}{并行执行时间}$</p>\n</li>\n<li><p>并行效率：$E&#x3D;\\dfrac{加速比}{核数}$</p>\n</li>\n</ul>\n<p>由于通信等因素，一般来说并行效率不会超过1。如果超过了1，那就是超线性加速比。那么什么时候会出现超线性加速比呢？</p>\n<p>可能出现超线性加速比的成因主要是不同处理器的高速缓存足以提供计算需要的存储量，属于硬件特性。</p>\n<p>不同约束条件下的加速比：</p>\n<ol>\n<li>固定问题规模</li>\n<li>固定时间</li>\n<li>固定存储</li>\n</ol>\n<h3 id=\"Amdahl定律\"><a href=\"#Amdahl定律\" class=\"headerlink\" title=\"Amdahl定律\"></a>Amdahl定律</h3><p><strong>描述了规模固定的加速比。</strong></p>\n<p>该定律指出，系统中对于某一部件采用更快的执行方式所能获得的性能改进程度，取决于这种执行方式被使用的频率。</p>\n<p>$W_s$是串行化部分运行的时间，$W_p$是并行化部分采用串行化的方法需要的时间。<strong>f是使用串行化的任务占比</strong>，p是并行核数。</p>\n<p>$S_{pc}&#x3D;\\dfrac{优化前耗时}{优化后耗时}&#x3D;\\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}&#x3D;\\dfrac{f+(1-f)}{f+\\frac{1-f}{p}}&#x3D;\\dfrac{p}{1+f(p-1)}$，当p-&gt;$\\infin$时，等于$1&#x2F;f$。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281607856.webp\" alt=\"image-20231228160723744\"></p>\n<p>例如，上图中，f&#x3D;1&#x2F;3，p&#x3D;2，那么加速比就是：Spc&#x3D;6&#x2F;5，也就是300&#x2F;250。</p>\n<p>增强的Amdahl定律，考虑了并行和通信的开销，推导式如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312281628586.webp\" alt=\"image-20231228162841483\"></p>\n<p>所以，Amdahl定律用一句话总结就是：&#x3D;&#x3D;并行计算模型的加速比不会超过串行化占比的倒数&#x3D;&#x3D;。</p>\n<h3 id=\"Gustafson定律\"><a href=\"#Gustafson定律\" class=\"headerlink\" title=\"Gustafson定律\"></a>Gustafson定律</h3><p>描述了时间固定的加速比。</p>\n<p>Gustafson定律也表明处理器个数、并行比例和加速比之间的关系。它描述了，<strong>在串行部分比例固定的前提下，加速比会随着处理器个数增加而增加</strong>。</p>\n<p>见公式Amdahl推导式的$\\dfrac{W_s+W_p}{W_s+W_p&#x2F;p}$，当p变大的时候，加速比自然变大，但是有渐近线逼近。</p>\n<p>考虑到并行开销的Gustafson定律，了解即可。</p>\n<h3 id=\"Sun-Ni定律\"><a href=\"#Sun-Ni定律\" class=\"headerlink\" title=\"Sun&amp;Ni定律\"></a>Sun&amp;Ni定律</h3><p>描述了存储受限的加速比。</p>\n<p>推导公式：$\\begin{aligned}S_{MC}&#x3D;\\frac{Work(p)&#x2F;Time(p)}{Work(l)&#x2F;Time(l)}&#x3D;\\frac{fW+(1-f)G(p)W}{fW+(1-f)G(p)W&#x2F;p}&#x3D;\\frac{f+(1-f)G(p)}{f+(1-f)G(p)&#x2F;p}\\end{aligned}$</p>\n<p>当G(p)&#x3D;1的时候就是Amdahl加速定律，G(p)&#x3D;p时变为f+p(1-f)，就是Gustafson加速定律。</p>\n<h3 id=\"可扩展性评测标准\"><a href=\"#可扩展性评测标准\" class=\"headerlink\" title=\"可扩展性评测标准\"></a>可扩展性评测标准</h3><p>增加系统规模（处理器个数）会增大额外开销和降低处理器利用率，所以对于一个特定的并行处理系统（算法或程序），它们能否有效利用不断增加的处理器的能力应是受限的，而度量这种能力的就是可扩展性这一指标。可扩展性更关心在&#x3D;&#x3D;系统规模和数据规模&#x3D;&#x3D;变化时的&#x3D;&#x3D;执行时间&#x3D;&#x3D;，是{性能、系统规模、数据规模}的综合量度。</p>\n<p>可扩展性的三种量化方式：</p>\n<ul>\n<li>等效率&#x3D;$\\dfrac{加速比}{处理器数}$，分析简单</li>\n<li>等速度：每秒处理的数据量，便于通过实验数据得到结果。</li>\n<li>平均时延：理想并行时间和实际并行时间的差距，便于通过实验数据得到结果。</li>\n</ul>\n<h4 id=\"等效率函数\"><a href=\"#等效率函数\" class=\"headerlink\" title=\"等效率函数\"></a>等效率函数</h4><p>考虑有并行开销的并行效率，加速比$\\begin{aligned}S&#x3D;\\dfrac{T_e}{T_p}&#x3D;\\dfrac{T_e}{\\dfrac{T_e+T_o}p}&#x3D;\\dfrac{P}{1+\\dfrac{T_o}{T_e}}&#x3D;\\dfrac{P}{1+\\dfrac{W_o}W}\\end{aligned}$，等效率：$\\begin{aligned}E&#x3D;\\frac{S}{P}&#x3D;\\frac{1}{1+\\dfrac{T_o}{T_e}}&#x3D;\\frac{1}{1+\\dfrac{W_o}{W}}\\end{aligned}$。</p>\n<p>如果保持问题规模W不变，处理器数目p增加，开销$T_o$增大，$W_o$增大，效率E下降。为了维持等效率，在增加处理器的时候，问题规模W也应该增大。</p>\n<p>下图是等效率曲线。曲线1表示可扩放性较好，曲线2表示算法可以扩放，曲线3表示算法不可扩放。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291508752.webp\" alt=\"image-20231229150855542\"></p>\n<p>按照等效率函数的定义，对于某一并行算法(或并行程序),为了维持运行效率保持不变，随着处理器数目的增加，若只需增加较小的工作量(即问题规模),比如说$W$随$P$呈线性或亚线性增长，则表示该算法具有良好的可扩放性；若需增加非常大的问题规模，比如说$W$随$P$呈指数级增长，则表示该算法是不可扩放的。</p>\n<h2 id=\"PCAM设计方法学\"><a href=\"#PCAM设计方法学\" class=\"headerlink\" title=\"PCAM设计方法学\"></a>PCAM设计方法学</h2><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312291902876.webp\" alt=\"image-20231229190206700\"></p>\n<h3 id=\"划分\"><a href=\"#划分\" class=\"headerlink\" title=\"划分\"></a>划分</h3><p>划分可以分为两类划分：<strong>域分解（数据分解）和功能分解</strong>。域分解划分的是数据，功能分解划分的是计算。</p>\n<p>划分之后，研究不同任务所需要的数据。如果这些数据不相交，则划分是成功的，否则需要重新进行域分解。</p>\n<p>划分的标准：</p>\n<ul>\n<li>划分的任务数，是否至少高于目标机上处理器数量一个量级。（灵活性）若否，则后续的设计步骤缺少灵活性。</li>\n<li>是否避免冗余的计算和存储要求（可扩放性）若否，算法的扩放性较差。</li>\n<li>划分的任务尺寸是否大致相当（均衡）若否，分配处理器时难以做到工作量均衡。</li>\n<li>任务数是否与问题尺寸成正比，理想情况下，问题尺寸的增加应该引起任务数的增加而不是任务尺寸的增加。</li>\n</ul>\n<h3 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h3><p>功能分解决定了各个任务之间的数据流，各任务是并发执行的，通信则限制了这种并发性。</p>\n<p>四种通信模式：<strong>局结态步</strong></p>\n<ul>\n<li>局部&#x2F;全局通信</li>\n</ul>\n<p>局部通信是指通信限制在一个邻域内，只与较少的几个近邻通信。</p>\n<p>全局通信是指许多任务参与的通信，例如星型，全相联的图。</p>\n<ul>\n<li>结构化&#x2F;非结构化通信</li>\n</ul>\n<p>结构化通信：每个任务的通信模式是相同的。</p>\n<p>非结构化通信：每个任务的通信模式不同，无统一的结构。</p>\n<ul>\n<li>静态&#x2F;动态通信</li>\n</ul>\n<p>静态通信是指通信伙伴的身份不会随着时间的改变而改变的通信。</p>\n<p>动态通信伙伴的身份由计算时的数据决定，并且是可变的。</p>\n<ul>\n<li>同步&#x2F;异步通信</li>\n</ul>\n<p>同步通信：双方知道何时进行通信，发送方显式地发给接收方</p>\n<p>异步通信：接收方明确的从发送方请求数据。</p>\n<p>了解通信的标准。</p>\n<h3 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h3><p>组合是抽象到具体的过程，使得任务在同一类并行机上有效地执行。</p>\n<p>合并小尺寸的任务，减少任务数，如果任务数恰好等于处理器数量，也就完成了映射的过程。</p>\n<blockquote>\n<p>通信量与任务子集的表面成正比，计算量与任务子集的体积成正比。</p>\n</blockquote>\n<p>增加重复计算有可能减少通讯量。</p>\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>每个任务需要映射到具体的处理器上，定位到运行机器上，存在负载均衡和任务调度的问题。实际上是一个NP完全问题。</p>\n<p>映射的目标：减少算法的执行时间。主要有两点原则:</p>\n<ol>\n<li>并发的任务：分配到不同的处理器</li>\n<li>高通信的任务：分配到相同的处理器</li>\n</ol>\n<ul>\n<li>负载均衡的算法：</li>\n</ul>\n<h2 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h2><p>有三种并行算法，分别是简单分块算法、Cannons算法和DNS算法，主要学习Cannon矩阵乘法。</p>\n<h3 id=\"Cannon矩阵乘法\"><a href=\"#Cannon矩阵乘法\" class=\"headerlink\" title=\"Cannon矩阵乘法\"></a>Cannon矩阵乘法</h3><ul>\n<li><p>起始对准：A矩阵第i行左移i位（i从0开始），B矩阵第i列上移i位（i从0开始）。</p>\n</li>\n<li><p>循环位移：每次A向左移动，B向上移动一个单位，再做一次乘法然后相加。</p>\n</li>\n</ul>\n<h2 id=\"OpenMP并行编程\"><a href=\"#OpenMP并行编程\" class=\"headerlink\" title=\"OpenMP并行编程\"></a>OpenMP并行编程</h2><p>OpenMP是&#x3D;&#x3D;共享存储体系&#x3D;&#x3D;上的一个编程模型，应用于unix, Windows等多种平台上。OpenMP的API是基于&#x3D;&#x3D;编译制导&#x3D;&#x3D;，具备简单、移植性好和可扩展等优点，是共享存储系统编程（主要针对SMP平台）的一个工业标准。</p>\n<blockquote>\n<p>编译制导（compiler directive）是一种特殊的注释或指令，用于指导编译器在源代码的编译过程中进行特定的处理或优化。</p>\n</blockquote>\n<p>OpenMP使用FORK-JOIN并行执行模型，所有的OpenMP程序开始于一个单独的主线程，直到遇见第一个并行域，然后并行域中的代码在不同的线程组中并行执行(FORK)。当各个线程在并行域执行完成之后，最后只有主线程在执行(JOIN)。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301611127.webp\" alt=\"image-20231230161102974\"></p>\n<h3 id=\"OpenMP基本用法\"><a href=\"#OpenMP基本用法\" class=\"headerlink\" title=\"OpenMP基本用法\"></a>OpenMP基本用法</h3><p>当计算机上安装了gcc之后，就可以直接开始OpenMP编程了。下面是一个hello_world代码示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;omp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> nthreads,tid;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"comment\">/* 编译制导语句 */</span></span><br><span class=\"line\">    <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp parallel private(nthreads,tid)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tid=omp_get_thread_num();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World from thread %d\\n&quot;</span>,tid);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tid==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            nthreads=omp_get_num_threads();</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Number of threads = %d\\n&quot;</span>,nthreads);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>private(nthreads, tid)</code>: 这个子句定义了私有变量。在并行执行期间，每个线程都会拥有自己的私有副本。在这个例子中，<code>nthreads</code>和<code>tid</code>是私有变量,私有副本避免了竞争条件。其中由<code># pragma omp</code>开头的语句就是编译制导语句，编译制导语句格式解释如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301635717.webp\" alt=\"image-20231230163502200\"></p>\n<p>并行域的写法如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301641289.webp\" alt=\"image-20231230164110177\"></p>\n<p>一个并行域就是一个能够被多个进程执行的程序块当一个线程运行到parallel的时候，会创建一个线程组并成为该组的主线程，tid为0。当并行域开始时，程序代码被复制，&#x3D;&#x3D;每个线程都会执行该代码&#x3D;&#x3D;。</p>\n<p>并行的线程数按照如下因素决定，优先级递减：</p>\n<ol>\n<li>使用库函数omp_set_num_threads</li>\n<li>设置环境变量OPM_NUM_THREADS</li>\n<li>由实现决定的默认值</li>\n</ol>\n<h3 id=\"共享任务结构\"><a href=\"#共享任务结构\" class=\"headerlink\" title=\"共享任务结构\"></a>共享任务结构</h3><p>共享任务结构将它所包含的代码划分给线程组内各个成员执行，不产生新的线程，在共享任务结构的入口处没有路障，但是在任务结束处有一个隐含的路障。共享任务结构有三种类型：</p>\n<ol>\n<li>for：线程组共享一个循环，表现出“数据并行性”</li>\n<li>sections：把任务分成离散段，每段由一个线程执行，表现“功能并行性”</li>\n<li>single：串行执行一段代码</li>\n</ol>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301657319.webp\" alt=\"image-20231230165746202\"></p>\n<h4 id=\"for结构\"><a href=\"#for结构\" class=\"headerlink\" title=\"for结构\"></a>for结构</h4><p>语句格式：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301700572.webp\" alt=\"image-20231230170039469\"></p>\n<p>schedule子句描述如何将循环的迭代划分给线程组中的线程。其参数type为static类型的时候，循环会被划分成大小为chunk的块，静态分配给各线程，若未指定chunk，则会被尽可能均衡地划分。</p>\n<p>下面是一个使用for结构并行计算一个向量的案例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> a[N],b[N],c[N];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">        a[i]=b[i]=c[i]=i*<span class=\"number\">1.0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 使用for结构之前必须先初始化并行域</span></span><br><span class=\"line\">    <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp parallel shared(a,b,c) private(i)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp for schedule(dynamic,CHUNKSIZE) nowait</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">            c[i]=a[i]+b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f\\n&quot;</span>,c[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"section结构\"><a href=\"#section结构\" class=\"headerlink\" title=\"section结构\"></a>section结构</h4><p>sections编译制导语句是非迭代共享任务结构，指定内部的代码划分给线程组中的各线程。嵌套在sections语句中的每个section编译制导语句，由线程组中的一个线程执行。</p>\n<p>语句格式：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301737971.webp\" alt=\"image-20231230173719857\"></p>\n<p>使用两个section计算向量加法，分别计算前后半段。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">float</span> a[N],b[N],c[N];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">        a[i]=b[i]=c[i]=i*<span class=\"number\">1.0</span>;</span><br><span class=\"line\">    <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp parallel shared(a,b,c) private(i)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp sections nowait</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp section</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N/<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">                a[i]=b[i]+c[i];</span><br><span class=\"line\">            <span class=\"meta\"># <span class=\"keyword\">pragma</span> omp section</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=N/<span class=\"number\">2</span>;i&lt;N;i++)</span><br><span class=\"line\">                a[i]=b[i]+c[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f\\n&quot;</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"single结构\"><a href=\"#single结构\" class=\"headerlink\" title=\"single结构\"></a>single结构</h4><p>single编译制导的语句制定内部的代码只有线程组中的一个线程执行，对于非线程安全的代码（比如输入&#x2F;输出），这个语句比较有用。除非是用了nowait语句，否则线程组中没有执行single语句的线程会一直等到代码块结束。</p>\n<p>代码格式：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312301747222.webp\" alt=\"image-20231230174735115\"></p>\n<h4 id=\"parallel-for\"><a href=\"#parallel-for\" class=\"headerlink\" title=\"parallel for\"></a>parallel for</h4><p>创建一个并行域并包含一个for语句，也就是把parallel和for结合起来。</p>\n<h4 id=\"parallel-section\"><a href=\"#parallel-section\" class=\"headerlink\" title=\"parallel section\"></a>parallel section</h4><p>创建一个并行域并包含一个sections语句。</p>\n<h3 id=\"同步结构\"><a href=\"#同步结构\" class=\"headerlink\" title=\"同步结构\"></a>同步结构</h3><ul>\n<li>master</li>\n</ul>\n<p>master语句指定的代码段将只由主线程执行，该线程组中的其他线程将忽略该代码段。</p>\n<ul>\n<li>critical</li>\n</ul>\n<p>critical指定的代码段在同一时刻只能有一个线程执行。</p>\n<ul>\n<li>barrier</li>\n</ul>\n<p>barrier语句用来同步线程组中的所有线程，在barrier语句处先到达的线程将会被阻塞，直到所有线程到达。</p>\n<ul>\n<li>atomic</li>\n</ul>\n<p>指定的存储单元将被原子地更新，而不允许多个线程同时执行更新操作。</p>\n<ul>\n<li>flush</li>\n</ul>\n<p>用于表示一个同步点，确保所有线程都看到一致的存储器视图。</p>\n<ul>\n<li>ordered</li>\n</ul>\n<p>被指定地代码段如同在船形的处理器上执行，任何时候只能有一个线程执行被ordered所限定的部分。只能出现在for中。</p>\n<ul>\n<li>reduction</li>\n</ul>\n<p>语法<code>reduction([ reduction-modifier, ] reduction-identifier : list)</code>。归约（reduction）操作用于将多个线程或进程计算得到的部分结果合并为一个最终结果，可以看成是一个不会丢失修改的多线程加法。</p>\n<h3 id=\"计算PI的openMP程序\"><a href=\"#计算PI的openMP程序\" class=\"headerlink\" title=\"计算PI的openMP程序\"></a>计算PI的openMP程序</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">long</span> steps = <span class=\"number\">1000000000</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> step;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span> <span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"type\">double</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> pi, sum = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> start, delta;</span><br><span class=\"line\">    step = <span class=\"number\">1.0</span>/(<span class=\"type\">double</span>) steps;</span><br><span class=\"line\">    <span class=\"comment\">// 从1到MAX_THREADS循环，每次循环设置线程数，计算PI值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j=<span class=\"number\">1</span>; j&lt;= MAX_THREADS; j++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; running on %d threads: &quot;</span>, j);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置线程数</span></span><br><span class=\"line\">        omp_set_num_threads(j);</span><br><span class=\"line\"></span><br><span class=\"line\">        sum = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        <span class=\"type\">double</span> start = omp_get_wtime();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        reduction(+:sum)：变量sum被声明为共享变量，通过+操作符进行归约。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">pragma</span> omp parallel for reduction(+:sum) private(x)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; steps; i++) &#123;</span><br><span class=\"line\">            x = (i+<span class=\"number\">0.5</span>)*step;</span><br><span class=\"line\">            sum += <span class=\"number\">4.0</span> / (<span class=\"number\">1.0</span>+x*x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算PI值</span></span><br><span class=\"line\">        pi = step * sum;</span><br><span class=\"line\">        delta = omp_get_wtime() - start;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;PI = %.16g computed in %.4g seconds\\n&quot;</span>, pi, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MPI编程\"><a href=\"#MPI编程\" class=\"headerlink\" title=\"MPI编程\"></a>MPI编程</h2><p>MPI(Message Passing Interface)是&#x3D;&#x3D;分布存储并行模型&#x3D;&#x3D;下的一个消息传递接口。MPI不是一个独立的自包含系统，而是建立在本地并行程序设计环境之上，进程管理和IO均由本地并行程序设计环境提供的。</p>\n<h3 id=\"安装、编译、运行\"><a href=\"#安装、编译、运行\" class=\"headerlink\" title=\"安装、编译、运行\"></a>安装、编译、运行</h3><p>安装：以Debian为例，使用apt安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install mpich</span><br></pre></td></tr></table></figure>\n\n<p>编译：使用mpicc编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpicc -o out/$1 $1.c</span><br></pre></td></tr></table></figure>\n\n<p>运行：使用mpirun运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpirun -np $2 out/$1</span><br></pre></td></tr></table></figure>\n\n<p>可用参数：</p>\n<p>-np：指定进程数</p>\n<p>-host：指定主机列表</p>\n<p>-npernode：每个计算节点的进程数</p>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>一个MPI程序有六个基本函数：</p>\n<ul>\n<li>MPI启动：调用该函数进入MPI环境，完成初始化工作。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Init</span><span class=\"params\">(<span class=\"type\">int</span> *argc, <span class=\"type\">char</span> ***argv)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>MPI结束：调用该函数从MPI环境中退出，是MPI程序的最后一个调用。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Finalize</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取进程编号：获取当前进程在指定通信域中的编号</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Comm_rank</span><span class=\"params\">(MPI_Comm comm, <span class=\"type\">int</span> *rank)</span><span class=\"comment\">// 结果存储在rank中，而不是返回值的int</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取进程数：获取指定通信域中的进程个数</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Comm_size</span><span class=\"params\">(MPI_Comm comm, <span class=\"type\">int</span> *size)</span><span class=\"comment\">// 结果存储在size中</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>消息发送：MPI_send函数用于发送一个消息到目标进程，将起始地址为buf的count个datatype类型的数据发送给目标进程。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Send</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span> *buf, <span class=\"type\">int</span> count, MPI_Datatype datatype, <span class=\"type\">int</span> dest, <span class=\"type\">int</span> tag, MPI_Comm comm)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>消息接收：MPI_Recv用于接收数据，如果数据大于缓冲区，则会</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">MPI_Recv</span><span class=\"params\">(<span class=\"type\">void</span> *buf, <span class=\"type\">int</span> count, MPI_Datatype datatype, <span class=\"type\">int</span> source, <span class=\"type\">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span><br></pre></td></tr></table></figure>\n\n<p>MPI_Comm是MPI中表示通信域（communication domain）的数据类型。它用于定义进程之间的通信关系，指定通信操作的参与进程组。通信域可以是全局通信域(MPI_COMM_WORLD)或自定义的子通信域。通信域定义了一组进程，它们可以通过发送和接收消息进行相互通信。</p>\n<p>MPI_Status是MPI中表示通信状态的数据类型。它用于在MPI通信操作中存储有关消息的信息，如发送者、接收者、消息长度等。定义如下，了解即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MPI_Status</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count_lo;</span><br><span class=\"line\">    <span class=\"type\">int</span> count_hi_and_cancelled;</span><br><span class=\"line\">    <span class=\"type\">int</span> MPI_SOURCE;</span><br><span class=\"line\">    <span class=\"type\">int</span> MPI_TAG;</span><br><span class=\"line\">    <span class=\"type\">int</span> MPI_ERROR;</span><br><span class=\"line\">&#125; MPI_Status;</span><br></pre></td></tr></table></figure>\n\n<p>一个MPI程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rank, size, tag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> sendData, recvData = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MPI相关接口</span></span><br><span class=\"line\">    MPI_Status status;</span><br><span class=\"line\">    MPI_Init(&amp;argc, &amp;argv);               <span class=\"comment\">// MPI初始化</span></span><br><span class=\"line\">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); <span class=\"comment\">// 该进程的编号</span></span><br><span class=\"line\">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size); <span class=\"comment\">// 总进程数目</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sendData = <span class=\"number\">9999</span>;</span><br><span class=\"line\">        <span class=\"comment\">// MPI发送信息</span></span><br><span class=\"line\">        MPI_Send(&amp;sendData, <span class=\"number\">1</span>, MPI_INT, <span class=\"number\">1</span>, tag, MPI_COMM_WORLD); <span class=\"comment\">// 发送数据到进程1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d进程发送\\n&quot;</span>, rank);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// MPI接收信息</span></span><br><span class=\"line\">        MPI_Recv(&amp;recvData, <span class=\"number\">1</span>, MPI_INT, <span class=\"number\">0</span>, tag, MPI_COMM_WORLD, &amp;status);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d进程接收到：%d\\n&quot;</span>, rank, recvData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MPI_Finalize();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker和hadoop\"><a href=\"#Docker和hadoop\" class=\"headerlink\" title=\"Docker和hadoop\"></a>Docker和hadoop</h2><p><strong>Hadoop</strong> 是一个开源的分布式计算框架，它可以处理大规模数据集并将其分配到多台计算机上进行处理。Hadoop主要掌握两个核心组件、Map&#x2F;Reduce的思想。</p>\n<p>Hadoop的两个核心，就是HDFS和MapReduce。HDFS为海量数据提供了<strong>存储</strong>，而MapReduce为海量数据提供了<strong>计算框架</strong>。</p>\n<p>Hadoop的生态圈示意图如下：</p>\n<img src=\"https://www.eduxiji.net/assets/files/2020-04-30/1588236269-937828-hadoop-0.png\" />\n\n<h3 id=\"Map-Reduce\"><a href=\"#Map-Reduce\" class=\"headerlink\" title=\"Map&#x2F;Reduce\"></a>Map&#x2F;Reduce</h3><ul>\n<li>整体结构：</li>\n</ul>\n<p><code>extends Mapper&lt;Object, Text, Text, IntWritable&gt;</code>，四个范型参数是输入键、输入值、输出键、输出值。</p>\n<p>重写<code>void map(Object key, Text value, Context context)</code>。</p>\n<p><code>extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;</code>，四个范型参数是输入键、输入值、输出键、输出值。</p>\n<p>重写<code>void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)</code>。</p>\n<ul>\n<li>两种数据类型：</li>\n</ul>\n<p><code>IntWritable</code>整形，<code>Text</code>表示字符串，这两种数据结构可以放在context中。</p>\n<ul>\n<li>处理逻辑：</li>\n</ul>\n<p>map函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringTokenizer</span> <span class=\"variable\">itr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringTokenizer</span>(value.toString());</span><br><span class=\"line\"><span class=\"keyword\">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class=\"line\">    word.set(itr.nextToken());</span><br><span class=\"line\">    context.write(word, one);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>reduce函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (IntWritable val : values) &#123;</span><br><span class=\"line\">    sum += val.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result.set(sum);</span><br><span class=\"line\">context.write(key, result);</span><br></pre></td></tr></table></figure>\n\n<p>主函数：JJ,MCR,KV,IO</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Configuration</span> <span class=\"variable\">conf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Configuration</span>();</span><br><span class=\"line\"><span class=\"type\">Job</span> <span class=\"variable\">job</span> <span class=\"operator\">=</span> Job.getInstance(conf, <span class=\"string\">&quot;word count&quot;</span>);</span><br><span class=\"line\">job.setJarByClass(WordCount.class);</span><br><span class=\"line\"></span><br><span class=\"line\">job.setMapperClass(TokenizerMapper.class);</span><br><span class=\"line\">job.setCombinerClass(IntSumReducer.class);</span><br><span class=\"line\">job.setReducerClass(IntSumReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">job.setOutputValueClass(IntWritable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">FileInputFormat.addInputPath(job, <span class=\"keyword\">new</span> <span class=\"title class_\">Path</span>(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> <span class=\"title class_\">Path</span>(args[<span class=\"number\">1</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">System.exit(job.waitForCompletion(<span class=\"literal\">true</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><p>Docker是开源的容器引擎。容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。</p>\n<blockquote>\n<p>和虚拟机的区别：</p>\n<p>部署速度、资源消耗、隔离性、部署管理</p>\n</blockquote>\n<p>服务器虚拟化由多种技术架构，其中主要的四种如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181751512.webp\" alt=\"image-20231018173203055\"></p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://veni222987.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"Web应用开发","date":"2023-12-17T12:23:50.000Z","path":"2023/12/17/Web应用开发/","text":"Web应用开发的课程笔记。 Web应用开发Web基础知识HTML基本概念 DOM：文档对象模型，是独立于平台的内容和结构。一个HTML的所有元素的表示模型就是一个DOM，表现为一个多层级的树 BOM：浏览器对象模型，独立于内容且可以和浏览器交互的对象。 BOM的层次如下： HTTP协议 协议组成，常见状态码，常用方法 HTTP工作三大特点：无连接，媒体独立，无状态的 八种请求类型：GET, POST, PUT, DELETE, OPTIONS, HEAD, TRACE, CONNECT HTTP请求：由请求行（请求方式、资源路径、所用HTTP版本），请求头，实体内容 HTTP响应：由响应状态行、响应头、实体内容 CSS基础四种引入方式：行内式、内嵌式、外链式、导入式。 外链式和导入式都是引入外部CSS代码的方法，异同在于： 外链式：使用&lt;link href&#x3D;””&gt;标签引入，导入式使用@引入，例如&lt;style&gt;@import “css&#x2F;hello.css”&lt;style&gt; 代码： 1234567891011121314151617181920&lt;html&gt;&lt;title&gt;这是一个测试&lt;/title&gt;&lt;head&gt; &lt;link href=&quot;css/myCss.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=&quot;color: blue&quot;&gt;行内式写法：&lt;/h1&gt;&lt;p&gt;在标签后面加上 style=&quot;属性:值&quot;&lt;/p&gt;&lt;p&gt;例如：style=&quot;color: blue&quot;&lt;/p&gt;&lt;h1&gt; 内嵌式：将代码集中写在head标签中&lt;/h1&gt;&lt;p&gt; &amp;lt;head&amp;gt; &amp;lt;style type=&quot;text/css&quot;&amp;gt; h1&#123; text-align: center&#125; &amp;lt;/style&amp;gt; &amp;lt;/head&gt;&lt;/p&gt;&lt;h1&gt;外链式&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; js基础js的三种引入方式：行内式、内嵌式和外链式。 12345678910&lt;head&gt; &lt;link href=&quot;css/myCss.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/my.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function neiqian()&#123; alert(&quot;这是内嵌式写的&quot;) &#125; &lt;/script&gt;&lt;/head&gt; Servlet教程第一个Servlet使用一个自己实现的Servlet类实现HttpServlet，然后重写doGet，doPost，doPut，每当有HTTP请求到达对应的路径的时候，就会调用对应的方法。 1234567891011//Servlet运行测试@WebServlet(name = &quot;/TestServlet0&quot;, urlPatterns = &#123;&quot;/hello&quot;&#125;)public class Servlet01 extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;Test Servlet 0&lt;/h1&gt;&quot;); out.close(); &#125;&#125; Servlet的配置使用web.xml可以对Servlet进行配置，步骤如下： 使用&lt;servlet&gt;标签进行注册，在该标签下包含若干个元素，如&lt;servlet-name&gt;,&lt;servlet-class&gt;等。 把Servlet映射到URL地址，使用&lt;servlet-mapping&gt;标签定义映射，使用&lt;servlet-name&gt;指定需要映射的Servlet，然后使用&lt;url-pattern&gt;子标签进行URL地址，地址前必须加”&#x2F;“。 例如，我们把上面的@WebServlet配置去掉，改用web.xml配置，实现如下： 注意，servlet必须配置name和class两个参数，class用于指定实现类，name用于和mapping建立映射。 123456789&lt;servlet&gt; &lt;servlet-name&gt;TestServlet01&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet01&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用注解配置时，value和urlPatterns通常是二选一，通常是忽略value，使用urlPattern，见文知意。 Servlet生命周期Servlet有三个生命周期：初始化，运行和销毁。 要想测试生命周期，必须实现GenericServlet，重写init()，service()和destroy接口。 当第一次访问&#x2F;Servlet02对应的Servlet的时候，init()函数会被调用 每一次访问该页面，都会调用service()服务（包括刷新） 当停止程序的时候，调用destroy() 1234567891011121314151617@WebServlet(name = &quot;/TestServlet02&quot;, urlPatterns = &#123;&quot;/Servlet02&quot;&#125;)public class Servlet02 extends GenericServlet &#123; @Override public void init() throws ServletException &#123; System.out.println(&quot;init&quot;); &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;destroy&quot;); &#125;&#125; ServletConfig配置环境在Servlet运行期间，常常需要一些配置，例如编码等等。使用ServletConfig类可以对Servlet进行初始化和默认参数的管理。例子如下： 12345678910111213@WebServlet(name = &quot;/Servlet03&quot;, urlPatterns = &#123;&quot;/Servlet03&quot;&#125;,initParams = &#123; @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;)&#125;)public class Servlet03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; PrintWriter out=httpServletResponse.getWriter(); ServletConfig config=this.getServletConfig(); String param = config.getInitParameter(&quot;encoding&quot;); out.println(&quot;encoding=&quot;+param); &#125;&#125; HttpServlet类中有一个getServletConfig方法，返回的是一个ServletConfig类的对象。上述例子使用了注解@WebInitParam方法实现了参数初始化，将encoding设置为UTF-8。除了上述方法外，还可以使用web.xml配置参数。例子如下： 首先配置xml的参数：注意context-param要写在servlet之前 123456789101112131415161718&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;param2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;TestServlet01&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet01&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;/web-app&gt; 然后获取xml中的配置并打印： 12345678910111213141516@WebServlet(name = &quot;Servlet04&quot;,urlPatterns = &quot;/servlet04&quot;)public class Servlet04 extends HttpServlet &#123; public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; res.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=res.getWriter(); ServletContext context=this.getServletContext(); Enumeration&lt;String&gt; paramsNames=context.getInitParameterNames(); out.println(&quot;参数是&quot;); while(paramsNames.hasMoreElements())&#123; String name = paramsNames.nextElement(); String value=context.getInitParameter(name); out.println(name+&quot;:&quot;+value); out.println(&quot;&lt;br/&gt;&quot;); &#125; &#125;&#125; 执行结果如下： 获取路径：HttpServlet-&gt; ServletContext-&gt; getInitParameterNames获取names的枚举值，然后调用context.getInitParameter。 多个Servlet共享数据首先写一个Servlet05，重写doGet请求，调用context.setAttribute设置上下文属性。 12345678@WebServlet(name = &quot;Servlet05&quot;,urlPatterns = &quot;/servlet05&quot;)public class Servlet05 extends HttpServlet &#123; public void doGet(HttpServletRequest req, HttpServletResponse res)&#123; ServletContext context=this.getServletContext(); context.setAttribute(&quot;data&quot;,&quot;this is a data from me&quot;); &#125;&#125; 然后写一个Servlet06，获取attribute， 12345678@WebServlet(name = &quot;Servlet06&quot;,urlPatterns = &quot;/servlet06&quot;)public class Servlet06 extends HttpServlet &#123; public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; PrintWriter out = res.getWriter(); String data=(String) this.getServletContext().getAttribute(&quot;data&quot;); out.println(data); &#125;&#125; 先调用servlet05，再调用servlet06，运行结果如下图： 读取Web应用下的资源文件资源文件包括.properties文件等。示例代码如下 12345678910111213@WebServlet(name = &quot;Servlet07&quot;,urlPatterns = &quot;/servlet07&quot;)public class Servlet07 extends HttpServlet &#123; public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; ServletContext context = this.getServletContext(); res.setContentType(&quot;text/html,charset=utf-8&quot;); PrintWriter out= res.getWriter(); InputStream in = context.getResourceAsStream(&quot;veni.properties&quot;); Properties properties=new Properties(); properties.load(in); out.println(&quot;Name=&quot;+properties.getProperty(&quot;Name&quot;)); out.println(&quot;City=&quot;+properties.getProperty(&quot;City&quot;)); &#125;&#125; HttpServletResponse类图如下，不作过多讲解。 获取请求信息和请求头就直接调函数即可，下面讲讲请求重定向。 请求重定向：两次请求，请求不同的资源 HttpServletRequest类图如下，根据函数名即可作用。 请求转发：一次请求，通过ServletContext共享。 FilterServlet规范有三个高级特性，Filter，Listener，以及文件的上传下载。Filter用于修改request和response，Listener用于监听context, session, request事件。 Servlet Filter是过滤器，由多个Filter组成Filter链，只有通过所有过滤器的请求才能进入Servlet。 拦截器是Servlet内部的处理方法，而Filter是Servlet外部的拦截器。 Filter接口 该接口定义了init()，doFilter()方法和destroy()方法。 FilterConfig接口 在Filter初始化的时候，服务器将FilterConfig对象作为参数传递给Filter初始化方法。 FilterChain接口 该接口的doFilter()方法调用Filter， Filter生命周期创建阶段-&gt;执行阶段-&gt;销毁阶段 实现Filter使用@WebFilter配置需要拦截的资源，实现如下： 12345678@WebFilter(&quot;/filter&quot;)public class MyFilter implements Filter &#123; // 如果路径匹配，就会执行这个方法 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletResponse.getWriter().println(&quot;Filter&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; Listener在Web开发中，经常需要对某些事件进行监听。为此，Servlet提供了监听器，专门监听Servlet事件。 监听过程的组成部分： 事件：用户的操作，如创建对象，调用方法，创建对象等。 事件源：产生事件的对象。 事件监听器 事件处理器 事件监听器的过程分为以下步骤 注册监听器：将监听器绑定到事件源 监听器监听到事件发生，会调用监听器的成员方法 事件处理器通过实践对象获得事件源，并对事件源进行处理 例如，实现一个自动插入审计字段的函数，当执行mapper的时候，调用Listener处理，更新时间等。 例如，一个监听器的实现如下： 123456789@WebListenerpublic class MyListener implements ServletContextListener, HttpSessionListener, ServletRequestListener &#123; public void requestDestroyed(javax.servlet.ServletRequestEvent sre) &#123; System.out.println(&quot;requestDestroyed&quot;); &#125; public void requestInitialized(javax.servlet.ServletRequestEvent sre) &#123; System.out.println(&quot;requestInitialized&quot;); &#125;&#125; 会话技术Cookies 使用Cookie类，该类仅有一个构造函数：参数为(String name, String value)。一个cookie就是一个带有过期时间等属性的KV对。 获取请求的cookies：使用HttpServletRequest类的getCookies()，返回Cookie[]，见上面的类图。 设置响应的cookie：使用HttpResponse的addCookie，见类图。注意这里的add不会叠加，只是在返回时更新浏览器的本地cookies。 Session技术当浏览器访问Web服务的时候，Servlet容器就会创建一个Session对象和ID属性。Session对象就相当于病例档案，而SessionId就是病例档案号。 Session只会在用户第一次访问JSP，Servlet等应用的时候才会创建。 Session的实现为HttpSession，是一个Java Interface，定义如下图： 可以看到，里面有一个servletContext的成员变量，而interface中的变量都是final的，因此该context不可重新赋值。由于Servlet默认启用session技术，所以在浏览器中的cookies栏都会有一个JSESSIONID。 HttpServletRequest方法中定义了一个获取Session对象的getSession()函数用于返回当前请求的HttpSession对象。有两个重载形式： 1234public HttpSession getSession(boolean create);public HttpSession getSession();//实际上就是默认参数public HttpSession getSession(boolean create=true); 如果create为true，那么在HttpSession对象不存在的时候创建一个新的HttpSession，为false返回null。第二个方法默认为true。 JSPJSP知识点如下： 基本语法基本声明和包导入，使用contentType声明文件类型等信息，一般而言IDE会自动完成 12&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot; %&gt; 基本结构：声明和引入完成之后，就是html主体,包括html标签下的head和body等标签。一个完整的jsp如下： 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%@ page import=&quot;java.text.SimpleDateFormat&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSP显示系统时间&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Date date = new Date(); SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String today= df.format(date); %&gt; 当前时间：&lt;%=today%&gt;&lt;/body&gt;&lt;/html&gt; JSP脚本元素JSP ScriptletsScriptlets就是一个代码段，可以编写java的程序语句。使用格式如下。在Scriptlets中可以进行属性的定义，也可以输出内容，但是无法声明函数。 1&lt;% java code %&gt; 声明函数的语法如下： 1&lt;%! java code %&gt; 在声明代码段中的函数在整个JSP页面都可以生效，包括多次打开和关闭，除非关闭服务器。 JSP指令JSP指令用于配置页面中的一些信息。例如 page指令：用于指定某个jsp页面的属性和引入java包。常用的page属性有：language，import，contentType。 1&lt;%@ page import=&quot;java.util.Date&quot; %&gt; include指令：实际开发中，有时候会要在一个jsp页面中包含另一个jsp页面，这时候可以通过include指令实现。Include一般使用相对路径。 taglib指令：可以使用该指令标识页面中所使用的标签库。 JSP动作元素 &lt;jsp:include page&#x3D;”” flush&#x3D;””&gt;用于向当前页面引入其他页面的文件，&lt;% @include file &#x3D; “” %&gt;，动态与静态的区别。 &lt;jsp:forward&gt;将当前请求转发到其他的Web资源，类似Servlet中的request.forward()，因为JSP本质上也是一个Servlet。 JSP隐式对象JSP有9个隐式对象，分别是：out, request, response, config, session, application, page, pageContext, exception。 EL和JSTLELExpression Language，语法格式。 EL的核心格式就是”${}” EL提供了11个隐式对象，这些对象类似于JSP的隐式对象 JSTLJava server pages standard tag library，JSP标准标签库，用于替代Java的部分关键字，在页面中处理部分业务逻辑。 JSTL必须使用JSP的taglib指令来指定标签库。标签库本质上是取代在html中嵌入Java代码的，因此具备逻辑处理能力。 JSTL包含五类标准标签库，分别是核心标签库、国际化&#x2F;格式化标签库、SQL标签库、XML标签库和函数标签库。 简记为：核、国、S、X、函。 &lt;c:out value&#x3D;”” default&#x3D;””&gt;标签&lt;&#x2F;c:out&gt;，用于输出元素。 JDBC常用API： Driver接口：所有JDBC程序必须实现的接口，专门给数据库厂商使用。 DriverManager类：用于加载JDBC驱动并且建立与数据库的连接。有两个比较重要的静态方法： registerDriver(Driver driver);注册数据库驱动 getConnection(String url, String user, String pwd);建立连接返回Connection对象。 连接数据库： 123Class.forname(&quot;com.mysql.cj.jdbc.Driver&quot;);String url = &quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=GMT%2B8&quot;;conn = DriverManager.getConnection(url,username,password); 这样一个连接就建立完成了。 Statement接口：用于执行静态的SQL语句 1234567stmt = conn.createStatement();ResultSet rs=stmt.excute(&quot;select * from users&quot;);while(rs.next())&#123; int id=GetInt(&quot;id&quot;); String name=GetString(&quot;name&quot;); // ...&#125; ResultSet：用于保存查询结果，可以保存单条或多条，使用rs.next()遍历。 PreparedStatement接口：封装了JDBC执行SQL语句的方法，完成Java调用SQL的功能。 SpringSpring的优良特性 非侵入式：基于Spring开发的应用程序对象可以不依赖于Spring的API。举个例子，使用Spring initializr初始化了一个Spring项目，但是可以不使用Spring风格的注解写Controller，可以使用Servlet写。 控制反转IoC：将对象的创建权交给Spring，以前都是我们手动创建对象，现在是由Spring创建。常常使用容器管理，这些容器使用反射、配置文件或注解来定义对象之间的依赖关系，并提供了自动注入依赖的机制。例如，使用@Bean之类的方法控制反转，类会成为一个Bean，当有需要的时候，会自动创建（如@Resource，@Autowired等。 123456789101112@Configurationpublic class AppConfig &#123; @Bean public UserRepository userRepository() &#123; return new UserRepositoryImpl(); &#125; //当注册为Bean的时候，可以在其他地方有需要时自动引入。 @Bean public UserService userService(UserRepository userRepository) &#123; return new UserService(userRepository); &#125;&#125; 依赖注入DI：实现控制反转的一种方法，指的是依赖的对象不需要手动调用set方法设置，而是通过配置赋值。例如Spring的JDBC连接，将对应的配置文件写好，然后在任何地方都可以调用@Mapper等方法实现。 面向切面编程AOP：用于将横切关注点（cross-cutting concerns）与核心业务逻辑分离。横切关注点指的是那些在应用程序中多处重复出现的功能，例如日志记录、事务管理、安全性检查等。例如，可以使用AOP的思想自动设置时间等审计字段的更新。 容器化与组件化：容器化是指Spring包含并管理对象的生命周期，组件化是指通过各种组件配置组合形成一个复杂的应用，使用xml或注解组合对象。 一站式：可以整合各种框架和第三方库，实际上Spring自身也提供了表述层的SpringMVC和持久层的Spring JDBC。 表述层是指应用程序中处理用户请求和生成响应的部分。它负责将用户的输入转化为可理解的数据，并将处理结果以适合用户的方式进行呈现。 Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品（企业级JavaBeans），比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。 POJO是”Plain Old Java Object”的缩写，它是一种简单的Java对象，没有任何特殊要求或限制。POJO是一种纯粹的普通Java对象，不依赖于任何特定的框架、接口或类库。 Spring框架体系结构 最下层是Test模块，然后是Core Container模块。","content":"<p>Web应用开发的课程笔记。<span id=\"more\"></span></p>\n<h1 id=\"Web应用开发\"><a href=\"#Web应用开发\" class=\"headerlink\" title=\"Web应用开发\"></a>Web应用开发</h1><h2 id=\"Web基础知识\"><a href=\"#Web基础知识\" class=\"headerlink\" title=\"Web基础知识\"></a>Web基础知识</h2><h3 id=\"HTML基本概念\"><a href=\"#HTML基本概念\" class=\"headerlink\" title=\"HTML基本概念\"></a>HTML基本概念</h3><ul>\n<li>DOM：文档对象模型，是独立于平台的内容和结构。一个HTML的所有元素的表示模型就是一个DOM，表现为一个多层级的树</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312172039300.webp\" alt=\"image-20231217203929130\"></p>\n<ul>\n<li>BOM：浏览器对象模型，独立于内容且可以和浏览器交互的对象。</li>\n</ul>\n<p>BOM的层次如下：</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecec85dcf1ff4f27a815685189feaccf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\">\n\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><blockquote>\n<p>协议组成，常见状态码，常用方法</p>\n</blockquote>\n<p>HTTP工作三大特点：无连接，媒体独立，无状态的</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312172029094.webp\" alt=\"image-20231217202900899\"></p>\n<p>八种请求类型：GET, POST, PUT, DELETE, OPTIONS, HEAD, TRACE, CONNECT</p>\n<blockquote>\n<p>HTTP请求：由请求行（请求方式、资源路径、所用HTTP版本），请求头，实体内容</p>\n<p>HTTP响应：由响应状态行、响应头、实体内容</p>\n</blockquote>\n<h3 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h3><p>四种引入方式：行内式、内嵌式、外链式、导入式。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312200116795.webp\" alt=\"image-20231220011604673\"></p>\n<blockquote>\n<p>外链式和导入式都是引入外部CSS代码的方法，异同在于：</p>\n<p>外链式：使用&lt;link href&#x3D;””&gt;标签引入，导入式使用@引入，例如&lt;style&gt;@import “css&#x2F;hello.css”&lt;style&gt;</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>这是一个测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;css/myCss.css&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: blue&quot;</span>&gt;</span>行内式写法：<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>在标签后面加上 style=&quot;属性:值&quot;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>例如：style=&quot;color: blue&quot;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span> 内嵌式：将代码集中写在head标签中<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"symbol\">&amp;lt;</span>head<span class=\"symbol\">&amp;gt;</span></span><br><span class=\"line\">    <span class=\"symbol\">&amp;lt;</span>style type=&quot;text/css&quot;<span class=\"symbol\">&amp;gt;</span></span><br><span class=\"line\">            h1&#123; text-align: center&#125;</span><br><span class=\"line\">    <span class=\"symbol\">&amp;lt;</span>/style<span class=\"symbol\">&amp;gt;</span></span><br><span class=\"line\">    <span class=\"symbol\">&amp;lt;</span>/head&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>外链式<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js基础\"><a href=\"#js基础\" class=\"headerlink\" title=\"js基础\"></a>js基础</h3><p>js的三种引入方式：行内式、内嵌式和外链式。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;link href=<span class=\"string\">&quot;css/myCss.css&quot;</span> type=<span class=\"string\">&quot;text/css&quot;</span> rel=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class=\"line\">    &lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span> src=<span class=\"string\">&quot;js/my.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">        function <span class=\"title function_\">neiqian</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">&quot;这是内嵌式写的&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Servlet教程\"><a href=\"#Servlet教程\" class=\"headerlink\" title=\"Servlet教程\"></a>Servlet教程</h2><h3 id=\"第一个Servlet\"><a href=\"#第一个Servlet\" class=\"headerlink\" title=\"第一个Servlet\"></a>第一个Servlet</h3><p>使用一个自己实现的Servlet类实现HttpServlet，然后重写doGet，doPost，doPut，每当有HTTP请求到达对应的路径的时候，就会调用对应的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Servlet运行测试</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;/TestServlet0&quot;, urlPatterns = &#123;&quot;/hello&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet01</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> response.getWriter();</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;&lt;h1&gt;Test Servlet 0&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Servlet的配置\"><a href=\"#Servlet的配置\" class=\"headerlink\" title=\"Servlet的配置\"></a>Servlet的配置</h3><p>使用web.xml可以对Servlet进行配置，步骤如下：</p>\n<ol>\n<li>使用&lt;servlet&gt;标签进行注册，在该标签下包含若干个元素，如&lt;servlet-name&gt;,&lt;servlet-class&gt;等。</li>\n<li>把Servlet映射到URL地址，使用&lt;servlet-mapping&gt;标签定义映射，使用&lt;servlet-name&gt;指定需要映射的Servlet，然后使用&lt;url-pattern&gt;子标签进行URL地址，地址前必须加”&#x2F;“。</li>\n</ol>\n<p>例如，我们把上面的@WebServlet配置去掉，改用web.xml配置，实现如下：</p>\n<p>注意，servlet必须配置name和class两个参数，class用于指定实现类，name用于和mapping建立映射。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet01<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>Servlet01<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet01<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用注解配置时，value和urlPatterns通常是二选一，通常是忽略value，使用urlPattern，见文知意。</p>\n</blockquote>\n<h3 id=\"Servlet生命周期\"><a href=\"#Servlet生命周期\" class=\"headerlink\" title=\"Servlet生命周期\"></a>Servlet生命周期</h3><p>Servlet有三个生命周期：初始化，运行和销毁。</p>\n<p>要想测试生命周期，必须实现GenericServlet，重写init()，service()和destroy接口。</p>\n<ul>\n<li>当第一次访问&#x2F;Servlet02对应的Servlet的时候，init()函数会被调用</li>\n<li>每一次访问该页面，都会调用service()服务（包括刷新）</li>\n<li>当停止程序的时候，调用destroy()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;/TestServlet02&quot;, urlPatterns = &#123;&quot;/Servlet02&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet02</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GenericServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;destroy&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ServletConfig\"><a href=\"#ServletConfig\" class=\"headerlink\" title=\"ServletConfig\"></a>ServletConfig</h3><h4 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h4><p>在Servlet运行期间，常常需要一些配置，例如编码等等。使用ServletConfig类可以对Servlet进行初始化和默认参数的管理。例子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;/Servlet03&quot;, urlPatterns = &#123;&quot;/Servlet03&quot;&#125;,initParams = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet03</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        PrintWriter out=httpServletResponse.getWriter();</span><br><span class=\"line\">        ServletConfig config=<span class=\"built_in\">this</span>.getServletConfig();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">param</span> <span class=\"operator\">=</span> config.getInitParameter(<span class=\"string\">&quot;encoding&quot;</span>);</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;encoding=&quot;</span>+param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HttpServlet类中有一个getServletConfig方法，返回的是一个ServletConfig类的对象。上述例子使用了注解@WebInitParam方法实现了参数初始化，将encoding设置为UTF-8。除了上述方法外，还可以使用web.xml配置参数。例子如下：</p>\n<p>首先配置xml的参数：注意context-param要写在servlet之前</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>Archetype Created Web Application<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>param2<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>value2<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet01<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>Servlet01<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后获取xml中的配置并打印：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;Servlet04&quot;,urlPatterns = &quot;/servlet04&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet04</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        res.setContentType(<span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter out=res.getWriter();</span><br><span class=\"line\">        ServletContext context=<span class=\"built_in\">this</span>.getServletContext();</span><br><span class=\"line\">        Enumeration&lt;String&gt; paramsNames=context.getInitParameterNames();</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;参数是&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(paramsNames.hasMoreElements())&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> paramsNames.nextElement();</span><br><span class=\"line\">            String value=context.getInitParameter(name);</span><br><span class=\"line\">            out.println(name+<span class=\"string\">&quot;:&quot;</span>+value);</span><br><span class=\"line\">            out.println(<span class=\"string\">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190003311.webp\" alt=\"image-20231219000256150\"></p>\n<p>获取路径：HttpServlet-&gt; ServletContext-&gt; getInitParameterNames获取names的枚举值，然后调用context.getInitParameter。</p>\n<h4 id=\"多个Servlet共享数据\"><a href=\"#多个Servlet共享数据\" class=\"headerlink\" title=\"多个Servlet共享数据\"></a>多个Servlet共享数据</h4><p>首先写一个Servlet05，重写doGet请求，调用context.setAttribute设置上下文属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;Servlet05&quot;,urlPatterns = &quot;/servlet05&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet05</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span>&#123;</span><br><span class=\"line\">        ServletContext context=<span class=\"built_in\">this</span>.getServletContext();</span><br><span class=\"line\">        context.setAttribute(<span class=\"string\">&quot;data&quot;</span>,<span class=\"string\">&quot;this is a data from me&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后写一个Servlet06，获取attribute，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;Servlet06&quot;,urlPatterns = &quot;/servlet06&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet06</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> res.getWriter();</span><br><span class=\"line\">        String data=(String) <span class=\"built_in\">this</span>.getServletContext().getAttribute(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\">        out.println(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先调用servlet05，再调用servlet06，运行结果如下图：</p>\n<p><img src=\"C:/Users/19481/AppData/Roaming/Typora/typora-user-images/image-20231219002124686.png\" alt=\"image-20231219002124686\"></p>\n<h4 id=\"读取Web应用下的资源文件\"><a href=\"#读取Web应用下的资源文件\" class=\"headerlink\" title=\"读取Web应用下的资源文件\"></a>读取Web应用下的资源文件</h4><p>资源文件包括.properties文件等。示例代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(name = &quot;Servlet07&quot;,urlPatterns = &quot;/servlet07&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Servlet07</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServletContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getServletContext();</span><br><span class=\"line\">        res.setContentType(<span class=\"string\">&quot;text/html,charset=utf-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter out= res.getWriter();</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> context.getResourceAsStream(<span class=\"string\">&quot;veni.properties&quot;</span>);</span><br><span class=\"line\">        Properties properties=<span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        properties.load(in);</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;Name=&quot;</span>+properties.getProperty(<span class=\"string\">&quot;Name&quot;</span>));</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;City=&quot;</span>+properties.getProperty(<span class=\"string\">&quot;City&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HttpServletResponse\"><a href=\"#HttpServletResponse\" class=\"headerlink\" title=\"HttpServletResponse\"></a>HttpServletResponse</h3><p>类图如下，不作过多讲解。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190111467.webp\" alt=\"image-20231219011108143\"></p>\n<p>获取请求信息和请求头就直接调函数即可，下面讲讲请求重定向。</p>\n<ul>\n<li>请求重定向：两次请求，请求不同的资源</li>\n</ul>\n<h3 id=\"HttpServletRequest\"><a href=\"#HttpServletRequest\" class=\"headerlink\" title=\"HttpServletRequest\"></a>HttpServletRequest</h3><p>类图如下，根据函数名即可作用。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312190109846.webp\" alt=\"image-20231219010924558\"></p>\n<ul>\n<li>请求转发：一次请求，通过ServletContext共享。</li>\n</ul>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>Servlet规范有三个高级特性，Filter，Listener，以及文件的上传下载。Filter用于修改request和response，Listener用于监听context, session, request事件。</p>\n<p><img src=\"https://th.bing.com/th/id/R.1cc9c9543e2604300e2181353caa438a?rik=aMy/fSlsWHGavw&riu=http://tutorials.jenkov.com/images/java-servlets/servlet-filters-1.png&ehk=6s4rd3wKOrfdMwhy537QCgFAA8ohUM6Znq00xw92x84=&risl=&pid=ImgRaw&r=0\" alt=\"Use of filters in Servlet\"></p>\n<p>Servlet Filter是过滤器，由多个Filter组成Filter链，只有通过所有过滤器的请求才能进入Servlet。</p>\n<blockquote>\n<p>拦截器是Servlet内部的处理方法，而Filter是Servlet外部的拦截器。</p>\n</blockquote>\n<ul>\n<li>Filter接口</li>\n</ul>\n<p>该接口定义了init()，doFilter()方法和destroy()方法。</p>\n<ul>\n<li>FilterConfig接口</li>\n</ul>\n<p>在Filter初始化的时候，服务器将FilterConfig对象作为参数传递给Filter初始化方法。</p>\n<ul>\n<li>FilterChain接口</li>\n</ul>\n<p>该接口的doFilter()方法调用Filter，</p>\n<h4 id=\"Filter生命周期\"><a href=\"#Filter生命周期\" class=\"headerlink\" title=\"Filter生命周期\"></a>Filter生命周期</h4><p><strong>创建阶段-&gt;执行阶段-&gt;销毁阶段</strong></p>\n<h4 id=\"实现Filter\"><a href=\"#实现Filter\" class=\"headerlink\" title=\"实现Filter\"></a>实现Filter</h4><p>使用@WebFilter配置需要拦截的资源，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebFilter(&quot;/filter&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyFilter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Filter</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果路径匹配，就会执行这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\">        servletResponse.getWriter().println(<span class=\"string\">&quot;Filter&quot;</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h3><p>在Web开发中，经常需要对某些事件进行监听。为此，Servlet提供了监听器，专门监听Servlet事件。</p>\n<p>监听过程的组成部分：</p>\n<ol>\n<li>事件：用户的操作，如创建对象，调用方法，创建对象等。</li>\n<li>事件源：产生事件的对象。</li>\n<li>事件监听器</li>\n<li>事件处理器</li>\n</ol>\n<p>事件监听器的过程分为以下步骤</p>\n<ol>\n<li>注册监听器：将监听器绑定到事件源</li>\n<li>监听器监听到事件发生，会调用监听器的成员方法</li>\n<li>事件处理器通过实践对象获得事件源，并对事件源进行处理</li>\n</ol>\n<p>例如，实现一个自动插入审计字段的函数，当执行mapper的时候，调用Listener处理，更新时间等。</p>\n<p>例如，一个监听器的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebListener</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServletContextListener</span>, HttpSessionListener, ServletRequestListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">requestDestroyed</span><span class=\"params\">(javax.servlet.ServletRequestEvent sre)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;requestDestroyed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">requestInitialized</span><span class=\"params\">(javax.servlet.ServletRequestEvent sre)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;requestInitialized&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"会话技术\"><a href=\"#会话技术\" class=\"headerlink\" title=\"会话技术\"></a>会话技术</h2><h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><ul>\n<li><p>使用Cookie类，该类仅有一个构造函数：参数为(String name, String value)。一个cookie就是一个带有过期时间等属性的KV对。</p>\n</li>\n<li><p>获取请求的cookies：使用HttpServletRequest类的getCookies()，返回Cookie[]，见上面的类图。</p>\n</li>\n<li><p>设置响应的cookie：使用HttpResponse的addCookie，见类图。注意这里的add不会叠加，只是在返回时更新浏览器的本地cookies。</p>\n</li>\n</ul>\n<h3 id=\"Session技术\"><a href=\"#Session技术\" class=\"headerlink\" title=\"Session技术\"></a>Session技术</h3><p>当浏览器访问Web服务的时候，Servlet容器就会创建一个Session对象和ID属性。Session对象就相当于病例档案，而SessionId就是病例档案号。</p>\n<p>Session只会在用户第一次访问JSP，Servlet等应用的时候才会创建。</p>\n<ul>\n<li>Session的实现为HttpSession，是一个Java Interface，定义如下图：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312191017177.webp\" alt=\"image-20231219101738007\"></p>\n<p>可以看到，里面有一个servletContext的成员变量，而interface中的变量都是final的，因此该context不可重新赋值。由于Servlet默认启用session技术，所以在浏览器中的cookies栏都会有一个JSESSIONID。</p>\n<ul>\n<li>HttpServletRequest方法中定义了一个获取Session对象的getSession()函数用于返回当前请求的HttpSession对象。有两个重载形式：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> HttpSession <span class=\"title function_\">getSession</span><span class=\"params\">(<span class=\"type\">boolean</span> create)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> HttpSession <span class=\"title function_\">getSession</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//实际上就是默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> HttpSession <span class=\"title function_\">getSession</span><span class=\"params\">(<span class=\"type\">boolean</span> create=<span class=\"literal\">true</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n  如果create为true，那么在HttpSession对象不存在的时候创建一个新的HttpSession，为false返回null。第二个方法默认为true。</li>\n</ul>\n<h2 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h2><p>JSP知识点如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312191913166.webp\" alt=\"JSP\"></p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><p>基本声明和包导入，使用contentType声明文件类型等信息，一般而言IDE会自动完成</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"string\">&quot;java&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>基本结构：声明和引入完成之后，就是html主体,包括html标签下的head和body等标签。一个完整的jsp如下：</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"string\">&quot;java&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Date&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.text.SimpleDateFormat&quot;</span>%&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;JSP显示系统时间&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;%</span><br><span class=\"line\">        <span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">df</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        String today= df.format(date);</span><br><span class=\"line\">    %&gt;</span><br><span class=\"line\">    当前时间：&lt;%=today%&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSP脚本元素\"><a href=\"#JSP脚本元素\" class=\"headerlink\" title=\"JSP脚本元素\"></a>JSP脚本元素</h3><h4 id=\"JSP-Scriptlets\"><a href=\"#JSP-Scriptlets\" class=\"headerlink\" title=\"JSP Scriptlets\"></a>JSP Scriptlets</h4><p>Scriptlets就是一个代码段，可以编写java的程序语句。使用格式如下。在Scriptlets中可以进行属性的定义，也可以输出内容，但是无法声明函数。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% java code %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>声明函数的语法如下：</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%! java code %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在声明代码段中的函数在整个JSP页面都可以生效，包括多次打开和关闭，除非关闭服务器。</p>\n<h3 id=\"JSP指令\"><a href=\"#JSP指令\" class=\"headerlink\" title=\"JSP指令\"></a>JSP指令</h3><p>JSP指令用于配置页面中的一些信息。例如</p>\n<ul>\n<li>page指令：用于指定某个jsp页面的属性和引入java包。常用的page属性有：language，import，contentType。</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>include指令：实际开发中，有时候会要在一个jsp页面中包含另一个jsp页面，这时候可以通过include指令实现。Include一般使用相对路径。</li>\n<li>taglib指令：可以使用该指令标识页面中所使用的标签库。</li>\n</ul>\n<h3 id=\"JSP动作元素\"><a href=\"#JSP动作元素\" class=\"headerlink\" title=\"JSP动作元素\"></a>JSP动作元素</h3><ul>\n<li>&lt;jsp:include page&#x3D;”” flush&#x3D;””&gt;用于向当前页面引入其他页面的文件，&lt;% @include file &#x3D; “” %&gt;，动态与静态的区别。</li>\n<li>&lt;jsp:forward&gt;将当前请求转发到其他的Web资源，类似Servlet中的request.forward()，因为JSP本质上也是一个Servlet。</li>\n</ul>\n<h3 id=\"JSP隐式对象\"><a href=\"#JSP隐式对象\" class=\"headerlink\" title=\"JSP隐式对象\"></a>JSP隐式对象</h3><p>JSP有9个隐式对象，分别是：out, request, response, config, session, application, page, pageContext, exception。</p>\n<h2 id=\"EL和JSTL\"><a href=\"#EL和JSTL\" class=\"headerlink\" title=\"EL和JSTL\"></a>EL和JSTL</h2><h3 id=\"EL\"><a href=\"#EL\" class=\"headerlink\" title=\"EL\"></a>EL</h3><p>Expression Language，语法格式。</p>\n<p>EL的核心格式就是”${}”</p>\n<p>EL提供了11个隐式对象，这些对象类似于JSP的隐式对象</p>\n<h3 id=\"JSTL\"><a href=\"#JSTL\" class=\"headerlink\" title=\"JSTL\"></a>JSTL</h3><p>Java server pages standard tag library，JSP标准标签库，用于替代Java的部分关键字，在页面中处理部分业务逻辑。</p>\n<p>JSTL必须使用JSP的taglib指令来指定标签库。标签库本质上是取代在html中嵌入Java代码的，因此具备逻辑处理能力。</p>\n<blockquote>\n<p>JSTL包含五类标准标签库，分别是核心标签库、国际化&#x2F;格式化标签库、SQL标签库、XML标签库和函数标签库。</p>\n<p>简记为：核、国、S、X、函。</p>\n</blockquote>\n<ul>\n<li>&lt;c:out value&#x3D;”” default&#x3D;””&gt;标签&lt;&#x2F;c:out&gt;，用于输出元素。</li>\n</ul>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>常用API：</p>\n<ul>\n<li>Driver接口：所有JDBC程序必须实现的接口，专门给数据库厂商使用。</li>\n<li>DriverManager类：用于加载JDBC驱动并且建立与数据库的连接。有两个比较重要的静态方法：</li>\n</ul>\n<ol>\n<li>registerDriver(Driver driver);注册数据库驱动</li>\n<li>getConnection(String url, String user, String pwd);建立连接返回Connection对象。</li>\n</ol>\n<p>连接数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forname(<span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=GMT%2B8&quot;</span>;</span><br><span class=\"line\">conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure>\n\n<p>这样一个连接就建立完成了。</p>\n<ul>\n<li>Statement接口：用于执行静态的SQL语句</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stmt = conn.createStatement();</span><br><span class=\"line\">ResultSet rs=stmt.excute(<span class=\"string\">&quot;select * from users&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(rs.next())&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id=GetInt(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\">    String name=GetString(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>ResultSet：用于保存查询结果，可以保存单条或多条，使用rs.next()遍历。</p>\n</li>\n<li><p>PreparedStatement接口：封装了JDBC执行SQL语句的方法，完成Java调用SQL的功能。</p>\n</li>\n</ul>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h3 id=\"Spring的优良特性\"><a href=\"#Spring的优良特性\" class=\"headerlink\" title=\"Spring的优良特性\"></a>Spring的优良特性</h3><ul>\n<li>非侵入式：基于Spring开发的应用程序对象可以不依赖于Spring的API。举个例子，使用Spring initializr初始化了一个Spring项目，但是可以不使用Spring风格的注解写Controller，可以使用Servlet写。</li>\n<li>控制反转IoC：将对象的创建权交给Spring，以前都是我们手动创建对象，现在是由Spring创建。常常使用容器管理，这些容器使用反射、配置文件或注解来定义对象之间的依赖关系，并提供了自动注入依赖的机制。例如，使用@Bean之类的方法控制反转，类会成为一个Bean，当有需要的时候，会自动创建（如@Resource，@Autowired等。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserRepository <span class=\"title function_\">userRepository</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserRepositoryImpl</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//当注册为Bean的时候，可以在其他地方有需要时自动引入。</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService <span class=\"title function_\">userService</span><span class=\"params\">(UserRepository userRepository)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>(userRepository);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>依赖注入DI：实现控制反转的一种方法，指的是依赖的对象不需要手动调用set方法设置，而是通过配置赋值。例如Spring的JDBC连接，将对应的配置文件写好，然后在任何地方都可以调用@Mapper等方法实现。</p>\n</li>\n<li><p>面向切面编程AOP：用于将横切关注点（cross-cutting concerns）与核心业务逻辑分离。横切关注点指的是那些在应用程序中多处重复出现的功能，例如日志记录、事务管理、安全性检查等。例如，可以使用AOP的思想自动设置时间等审计字段的更新。</p>\n</li>\n<li><p>容器化与组件化：容器化是指Spring包含并管理对象的生命周期，组件化是指通过各种组件配置组合形成一个复杂的应用，使用xml或注解组合对象。</p>\n</li>\n<li><p>一站式：可以整合各种框架和第三方库，实际上Spring自身也提供了表述层的SpringMVC和持久层的Spring JDBC。</p>\n</li>\n</ul>\n<blockquote>\n<p>表述层是指应用程序中处理用户请求和生成响应的部分。它负责将用户的输入转化为可理解的数据，并将处理结果以适合用户的方式进行呈现。</p>\n</blockquote>\n<p>Spring 可以使开发人员使用 <strong>POJOs</strong> 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 <strong>EJB</strong> 容器产品（企业级JavaBeans），比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</p>\n<blockquote>\n<p>POJO是”Plain Old Java Object”的缩写，它是一种简单的Java对象，没有任何特殊要求或限制。POJO是一种纯粹的普通Java对象，不依赖于任何特定的框架、接口或类库。</p>\n</blockquote>\n<h3 id=\"Spring框架体系结构\"><a href=\"#Spring框架体系结构\" class=\"headerlink\" title=\"Spring框架体系结构\"></a>Spring框架体系结构</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312192150920.webp\" alt=\"image-20231219214854914\"></p>\n<p>最下层是Test模块，然后是Core Container模块。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312192151924.webp\" alt=\"image-20231219215119695\"></p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://veni222987.github.io/tags/Java/"}]},{"title":"WSL食用指南","date":"2023-12-15T15:25:19.000Z","path":"2023/12/15/WSL食用指南/","text":"这是一个WSL开发的使用指南，可以享受Linux的开发环境和Windows的办公环境（主要是买不起Mac）。下面是使用WSL开发的基本指南。 WSL食用指南基础配置篇CentOS已经停止维护，推荐使用Debian，轻量且稳定。 要想使用Debian开发，需要完成下面几件事情： 更换apt源，阿里源或者清华源都可（如果是云服务器则不需要手动换源，一般对应厂商已经换好）。 apt install build-essentials，各种开发的基础。 换源教程： 安装Debian 12.0(bookworm)，执行apt update更新apt。 下载https支持： 1apt install apt-transport-https ca-certificates 修改清华源： 123456789101112# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contribdeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contribdeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contribdeb https://security.debian.org/debian-security bookworm-security main contrib# deb-src https://security.debian.org/debian-security bookworm-security main contrib 再次执行apt update 下载必要的编译环境，这是各类开发包的基础，如不安装，则无法安装其他部分SDK。 1apt install build-essential 之后就可以按需安装需要的软件了 开发篇网络调试使用WSL开发后端，进行接口调试的时候可以有多种方式。 IDE端口转发一种是直接使用IDEA(或其他IDE的类似功能)的端口转发。如下图所示：将2345端口转发到主机的13151端口，之后调用localhost:13151端口访问。每次启动都会改变端口，推荐前端使用此方法调用，例如开发Vue等项目需要运行的时候，可以使用本机浏览器测试。 使用netsh interface portproxy转发另外一种是放行WSL的防火墙，进行接口调试。这种方法设置的ip长期有效，端口固定，在使用APIFOX的时候不用每次都修改端口号。推荐后端开发使用此方法。步骤如下： 查看WSL的ip地址：ip address： 修改Windows网络转发规则： 1netsh interface portproxy add v4tov4 listenport=5354 listenaddress=0.0.0.0 connectport=5354 connectaddress=172.18.157.129 listenport, 表示要监听的 Windows 端口listenaddress, 表示监听地址, 0.0.0.0 表示匹配所有地址, 比如Windows 既有Wifi网卡, 又有有线网卡, 那么访问任意两个网卡, 都会被监听到,当然也可以指定其中之一的IP的地址connectaddress ,要转发的地址, 这里设置为localhost, 是因为,我们可以通过localhost来访问WSL2, 如果暂不支持, 这里需要指定为 WSL2的IP地址connectport, 要转发到的目标端口，即虚拟机监听的端口 推荐转发的端口以2xxxx命名，与To同音，例如28080, 28088, 26379 附netsh的常用指令： 查看端口转发： 1netsh interface portproxy show all 删除端口转发： 1netsh interface portproxy delete v4tov4 listenport=5354 listenaddress=0.0.0.0 这个时候，对于本机而言，使用127.0.0.1:5354访问和使用172.18.157.129:5354访问的结果是一样的，都可以正常访问WSL中启动的后端项目。 局域网访问：使用防火墙配置入站规则，放行对应端口后，重启电脑即可。 使用容器转发使用容器,来配置web服务,显然是最佳选择,这个时候你就会遇到本文的问题,因为你可能希望让其他主机来访问你的容器服务!但是还未实践，此处略过。","content":"<p>这是一个WSL开发的使用指南，可以享受Linux的开发环境和Windows的办公环境（主要是买不起Mac）。下面是使用WSL开发的基本指南。<span id=\"more\"></span></p>\n<h1 id=\"WSL食用指南\"><a href=\"#WSL食用指南\" class=\"headerlink\" title=\"WSL食用指南\"></a>WSL食用指南</h1><h2 id=\"基础配置篇\"><a href=\"#基础配置篇\" class=\"headerlink\" title=\"基础配置篇\"></a>基础配置篇</h2><p>CentOS已经停止维护，推荐使用Debian，轻量且稳定。</p>\n<p>要想使用Debian开发，需要完成下面几件事情：</p>\n<ol>\n<li>更换apt源，阿里源或者清华源都可（如果是云服务器则不需要手动换源，一般对应厂商已经换好）。</li>\n<li>apt install build-essentials，各种开发的基础。</li>\n</ol>\n<p>换源教程：</p>\n<ul>\n<li><p>安装Debian 12.0(bookworm)，执行<code>apt update</code>更新apt。</p>\n</li>\n<li><p>下载https支持：</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改清华源：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class=\"line\">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb https://security.debian.org/debian-security bookworm-security main contrib</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">deb-src https://security.debian.org/debian-security bookworm-security main contrib</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>再次执行<code>apt update</code></li>\n<li>下载必要的编译环境，这是各类开发包的基础，如不安装，则无法安装其他部分SDK。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install build-essential</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以按需安装需要的软件了</p>\n<h2 id=\"开发篇\"><a href=\"#开发篇\" class=\"headerlink\" title=\"开发篇\"></a>开发篇</h2><h3 id=\"网络调试\"><a href=\"#网络调试\" class=\"headerlink\" title=\"网络调试\"></a>网络调试</h3><p>使用WSL开发后端，进行接口调试的时候可以有多种方式。</p>\n<h4 id=\"IDE端口转发\"><a href=\"#IDE端口转发\" class=\"headerlink\" title=\"IDE端口转发\"></a>IDE端口转发</h4><p>一种是直接使用IDEA(或其他IDE的类似功能)的端口转发。如下图所示：将2345端口转发到主机的13151端口，之后调用localhost:13151端口访问。每次启动都会改变端口，推荐前端使用此方法调用，例如开发Vue等项目需要运行的时候，可以使用本机浏览器测试。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312152331769.webp\" alt=\"image-20231215233103387\"></p>\n<h4 id=\"使用netsh-interface-portproxy转发\"><a href=\"#使用netsh-interface-portproxy转发\" class=\"headerlink\" title=\"使用netsh interface portproxy转发\"></a>使用netsh interface portproxy转发</h4><p>另外一种是放行WSL的防火墙，进行接口调试。这种方法设置的ip长期有效，端口固定，在使用APIFOX的时候不用每次都修改端口号。推荐后端开发使用此方法。步骤如下：</p>\n<p>查看WSL的ip地址：<code>ip address</code>：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312152340280.webp\" alt=\"image-20231215234033137\"></p>\n<p>修改Windows网络转发规则：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh interface portproxy add v4tov4 listenport=<span class=\"number\">5354</span> listenaddress=<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span> connectport=<span class=\"number\">5354</span> connectaddress=<span class=\"number\">172</span>.<span class=\"number\">18</span>.<span class=\"number\">157</span>.<span class=\"number\">129</span></span><br></pre></td></tr></table></figure>\n\n<p><code>listenport</code>, 表示要监听的 Windows 端口<br><code>listenaddress</code>, 表示监听地址, 0.0.0.0 表示匹配所有地址, 比如Windows 既有Wifi网卡, 又有有线网卡, 那么访问任意两个网卡, 都会被监听到,当然也可以指定其中之一的IP的地址<br><code>connectaddress</code> ,要转发的地址, 这里设置为localhost, 是因为,我们可以通过localhost来访问WSL2, 如果暂不支持, 这里需要指定为 WSL2的IP地址<br><code>connectport</code>, 要转发到的目标端口，即虚拟机监听的端口</p>\n<blockquote>\n<p>推荐转发的端口以2xxxx命名，与To同音，例如28080, 28088, 26379</p>\n</blockquote>\n<p>附netsh的常用指令：</p>\n<p>查看端口转发：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh interface portproxy show all</span><br></pre></td></tr></table></figure>\n\n<p>删除端口转发：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh interface portproxy delete v4tov4 listenport=<span class=\"number\">5354</span> listenaddress=<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候，对于本机而言，使用127.0.0.1:5354访问和使用172.18.157.129:5354访问的结果是一样的，都可以正常访问WSL中启动的后端项目。</p>\n<ul>\n<li>局域网访问：使用防火墙配置入站规则，放行对应端口后，重启电脑即可。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202312160029651.webp\" alt=\"image-20231216002903288\"></p>\n<h4 id=\"使用容器转发\"><a href=\"#使用容器转发\" class=\"headerlink\" title=\"使用容器转发\"></a>使用容器转发</h4><p>使用容器,来配置web服务,显然是最佳选择,这个时候你就会遇到本文的问题,因为你可能希望让其他主机来访问你的容器服务!但是还未实践，此处略过。</p>\n","categories":[{"name":"tools","slug":"tools","permalink":"https://veni222987.github.io/categories/tools/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://veni222987.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"【Sangfor】深信服产品介绍与最佳实践","date":"2023-10-18T11:17:39.000Z","path":"2023/10/18/【Sangfor】深信服超融合HCI/","text":"通过本文，你将了解到深信服产品的技术以及学习深信服产品的最佳实践，包括HCI、aDesk、EDS和AD等产品。。 深信服超融合HCIHCI产品简介HCI产品基础 深信服HCI(Hyper-Converged Infrastructure)定位云平台的软硬件，聚焦服务器、虚拟化、数据中心和交付等。深信服的HCI只需要通用的服务器和交换机软件，就可以利用软件技术构建计算、存储、网络和安全的统一资源池，实现基础架构的简化。 与传统的云基础架构（烟囱架构）相比，HCI只需要两种设备即可实现IT的基础要求，而传统的云平台需要服务器、存储设备、网络设备等等，维护成本高，运维复杂。 深信服HCI具有极简、可靠、高性能、更安全等特点。 深信服HCI的应用场景： 新建数据中心 数据中心改造场景 CPU应用承载 K8S应用承载 HCI关键特性深信服HCI关键特性可以由下图概括： 包括了安全特性，平台特性和高可用性等方面。 aSV服务器虚拟化aSV是深信服服务器虚拟化技术，具备了热迁移、HA高可用、动态资源调度DRS和动态资源添加DRX的四个基础功能。还有一些其他的优势特性和功能。 aSV（包括其他的服务器虚拟化）解决了什么问题？ 提供资源利用率：一台服务器可以运行多台虚拟机，彼此独立运行，互不影响 提高扩展能力：根据负载情况手动调整资源 提高生产效率：硬件故障、软件故障（重装系统）等速度快 提高业务可用性：热迁移保障可用性 提高运维效率：硬件资源、虚拟机资源可视化和统一管理 热迁移热迁移保障了业务的高可用性，当管理员需要进行硬件维护、主机变更等操作的时候，aSV可以在不影响业务的情况下完成迁移操作。 关键技术：无需外置存储、零宕机时间、兼容外部存储 支持场景：集群内热迁移、集群内跨存储热迁移、跨集群热迁移 HA(High Availability)高可用HA（High Availability）高可用是指在系统或服务出现故障时，能够保持持续可用性和稳定性的能力。HA的目标是确保系统的连续性，最小化服务中断和数据丢失的风险。虚拟机实现HA的前提条件： 虚拟化集群服务器不少于2台。 必须配置共享存储（磁盘阵列、分布式存储均可）。 剩余主机必须有足够的资源供业务恢复使用。 在软件质量架构中，”Availability”（可用性）属性是指系统或应用程序在所需的时间内正常运行和提供服务的能力。它是衡量系统可靠性和可用性的重要指标之一。 应用场景：虚拟机系统异常卡死、操作系统无响应，虚拟机蓝屏、黑屏等等。 虚拟机HA实现了当业务故障的时候自动、迅速切换到另外的云计算资源上，保持业务的高可用，业务恢复耗时在分钟级。 分布式管理平台 平台内置WAF等安全功能 同意可视化资源管理和运维 纳管VMware和业务双向迁移 集群环境一键检测 行业应用向导 aSAN存储虚拟化aSAN(Storage Area Network)深信服分布式存储的技术，是一款自主开发的分布式存储系统，利用虚拟化技术“池化”集群存储卷内的磁盘，实现存储资源统一管理，向上提供NFS&#x2F;iSCSI存储接口，广泛应用于HCI，aDesk和EDS三大系统。 aSAN具备防脑裂仲裁机制，但是集群内必须部署3台以上的设备。读一下脑裂的定义就明白了，如果只有两台主机，那么顶多有一条边。当子节点无法通讯的时候，相当于删除一条边，那么集群就分裂成为了两个独立的子集群。 脑裂（brain split）是指在分布式计算环境中，发生了网络或硬件故障导致集群中的节点无法相互通信，从而导致集群分裂成多个独立的子集。这种情况下，每个子集都认为其他子集中的节点已经失效，因此会独立地继续运行和处理任务。 数据副本机制主要功能特征： 每份数据在存储层保留2-3副本 副本所存放的位置必须满足主机互斥原则，不能将两个副本同时存放在同一台主机上（不然一台物理主机崩溃就会丢失全部数据） 支持以虚拟机或虚拟磁盘为单位设置副本，支持灵活修改副本数 数据快速重建 应用场景： 当集群内硬盘或主机出现故障，部分数据处于单副本状态，可以通过故障重建的方式恢复损坏的数据。 可容忍的故障程度： 两副本：可容忍集群内单台主机硬盘全部故障 三副本：可容忍集群内两台主机硬盘全部故障，可容忍集群内非同一主机下2块硬盘故障 特性： 全局参与，多并发：从多个源端磁盘读取，往多个目的磁盘写入 智能重建：根据上层的I&#x2F;O情况动态调整重建所用的I&#x2F;O 分级重建：优先保障重要数据，分等级上传 亚健康检测和处理亚健康介质包括慢盘、坏道过多、寿命到期的SSD等等，亚健康对于系统的危害十分严重。 处理方法： 读写算法降级：降低算法的优先级，不在从该盘读写 亚健康数据迁移：将数据迁到健康的介质 主动对坏道扫描：及时修理 克隆技术 链接克隆：利用快照技术，基于原镜像生成映射关系秒级拉起虚拟机，缺点是存在依赖关系，有额外性能开销 全量克隆：基于原计算克隆一份新的镜像后开机，缺点是启动速度满 快速全量克隆：利用快照技术拉起虚拟机后，持续拷贝原镜像数据，拷贝完成后，脱离依赖关系 高性能技术——磁盘分卷将多个硬盘分成不同的卷，深信服的分卷包括全闪卷和混闪卷。 高性能技术——存储分层分层是aSAN缓存系统中最主要的性能层，SSD分层的核心思想是： 写操作可以快速地写入分层中，立即向上返回写入成功，然后再将数据写到HDD中。 读操作尽可能直接从分层中读取数据，无需从HDD中读取。 存储分层的工作原理如下： 高性能技术——智能条带化 此外aSAN还具有AI硬盘故障检测的能力，以及提供存储容量、硬盘寿命分析的能力。 aNET网络虚拟化aNET是深信服网络安全虚拟化的一项技术，具备四个关键特性：网络虚拟化、网络功能虚拟化、分布式虚拟防火墙、业务逻辑拓扑。 网络虚拟化技术：采用分布式虚拟交换机aSwitch和虚拟路由器 网络功能虚拟化：虚拟路由器具备NAT，DNS等等网络功能 分布式防火墙： 面向虚拟机的安全策略部署 业务逻辑拓扑——所画即所得 在画网络拓扑图的过程中采用智能算法、优化网络拓扑结构。 aSAN注意事项aSAN平衡的实现方式中，目标磁盘不可以是多个，只能是单个。 HCI最佳实践这里仅记录一下不同的产品服务的注意事项，各位读者可以自行去实操体验。 HCI性能最佳实践硬件配置 磁盘：深信服一体机系统盘默认最低使用128G SSD盘。 RAID卡：使用aSAN，缓存盘和数据盘必须配置成non-raid或者jbod模式。 网卡：支持巨帧，推荐配置6*GE，2*10GE（6个千兆口，2个万兆口） 交换机：建议每个网络平面采用堆叠的两个交换机，在端口足够的情况下考虑交换机复用 虚拟机配置 vCPU配置 随着vCPU的增加，性能提升是非线性的，而是对数增长。需要配置虚拟插槽数和每个插槽的核数。配置时，虚拟插槽数不要超过物理CPU个数，插槽核数也不要超过单个CPU的核数。 启用NUMA调度：vCPU本地内存访问，不会跨NUMA节点。 推荐默认不使用Host CPU，只有当虚拟机性能不足时才启用。 内存配置 配置内存是指最大的可用内存。配置内存时，不能超过集群中单台主机的最大物理内存。建议关闭内存回收。 极端情况下虚拟机的内存超过主机内存，这时大量使用了交换分区。推荐内存不超配，所有开机虚拟机配置内存不要超过物理机的0.9。 内存分配的注意事项：如果配置了aSAN，预留32G，否则预留12G。Swap分区大小swap=memory&lt;96GB?memory*2:memory，不超过系统盘剩余空间的50%，最低8GB，最高256GB。 内存分配公式：分配内存=总内存-预留内存+swap*0.2。 虚拟磁盘配置 虚拟磁盘的个数多少与虚拟磁盘的性能无直接关系，例如一块2T的和两块1T的硬盘性能是一样的（不考虑条带化等技术）。 裸磁盘映射的大小和性能都由裸磁盘本身决定，无调优参数。 预分配可以大幅提升IOPS和吞吐，但是会浪费一些存储空间。对于数据库等对IO要求高的应用，建议使用预分配，一般虚拟机不建议使用，浪费空间。 虚拟网络配置 VXLAN网络通信：虚拟网络内部集群内同一网段内部的虚拟机之间的跨主机流量成为“东西向流量”，深信服在企业服务器内设置了隧道，增加VXLAN报头封装虚拟机跨主机二层通信报文，通过vxlan隧道实现跨主机通信。 物理出口：用来连接虚拟网络和物理网络，每台服务器至少配置2*GE网口作为物理出口，并做网口聚合绑定。交换机需要关闭stp协议，保障网络稳定性。 虚拟存储配置 推荐存储网络使用2*10GE两个万兆口 SSD缓存盘：SSD可为其磁盘组下的HDD提供缓存加速的能力。SSD和HDD的个数比推荐值为1：3，不能低于1：7。 存储卷：使用存储多卷，要求每个存储卷的主机数量至少为3台。建议一个集群内不配置超过3个卷，单个卷内主机数不超过12台。 建议使用三台以上的主机组成一个虚拟存储卷，可以获得条带化的效果和仲裁机制。 HCI管理（重点！）HCI初始化有如下的条件： 根据集群内所有主机的CPU颗数购买充足的首选。 单主机不支持虚拟存储；普通集群至少要求2台以上的主机，如果需要虚拟存储的条带化功能或使用虚拟存储多卷功能，则需要3台以上的主机。 延伸集群至少需要4主机起步，加上一个仲裁节点。 禁止单台主机部署HCI。 HCI有USE-Key（离线）授权和vKEY（在线）授权两种方式。 HCI产品功能集群资源调度DRSDRS全称是Distributed Resource Scheduler，指集群资源调度，顾名思义，在特定场景下会调度集群资源，这里的资源指的是虚拟机。我们的DRS会设置CPU和内存阈值，如果超过阈值，就会触发DRS。 DRS有自动和手动两种，对于选了自动的虚拟机，DRS会配置自动选择合适的主机来运行。而对于那些指定了运行位置的虚拟机，DRS不会对其进行操作。 集群资源动态热添加DRXDRX全称是Dynamic Resource Extension，指动态资源拓展。虚拟机资源不足，主机资源空闲的时候，自动为虚拟机添加CPU或者内存。 HCI产品应用场景信服云迁移工具信服云迁移工具可以供业务迁移能力(P2V，V2V)，可满足以下的业务场景要求： 注意是不会影响被迁移，不是不会被热迁移。蓝屏，USB和接受迁移目标资源不足都会影响虚拟机被热迁移。 HCI产品运维深信服桌面云aDesk 在深信服Webconsole界面中，sock命令与telnet命令相似。 VMP（Virtualization Management Platform）是虚拟化管理平台的缩写。VDC(Virtual Desktop Controller)是桌面控制系统的缩写。VDI是虚拟桌面基础设施（Virtual Desktop Infrastructure）的缩写。它是一种技术和架构，用于在服务器上创建和管理虚拟桌面环境，从而提供集中式的桌面虚拟化解决方案。 可以与VMware对比的是VMP平台都用于管理虚拟机，VDC相当于一个C&#x2F;S架构应用程序的服务器端，VDI是客户端。 所以，使用aDesk之前必须要先完成VMP的部署和VDC的部署，而这两个平台的部署都是基于HCI的，所以在此之前还需要完成HCI的部署。下面是完成HCI部署之后的平台部署流程图： VMP安装VMP叫做虚拟化管理平台，理论上每一台虚拟机都应该安装VMP。而HCI将这些虚拟资源整合在一起，形成一个统一的平台，用于构建和管理虚拟化环境。HCI通常由多台物理服务器组成，每台服务器上运行着虚拟化软件，并通过网络进行通信和数据共享。 安装VMP的过程和安装HCI类似，都是获取到了iso镜像之后，在系统启动之时进入BIOS安装。 前提条件 VMP系统镜像 U盘&#x2F;刻录光盘 普通PC（用于控制，制作iso镜像） 需要安装VMP的服务器 VMP硬件配置要求： VMP授权管理： VMP除了可以使用Key授权之外，还可以借助aCenter实现对VMP和VDC的统一授权，在多集群&#x2F;多分支情况下，随意回收和修改授权。 aCenter已经通过了Key进行授权，并且VMP节点已经加入了aCenter。 通过aCenter下发授权至分支节点后，该分支节点原有的授权无效，只继承aCenter所下发的授权。 通过aCenter进行统一的授权后，分支节点的授权key可拔出回收。 修改授权后，VDC会重启服务来更新授权信息。 VMP创建VDC再复习一下，VDC(Virtual Desktop Controller)是桌面控制系统的缩写。 在上一步完成了VMP的安装之后，就可以登录VMP控制台，设置ip等信息创建全新的虚拟机，然后创建VDC，一般VDC运行在4430端口上。如果想要更好的理解，可以把VMware想象成为一个Web应用，那么VDC就是服务器，VDI就是客户端。 VDC集群的介绍 VDC集群的各个节点（VDC设备）由一个分发器和一组真实服务器组成，分发器和真实服务器都是VDC设备。网络客户接入VDI的时候，会由分发器合理的分配给集群中最空闲的真实服务器为客户提供服务。 VDC集群的要求： 存在两台VDC并且版本是一致的，确认VDC的ip地址处在同一个内网网段内。 每台VDC设备上均需要启用集群部署，并且需要配置相同的集群ip。 软件VDC和硬件VDC可以组件集群。 禁止将克隆出的软件VDC和克隆前的软件VDC组件集群。 VDC用户认证管理 VDC用户认证管理的主要方式有三种：本地密码认证、LDAP认证和第三方接口认证，可以看aDesk用户管理的部分。 授权码的注意事项如下： 创建VDC步骤： win操作机登录HCI 选择存储——本地存储 系统管理——端口管理——桌面云接入服务 虚拟机导入界面，导入虚拟机的vma镜像文件 点击转到虚拟机，开机，选择NetworkSetup Wizard，配置ip为VDC的管理ip。 部署完成后，浏览器访问https://VDCip:4430即进入VDC。 新建虚拟化管理平台控制器，输入控制器地址，测试连接。 VDC管理 在VDC管理过程中，每个用户拥有的硬件特征码个数默认为5个（五种设备？？？）。 VMP创建VDI 创建VDI的步骤： win操作机登录HCI 选择上面的虚拟机（VDC已经创建好的） 选择下面的桌面应用，创建全新VDI虚拟机 填写VDI虚拟机信息 安装系统，配置网络 最佳实践： VDI5.4.1开始支持多卷功能，如果是单主机或者双主机只允许创建一个卷；当系统中已存在一个卷的时候，未加入主机数小于3的时候不再允许新加卷。 单卷最大支持24主机，最佳实践是8-12为一个卷，VMP单集群最大支持创建3个卷。 aCenter平台的部署aCenter是虚拟化集中管理平台，适用于VMP集群分布式部署场景。通常将aCenter部署于企业内部，通过公网、专线等方式对各分支机构的VMP集群进行集中的监控、升级、管理和统一授权。 aCenter安装在物理主机 需要先将aCenter的ISO镜像通过UltraISO制作启动镜像。 物理主机最低配置为：4GB内存，65GB硬盘，千兆网卡。 aCenter安装在VMP平台： 与VMP上安装VDC虚拟机的过程大致相同，需要在虚拟机操作系统处选虚拟化集中管理平台aCenter，并将aCenter的ISO镜像挂载到虚拟机的光驱上，后续同物理机。配置要求也一样。 aDesk用户和用户组管理在aDesk上可以对VMP，VDC和VDI进行的用户进行管理。 主要认证还包括第三方认证。 LDAP（Lightweight Directory Access Protocol）认证是一种基于网络协议的身份验证机制，用于验证用户的身份和授权其访问特定资源。LDAP是一种应用层协议，用于访问和维护分布式目录服务（如LDAP服务器）中的信息。它使用客户端-服务器模型，其中客户端发起LDAP请求，服务器响应并提供所需的信息。 Radius（Remote Authentication Dial-In User Service）认证是一种网络身份验证协议，用于验证和授权用户对网络资源的访问。Radius认证是一种客户端-服务器认证协议，广泛用于网络接入服务，特别是拨号和虚拟专用网络（VPN）服务。它提供了一种中心化的认证和授权机制，允许用户通过一组凭据（例如用户名和密码）进行身份验证，并授予他们访问网络资源的权限。 客户端接入常见的终端接入： 请注意，移动终端不支持登录linux虚拟机，但是可以访问windows虚拟机。 分布式防火墙 传统终端安全的实现方式 接入交换机ACL控制终端PC间互访流量，，防止出现一些主机沦陷病毒扩散问题。 网络防火墙部署在区域边界节点控制区域互访流量。 计算机软件防火墙保护计算机系统环境安全。 分布式防火墙 分布式防火墙适用场景： 用户对于虚拟机之间的网络有微隔离要求。 出现诸如勒索病毒一类内网安全事件，需要阻断病毒横向传播场景。 使用传统基于IP做策略的方式难以满足实际网络访问控制需求的场景（如池桌面）。 新增策略的三种方式：新建策略、复制策略和导入策略。 报表中心(Sangfor VDC Report Center) 报表中心简介 报表中心可以对VDC和VMP上的数据进行收集，存储和展示，主要包括数据查询、数据分析、报表导出等功能。 针对VDC传输的数据可以分为：资产信息、管理日志、安全日志、安全策略、并发会话数。 针对VMP传递的数据可以分为：服务器存储趋势、服务器负载。 针对用户虚拟机的数据则提供文件导出审计页面。 报表中心适用场景： 请注意，一个桌面云上的报表中心最多能关联1个VDC集群。 显卡虚拟化3D部署 桌面虚拟化的两种架构： 3D桌面显卡虚拟化(vGPU)优势 实验Agent安装agent是桌面云的一个重要的组件，虚拟机的正常使用，离不开agent的正常运行。在虚拟机上安装Agent的方法是：虚拟机上面的管理栏下，有安装Agent的相关选项。 注意！安装Agent后会重启虚拟机。安装Agent之前要安装vmtools：在虚拟机那一栏下拉。 独享桌面资源的创建 登入HCI 虚拟机模板管理——虚拟机转模板 业务中心——资源管理——新建独享桌面 按要求配置信息，保存 桌面云用户接入实验 登录HCI 业务中心——用户管理——新建 输入用户相关信息 安装VDI客户端并打开 输入服务器地址，用户名和密码 深信服分布式存储EDS 存储常见技术 备份与容灾容灾（Disaster Recovery）是一种综合性的策略和实践，旨在保护和恢复组织的关键业务和数据，以应对各种灾难性事件，如自然灾害、硬件故障、人为错误等。容灾的目标是在灾难发生时，能够尽快地恢复业务运营和数据访问，并最小化停机时间和数据丢失。 备份（Backup）是一种数据保护的措施，旨在创建数据的副本并存储在另一个位置，以防止数据丢失或损坏。备份可以用于恢复单个文件、文件夹、数据库或整个系统。 RTO（恢复时间目标）是指在发生灾难性事件后，系统需要恢复正常运行所需的时间。它代表了从灾难发生到系统完全恢复正常运行的时间窗口。较短的RTO意味着系统能够更快地恢复，尽快恢复业务运营，减少停机时间和业务中断。RTO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。 RPO（恢复点目标）是指在发生灾难性事件后，系统需要恢复到的数据恢复点。它代表了在灾难发生前的系统数据状态。较小的RPO意味着系统能够更少地丢失数据，尽可能接近灾难发生前的最新数据。RPO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。RPO越小，丢失的数据越少。 EC（Erasure Coding）机制和副本机制是在分布式存储系统中用于数据可靠性和容错性的两种不同策略。 EC机制是一种纠删码技术，它将原始数据分割成多个数据块，并通过添加冗余数据块来实现数据的冗余和容错。EC可以在数据丢失或损坏的情况下进行数据恢复，而不需要完全复制原始数据。 副本机制是一种简单而直接的数据冗余策略，它通过完全复制数据来实现容错性。在副本机制中，原始数据会被完全复制到多个存储节点上，以确保数据的可靠性。如果某个节点发生故障或数据损坏，可以通过其他副本来恢复数据。 RAID介绍 传统存储与分布式存储 EDS架构简介 EDS产品应用场景EDS产品的应用场景涵盖了块存储、文件存储和对象存储三个方面。 EDS产品运维EDS存储巡检：存储巡检是一种定期检查和评估存储系统的健康状况和性能的过程。它旨在发现和解决潜在的问题，以确保存储系统的稳定性、可靠性和性能。 进行存储巡检是商业维度，技术维度和其他维度的综合考量结果。可以使用深信服adeploy服务（一个可执行文件）进行存储巡检。 深信服应用交付AD平台网络部署 深信服AD的集群部署模式种，1个浮动IP顶多在1台设备上生效。 深信服AD的集群模式中，当组件集群的AD版本号不一致的时候，健康状态应为故障。 网络部署基础网口配置在HCI的网络部署——网口配置页面，可以配置网口的协商模式，推荐使用Auto配置。 端口聚合端口聚合可以将多个物理接口当作一个单一的逻辑接口来处理，它允许两台设备之间通过多个接口并行连接同时传输数据以提供更高的带宽，更大的吞吐量和可恢复性技术。主要有如下优点： 增加带宽：带宽相当于聚合的端口的带宽总和。 增加冗余：其中一个端口坏了还能工作，只是带宽变小。 负载均衡：可以在组内接口上配置，是流量在接口上自动进行负载均衡。 操作方法：新建聚合接口——选择绑定策略——选择绑定接口。 VLAN子接口某些情况下与AD设备对接的网口为TRUNK口，要求AD设备对应的接口也可以封装VLAN划分子接口，此时需要配置VLAN子接口。 端口桥接在一些较为复杂的网络结构中，需要AD设备能将两个口划分到一个广播域内，相当于将AD设备的多个口组成一个二层交换机，此时就需要网口桥接功能。 负载均衡 ECMP是传统边界路由器的运营商链路负载方式。 策略路由是传统的边界路由器的运营商链路负载方式。 路由器策略路由链路负载方式无法根据带宽动态调整，调度策略不灵活，资源利用率低。 ECMP是一种路由算法，用于在网络中选择多个等价路径来转发数据流量。当存在多个具有相同开销（cost）的路径时，ECMP允许路由器将数据流量分散到这些路径上，以实现负载均衡和提高网络性能。ECMP通常在网络中的内部路由中使用，例如在数据中心网络中。 策略路由是一种根据特定的策略或条件，动态选择路由路径的方法。与传统的静态路由不同，策略路由可以根据网络中的不同因素（如流量负载、链路状态、服务质量要求等）来选择最佳路径，以实现更灵活的路由控制。 部署模式部署模式使之设备以什么样的工作方式部署到用户的网络中去，不同的部署方式对于网络影响各不相同。AD支持两种部署模式：网关模式和旁路模式。注意，配置AD设备的时候不需要在界面上选择部署模式，以什么样的方式接入客户网络就是什么部署模式。 网关部署模式一般是将AD部署在互联网出口或者是内网服务器前端，逻辑网络层面，设备有两个或多个接口连接到网络内，数据经过路由转发会穿过设备。设备配置里，既有WAN接口，也有LAN属性接口。 优点：AD的功能都能满足（出战负载、全局负载、应用负载等等） 缺点：此种部署对网络的改动比较大，建议在新建网络或者网络改造的时候部署。 旁路模式部署一般是AD旁路在接入或者核心交换机上 优点：无需改变原网络拓扑结构，只需要单臂挂在核心交换机，进行配置即可，对现有网络无影响 缺点：无法实现链路负载 三角传输模式一般是AD旁路部署在业务服务器同一台二层交换机下或同一个二层网络中，通过AD虚拟服务关闭DNAT和SNAT功能，服务器配置loopback口与虚拟服务相同IP实现。 优点：服务端可以看到客户端源IP；减轻AD流量负担，回来的包不经过AD设备，而是直接转发回客户端 缺点：AD无法感知服务器的loopback口健康状态；AD必须与服务器同网段部署。 高可用主备模式主备模式简介主备模式：两台AD双击部署，一台处于工作状态，另一台处于冷备状态。两台设备通过心跳口检测对端是否存在，并同步设备和会话。当主设备触发问题切换条件时，设备会自动地把业务切换到备用设备。 AD设备的各种部署模式都支持双机热备，以下是典型的拓扑图。 主备模式要求主备模式部署要求： 网口个数一样 内存大小一样 序列号一致 软件版本一致 主备模式的基本元素心跳口又叫HA口，主要功能是检测对端是否还存活，通常两台设备的心跳口通过网线直连，并且通过周期性地发送心跳口包来检测对端是否存活，并且有冗余保障机制。 故障切换用来检测主设备发生故障时，进行主备设备切换保证业务的连续稳定运行，切换条件可以由用户自己定义。 同步对象ACL访问控制策略配置ACL(Access Control List)访问控制列表，ACL基于数据连接的五元组来实现外到内或内到外的数据访问控制，可以提升网络的安全性。主要应用场景是禁止内网指定用户访问AD设备或禁止访问互联网，禁止外部主机访问设备或者AD设备发布的内网业务。 相关的配置在HCI的网络部署——网络安全——ACL配置路径。 健康检测深信服AD设备对某节点业务健康检查失败之后的处理动作：标记该节点异常；AD会将健康检查失败的节点从资源池中剔除；健康检查失败的节点将不能继续提供业务访问。但是会在资源池中继续进行健康检查。 在AD巡检的过程中，进行外观检查的时候，备机的alarm灯闪属于正常现象。主设备的alarm灯亮属于告警现象。 AD产品应用场景智能路由 适用场景 外网多条线路时，部署的传统路由器总是出现：链路调度不均衡，跨运营商访问慢","content":"<p>通过本文，你将了解到深信服产品的技术以及学习深信服产品的最佳实践，包括HCI、aDesk、EDS和AD等产品。。<span id=\"more\"></span></p>\n<h1 id=\"深信服超融合HCI\"><a href=\"#深信服超融合HCI\" class=\"headerlink\" title=\"深信服超融合HCI\"></a>深信服超融合HCI</h1><h2 id=\"HCI产品简介\"><a href=\"#HCI产品简介\" class=\"headerlink\" title=\"HCI产品简介\"></a>HCI产品简介</h2><h3 id=\"HCI产品基础\"><a href=\"#HCI产品基础\" class=\"headerlink\" title=\"HCI产品基础\"></a>HCI产品基础</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211628796.webp\" alt=\"image-20231021162852689\"></p>\n<p>深信服HCI(Hyper-Converged Infrastructure)定位云平台的软硬件，聚焦服务器、虚拟化、数据中心和交付等。深信服的HCI只需要通用的服务器和交换机软件，就可以利用软件技术构建计算、存储、网络和安全的统一资源池，实现基础架构的简化。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181936850.webp\" alt=\"image-20231018193613643\"></p>\n<p>与传统的云基础架构（烟囱架构）相比，HCI只需要两种设备即可实现IT的基础要求，而传统的云平台需要服务器、存储设备、网络设备等等，维护成本高，运维复杂。</p>\n<p>深信服HCI具有极简、可靠、高性能、更安全等特点。</p>\n<p>深信服HCI的应用场景：</p>\n<ul>\n<li>新建数据中心</li>\n<li>数据中心改造场景</li>\n<li>CPU应用承载</li>\n<li>K8S应用承载</li>\n</ul>\n<h3 id=\"HCI关键特性\"><a href=\"#HCI关键特性\" class=\"headerlink\" title=\"HCI关键特性\"></a>HCI关键特性</h3><p>深信服HCI关键特性可以由下图概括：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181951996.webp\" alt=\"image-20231018195137766\"></p>\n<p>包括了安全特性，平台特性和高可用性等方面。</p>\n<h4 id=\"aSV服务器虚拟化\"><a href=\"#aSV服务器虚拟化\" class=\"headerlink\" title=\"aSV服务器虚拟化\"></a>aSV服务器虚拟化</h4><p>aSV是深信服服务器虚拟化技术，具备了<strong>热迁移、HA高可用、动态资源调度DRS和动态资源添加DRX</strong>的四个基础功能。还有一些其他的优势特性和功能。</p>\n<p>aSV（包括其他的服务器虚拟化）解决了什么问题？</p>\n<ol>\n<li>提供资源利用率：一台服务器可以运行多台虚拟机，彼此独立运行，互不影响</li>\n<li>提高扩展能力：根据负载情况手动调整资源</li>\n<li>提高生产效率：硬件故障、软件故障（重装系统）等速度快</li>\n<li>提高业务可用性：热迁移保障可用性</li>\n<li>提高运维效率：硬件资源、虚拟机资源可视化和统一管理</li>\n</ol>\n<h5 id=\"热迁移\"><a href=\"#热迁移\" class=\"headerlink\" title=\"热迁移\"></a>热迁移</h5><p>热迁移保障了业务的高可用性，当管理员需要进行硬件维护、主机变更等操作的时候，aSV可以在不影响业务的情况下完成迁移操作。</p>\n<ul>\n<li>关键技术：无需外置存储、零宕机时间、兼容外部存储</li>\n<li>支持场景：集群内热迁移、集群内跨存储热迁移、跨集群热迁移</li>\n</ul>\n<h5 id=\"HA-High-Availability-高可用\"><a href=\"#HA-High-Availability-高可用\" class=\"headerlink\" title=\"HA(High Availability)高可用\"></a>HA(High Availability)高可用</h5><p>HA（High Availability）高可用是指在系统或服务出现故障时，能够保持持续可用性和稳定性的能力。HA的目标是确保系统的连续性，最小化服务中断和数据丢失的风险。虚拟机实现HA的前提条件：</p>\n<ol>\n<li>虚拟化集群服务器不少于2台。</li>\n<li>必须配置共享存储（磁盘阵列、分布式存储均可）。</li>\n<li>剩余主机必须有足够的资源供业务恢复使用。</li>\n</ol>\n<blockquote>\n<p>在软件质量架构中，”Availability”（可用性）属性是指系统或应用程序在所需的时间内正常运行和提供服务的能力。它是衡量系统可靠性和可用性的重要指标之一。</p>\n</blockquote>\n<p>应用场景：虚拟机系统异常卡死、操作系统无响应，虚拟机蓝屏、黑屏等等。</p>\n<p>虚拟机HA实现了当业务故障的时候自动、迅速切换到另外的云计算资源上，保持业务的高可用，业务恢复耗时在分钟级。</p>\n<ul>\n<li>分布式管理平台</li>\n<li>平台内置WAF等安全功能</li>\n<li>同意可视化资源管理和运维</li>\n<li>纳管VMware和业务双向迁移</li>\n<li>集群环境一键检测</li>\n<li>行业应用向导</li>\n</ul>\n<h4 id=\"aSAN存储虚拟化\"><a href=\"#aSAN存储虚拟化\" class=\"headerlink\" title=\"aSAN存储虚拟化\"></a>aSAN存储虚拟化</h4><p>aSAN(Storage Area Network)深信服分布式存储的技术，是一款自主开发的分布式存储系统，利用虚拟化技术“池化”集群存储卷内的磁盘，实现存储资源统一管理，向上提供NFS&#x2F;iSCSI存储接口，广泛应用于HCI，aDesk和EDS三大系统。</p>\n<p>aSAN具备防脑裂仲裁机制，但是集群内必须部署3台以上的设备。读一下脑裂的定义就明白了，如果只有两台主机，那么顶多有一条边。当子节点无法通讯的时候，相当于删除一条边，那么集群就分裂成为了两个独立的子集群。</p>\n<blockquote>\n<p>脑裂（brain split）是指在分布式计算环境中，发生了网络或硬件故障导致集群中的节点无法相互通信，从而导致集群分裂成多个独立的子集。这种情况下，每个子集都认为其他子集中的节点已经失效，因此会独立地继续运行和处理任务。</p>\n</blockquote>\n<h5 id=\"数据副本机制\"><a href=\"#数据副本机制\" class=\"headerlink\" title=\"数据副本机制\"></a>数据副本机制</h5><p>主要功能特征：</p>\n<ol>\n<li>每份数据在存储层保留2-3副本</li>\n<li>副本所存放的位置必须满足主机互斥原则，不能将两个副本同时存放在同一台主机上（不然一台物理主机崩溃就会丢失全部数据）</li>\n<li>支持以虚拟机或虚拟磁盘为单位设置副本，支持灵活修改副本数</li>\n</ol>\n<h5 id=\"数据快速重建\"><a href=\"#数据快速重建\" class=\"headerlink\" title=\"数据快速重建\"></a>数据快速重建</h5><ul>\n<li>应用场景：</li>\n</ul>\n<p>当集群内硬盘或主机出现故障，部分数据处于单副本状态，可以通过故障重建的方式恢复损坏的数据。</p>\n<ul>\n<li>可容忍的故障程度：</li>\n</ul>\n<p>两副本：可容忍集群内单台主机硬盘全部故障</p>\n<p>三副本：可容忍集群内两台主机硬盘全部故障，可容忍集群内非同一主机下2块硬盘故障</p>\n<ul>\n<li>特性：</li>\n</ul>\n<ol>\n<li>全局参与，多并发：从多个源端磁盘读取，往多个目的磁盘写入</li>\n<li>智能重建：根据上层的I&#x2F;O情况动态调整重建所用的I&#x2F;O</li>\n<li>分级重建：优先保障重要数据，分等级上传</li>\n</ol>\n<h5 id=\"亚健康检测和处理\"><a href=\"#亚健康检测和处理\" class=\"headerlink\" title=\"亚健康检测和处理\"></a>亚健康检测和处理</h5><p>亚健康介质包括慢盘、坏道过多、寿命到期的SSD等等，亚健康对于系统的危害十分严重。</p>\n<p>处理方法：</p>\n<ol>\n<li>读写算法降级：降低算法的优先级，不在从该盘读写</li>\n<li>亚健康数据迁移：将数据迁到健康的介质</li>\n<li>主动对坏道扫描：及时修理</li>\n</ol>\n<h5 id=\"克隆技术\"><a href=\"#克隆技术\" class=\"headerlink\" title=\"克隆技术\"></a>克隆技术</h5><ul>\n<li>链接克隆：利用快照技术，基于原镜像生成<strong>映射关系</strong>秒级拉起虚拟机，缺点是存在依赖关系，有额外性能开销</li>\n<li>全量克隆：基于原计算克隆一份新的镜像后开机，缺点是启动速度满</li>\n<li>快速全量克隆：利用快照技术拉起虚拟机后，持续拷贝原镜像数据，拷贝完成后，脱离依赖关系</li>\n</ul>\n<h5 id=\"高性能技术——磁盘分卷\"><a href=\"#高性能技术——磁盘分卷\" class=\"headerlink\" title=\"高性能技术——磁盘分卷\"></a>高性能技术——磁盘分卷</h5><p>将多个硬盘分成不同的卷，深信服的分卷包括全闪卷和混闪卷。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182120588.webp\" alt=\"image-20231018212026173\"></p>\n<h5 id=\"高性能技术——存储分层\"><a href=\"#高性能技术——存储分层\" class=\"headerlink\" title=\"高性能技术——存储分层\"></a>高性能技术——存储分层</h5><p>分层是aSAN缓存系统中最主要的性能层，SSD分层的核心思想是：</p>\n<ol>\n<li>写操作可以快速地写入分层中，立即向上返回写入成功，然后再将数据写到HDD中。</li>\n<li>读操作尽可能直接从分层中读取数据，无需从HDD中读取。</li>\n</ol>\n<p>存储分层的工作原理如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182127000.webp\" alt=\"image-20231018212714653\"></p>\n<h5 id=\"高性能技术——智能条带化\"><a href=\"#高性能技术——智能条带化\" class=\"headerlink\" title=\"高性能技术——智能条带化\"></a>高性能技术——智能条带化</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182130668.webp\" alt=\"image-20231018213056259\"></p>\n<p>此外aSAN还具有AI硬盘故障检测的能力，以及提供存储容量、硬盘寿命分析的能力。</p>\n<h4 id=\"aNET网络虚拟化\"><a href=\"#aNET网络虚拟化\" class=\"headerlink\" title=\"aNET网络虚拟化\"></a>aNET网络虚拟化</h4><p>aNET是深信服网络安全虚拟化的一项技术，具备四个关键特性：<strong>网络虚拟化、网络功能虚拟化、分布式虚拟防火墙、业务逻辑拓扑</strong>。</p>\n<ul>\n<li>网络虚拟化技术：采用分布式虚拟交换机aSwitch和虚拟路由器</li>\n<li>网络功能虚拟化：虚拟路由器具备NAT，DNS等等网络功能</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182140353.webp\" alt=\"image-20231018214001970\"></p>\n<ul>\n<li>分布式防火墙：</li>\n</ul>\n<p>面向虚拟机的安全策略部署</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182138016.webp\" alt=\"image-20231018213834692\"></p>\n<ul>\n<li>业务逻辑拓扑——所画即所得</li>\n</ul>\n<p>在画网络拓扑图的过程中采用智能算法、优化网络拓扑结构。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310182139280.webp\" alt=\"image-20231018213926916\"></p>\n<h4 id=\"aSAN注意事项\"><a href=\"#aSAN注意事项\" class=\"headerlink\" title=\"aSAN注意事项\"></a>aSAN注意事项</h4><p>aSAN平衡的实现方式中，目标磁盘不可以是多个，只能是单个。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211535391.webp\" alt=\"image-20231021153529235\"></p>\n<h2 id=\"HCI最佳实践\"><a href=\"#HCI最佳实践\" class=\"headerlink\" title=\"HCI最佳实践\"></a>HCI最佳实践</h2><p>这里仅记录一下不同的产品服务的注意事项，各位读者可以自行去实操体验。</p>\n<h3 id=\"HCI性能最佳实践\"><a href=\"#HCI性能最佳实践\" class=\"headerlink\" title=\"HCI性能最佳实践\"></a>HCI性能最佳实践</h3><h4 id=\"硬件配置\"><a href=\"#硬件配置\" class=\"headerlink\" title=\"硬件配置\"></a>硬件配置</h4><ul>\n<li>磁盘：深信服一体机系统盘默认最低使用128G SSD盘。</li>\n<li>RAID卡：使用aSAN，缓存盘和数据盘必须配置成non-raid或者jbod模式。</li>\n<li>网卡：支持巨帧，推荐配置6*GE，2*10GE（6个千兆口，2个万兆口）</li>\n<li>交换机：建议每个网络平面采用堆叠的两个交换机，在端口足够的情况下考虑交换机复用</li>\n</ul>\n<h4 id=\"虚拟机配置\"><a href=\"#虚拟机配置\" class=\"headerlink\" title=\"虚拟机配置\"></a>虚拟机配置</h4><ul>\n<li>vCPU配置</li>\n</ul>\n<ol>\n<li>随着vCPU的增加，性能提升是非线性的，而是对数增长。需要配置虚拟插槽数和每个插槽的核数。配置时，虚拟插槽数不要超过物理CPU个数，插槽核数也不要超过单个CPU的核数。</li>\n<li>启用NUMA调度：vCPU本地内存访问，不会跨NUMA节点。</li>\n<li>推荐默认不使用Host CPU，只有当虚拟机性能不足时才启用。</li>\n</ol>\n<ul>\n<li>内存配置</li>\n</ul>\n<p>配置内存是指最大的可用内存。配置内存时，不能超过集群中单台主机的最大物理内存。建议关闭内存回收。</p>\n<p>极端情况下虚拟机的内存超过主机内存，这时大量使用了交换分区。推荐内存不超配，所有开机虚拟机配置内存不要超过物理机的0.9。</p>\n<p>内存分配的注意事项：如果配置了aSAN，预留32G，否则预留12G。Swap分区大小<code>swap=memory&lt;96GB?memory*2:memory</code>，不超过系统盘剩余空间的50%，最低8GB，最高256GB。</p>\n<p>内存分配公式：<code>分配内存=总内存-预留内存+swap*0.2</code>。</p>\n<ul>\n<li>虚拟磁盘配置</li>\n</ul>\n<ol>\n<li>虚拟磁盘的个数多少与虚拟磁盘的性能无直接关系，例如一块2T的和两块1T的硬盘性能是一样的（不考虑条带化等技术）。</li>\n<li>裸磁盘映射的大小和性能都由裸磁盘本身决定，无调优参数。</li>\n<li>预分配可以大幅提升IOPS和吞吐，但是会浪费一些存储空间。对于数据库等对IO要求高的应用，建议使用预分配，一般虚拟机不建议使用，浪费空间。</li>\n</ol>\n<h4 id=\"虚拟网络配置\"><a href=\"#虚拟网络配置\" class=\"headerlink\" title=\"虚拟网络配置\"></a>虚拟网络配置</h4><ul>\n<li>VXLAN网络通信：虚拟网络内部集群内同一网段内部的虚拟机之间的跨主机流量成为“东西向流量”，深信服在企业服务器内设置了隧道，增加VXLAN报头封装虚拟机跨主机二层通信报文，通过vxlan隧道实现跨主机通信。</li>\n<li>物理出口：用来连接虚拟网络和物理网络，每台服务器至少配置2*GE网口作为物理出口，并做网口聚合绑定。交换机需要关闭stp协议，保障网络稳定性。</li>\n</ul>\n<h4 id=\"虚拟存储配置\"><a href=\"#虚拟存储配置\" class=\"headerlink\" title=\"虚拟存储配置\"></a>虚拟存储配置</h4><ul>\n<li>推荐存储网络使用2*10GE两个万兆口</li>\n<li>SSD缓存盘：SSD可为其磁盘组下的HDD提供缓存加速的能力。SSD和HDD的个数比推荐值为1：3，不能低于1：7。</li>\n<li>存储卷：使用存储多卷，要求每个存储卷的主机数量至少为3台。建议一个集群内不配置超过3个卷，单个卷内主机数不超过12台。</li>\n<li>建议使用三台以上的主机组成一个虚拟存储卷，可以获得条带化的效果和仲裁机制。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211559795.webp\" alt=\"image-20231021155928654\"></p>\n<h4 id=\"HCI管理（重点！）\"><a href=\"#HCI管理（重点！）\" class=\"headerlink\" title=\"HCI管理（重点！）\"></a>HCI管理（重点！）</h4><p>HCI初始化有如下的条件：</p>\n<ol>\n<li>根据集群内所有主机的CPU颗数购买充足的首选。</li>\n<li>单主机不支持虚拟存储；普通集群至少要求2台以上的主机，如果需要虚拟存储的条带化功能或使用虚拟存储多卷功能，则需要3台以上的主机。</li>\n<li>延伸集群至少需要4主机起步，加上一个仲裁节点。</li>\n<li>禁止单台主机部署HCI。</li>\n</ol>\n<p>HCI有USE-Key（离线）授权和vKEY（在线）授权两种方式。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211601457.webp\" alt=\"image-20231021160128322\"></p>\n<h2 id=\"HCI产品功能\"><a href=\"#HCI产品功能\" class=\"headerlink\" title=\"HCI产品功能\"></a>HCI产品功能</h2><h3 id=\"集群资源调度DRS\"><a href=\"#集群资源调度DRS\" class=\"headerlink\" title=\"集群资源调度DRS\"></a>集群资源调度DRS</h3><p>DRS全称是Distributed Resource Scheduler，指集群资源调度，顾名思义，在特定场景下会调度集群资源，这里的资源指的是虚拟机。我们的DRS会设置CPU和内存阈值，如果超过阈值，就会触发DRS。</p>\n<p>DRS有自动和手动两种，对于选了自动的虚拟机，DRS会配置自动选择合适的主机来运行。而对于那些指定了运行位置的虚拟机，DRS不会对其进行操作。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211508535.webp\" alt=\"image-20231021150843382\"></p>\n<h3 id=\"集群资源动态热添加DRX\"><a href=\"#集群资源动态热添加DRX\" class=\"headerlink\" title=\"集群资源动态热添加DRX\"></a>集群资源动态热添加DRX</h3><p>DRX全称是Dynamic Resource Extension，指动态资源拓展。虚拟机资源不足，主机资源空闲的时候，自动为虚拟机添加CPU或者内存。</p>\n<h2 id=\"HCI产品应用场景\"><a href=\"#HCI产品应用场景\" class=\"headerlink\" title=\"HCI产品应用场景\"></a>HCI产品应用场景</h2><h3 id=\"信服云迁移工具\"><a href=\"#信服云迁移工具\" class=\"headerlink\" title=\"信服云迁移工具\"></a>信服云迁移工具</h3><p>信服云迁移工具可以供业务迁移能力(P2V，V2V)，可满足以下的业务场景要求：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211528787.webp\" alt=\"image-20231021152837489\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211531494.webp\" alt=\"image-20231021153154351\"></p>\n<p>注意是不会影响被迁移，不是不会被热迁移。蓝屏，USB和接受迁移目标资源不足都会影响虚拟机被热迁移。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211602968.webp\" alt=\"image-20231021160223851\"></p>\n<h2 id=\"HCI产品运维\"><a href=\"#HCI产品运维\" class=\"headerlink\" title=\"HCI产品运维\"></a>HCI产品运维</h2><h1 id=\"深信服桌面云aDesk\"><a href=\"#深信服桌面云aDesk\" class=\"headerlink\" title=\"深信服桌面云aDesk\"></a>深信服桌面云aDesk</h1><ul>\n<li>在深信服Webconsole界面中，<strong>sock</strong>命令与<strong>telnet</strong>命令相似。</li>\n</ul>\n<p>VMP（Virtualization Management Platform）是虚拟化管理平台的缩写。VDC(Virtual Desktop Controller)是桌面控制系统的缩写。VDI是虚拟桌面基础设施（Virtual Desktop Infrastructure）的缩写。它是一种技术和架构，用于在服务器上创建和管理虚拟桌面环境，从而提供集中式的桌面虚拟化解决方案。</p>\n<p>可以与VMware对比的是VMP平台都用于管理虚拟机，VDC相当于一个C&#x2F;S架构应用程序的服务器端，VDI是客户端。</p>\n<p>所以，使用aDesk之前必须要先完成VMP的部署和VDC的部署，而这两个平台的部署都是基于HCI的，所以在此之前还需要完成HCI的部署。下面是完成HCI部署之后的平台部署流程图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201835012.webp\" alt=\"image-20231020183431435\"></p>\n<h2 id=\"VMP安装\"><a href=\"#VMP安装\" class=\"headerlink\" title=\"VMP安装\"></a>VMP安装</h2><p>VMP叫做虚拟化管理平台，理论上每一台虚拟机都应该安装VMP。而HCI将这些虚拟资源整合在一起，形成一个统一的平台，用于构建和管理虚拟化环境。<strong>HCI通常由多台物理服务器组成</strong>，每台服务器上运行着虚拟化软件，并通过网络进行通信和数据共享。</p>\n<p>安装VMP的过程和安装HCI类似，都是获取到了iso镜像之后，在系统启动之时进入BIOS安装。</p>\n<ul>\n<li>前提条件</li>\n</ul>\n<ol>\n<li>VMP系统镜像</li>\n<li>U盘&#x2F;刻录光盘</li>\n<li>普通PC（用于控制，制作iso镜像）</li>\n<li>需要安装VMP的服务器</li>\n</ol>\n<p>VMP硬件配置要求：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201409517.webp\" alt=\"image-20231020140937268\"></p>\n<ul>\n<li>VMP授权管理：</li>\n</ul>\n<p>VMP除了可以使用Key授权之外，还可以借助aCenter实现对VMP和VDC的统一授权，在多集群&#x2F;多分支情况下，随意回收和修改授权。</p>\n<ol>\n<li>aCenter已经通过了Key进行授权，并且VMP节点已经加入了aCenter。</li>\n<li>通过aCenter下发授权至分支节点后，该分支节点原有的授权无效，只继承aCenter所下发的授权。</li>\n<li>通过aCenter进行统一的授权后，分支节点的授权key可拔出回收。</li>\n<li>修改授权后，VDC会重启服务来更新授权信息。</li>\n</ol>\n<h2 id=\"VMP创建VDC\"><a href=\"#VMP创建VDC\" class=\"headerlink\" title=\"VMP创建VDC\"></a>VMP创建VDC</h2><p>再复习一下，VDC(Virtual Desktop Controller)是桌面控制系统的缩写。</p>\n<p>在上一步完成了VMP的安装之后，就可以登录VMP控制台，设置ip等信息创建全新的虚拟机，然后创建VDC，一般VDC运行在4430端口上。如果想要更好的理解，可以把VMware想象成为一个Web应用，那么VDC就是服务器，VDI就是客户端。</p>\n<ul>\n<li>VDC集群的介绍</li>\n</ul>\n<p>VDC集群的各个节点（VDC设备）由一个分发器和一组真实服务器组成，分发器和真实服务器都是VDC设备。网络客户接入VDI的时候，会由分发器合理的分配给集群中最空闲的真实服务器为客户提供服务。</p>\n<ul>\n<li><font>VDC集群的要求：</font></li>\n</ul>\n<ol>\n<li>存在两台VDC并且版本是一致的，确认VDC的ip地址处在同一个内网网段内。</li>\n<li>每台VDC设备上均需要启用集群部署，并且需要配置相同的集群ip。</li>\n<li><strong>软件VDC和硬件VDC可以组件集群</strong>。</li>\n<li>禁止将克隆出的软件VDC和克隆前的软件VDC组件集群。</li>\n</ol>\n<ul>\n<li>VDC用户认证管理</li>\n</ul>\n<p>VDC用户认证管理的主要方式有三种：本地密码认证、LDAP认证和第三方接口认证，可以看aDesk用户管理的部分。</p>\n<p>授权码的注意事项如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201906572.webp\" alt=\"image-20231020190602207\"></p>\n<ul>\n<li>创建VDC步骤：</li>\n</ul>\n<ol>\n<li>win操作机登录HCI</li>\n<li>选择存储——本地存储</li>\n<li>系统管理——端口管理——桌面云接入服务</li>\n<li>虚拟机导入界面，导入虚拟机的vma镜像文件</li>\n<li>点击转到虚拟机，开机，选择NetworkSetup Wizard，配置ip为VDC的管理ip。</li>\n<li>部署完成后，浏览器访问<a href=\"https://VDCip:4430即进入VDC。\">https://VDCip:4430即进入VDC。</a></li>\n<li>新建虚拟化管理平台控制器，输入控制器地址，测试连接。</li>\n</ol>\n<ul>\n<li>VDC管理</li>\n</ul>\n<p>在VDC管理过程中，每个用户拥有的硬件特征码个数默认为5个（五种设备？？？）。</p>\n<h2 id=\"VMP创建VDI\"><a href=\"#VMP创建VDI\" class=\"headerlink\" title=\"VMP创建VDI\"></a>VMP创建VDI</h2><ul>\n<li>创建VDI的步骤：</li>\n</ul>\n<ol>\n<li>win操作机登录HCI</li>\n<li>选择上面的虚拟机（VDC已经创建好的）</li>\n<li>选择下面的桌面应用，创建全新VDI虚拟机</li>\n<li>填写VDI虚拟机信息</li>\n<li>安装系统，配置网络</li>\n</ol>\n<ul>\n<li>最佳实践：</li>\n</ul>\n<p>VDI5.4.1开始支持多卷功能，如果是单主机或者双主机只允许创建一个卷；当系统中已存在一个卷的时候，未加入主机数小于3的时候不再允许新加卷。</p>\n<p>单卷最大支持24主机，最佳实践是8-12为一个卷，VMP单集群最大支持创建3个卷。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211627113.webp\"></p>\n<h2 id=\"aCenter平台的部署\"><a href=\"#aCenter平台的部署\" class=\"headerlink\" title=\"aCenter平台的部署\"></a>aCenter平台的部署</h2><p>aCenter是虚拟化集中管理平台，适用于VMP集群分布式部署场景。通常将aCenter部署于企业内部，通过公网、专线等方式对各分支机构的VMP集群进行集中的监控、升级、管理和统一授权。</p>\n<ul>\n<li>aCenter安装在物理主机</li>\n</ul>\n<ol>\n<li>需要先将aCenter的ISO镜像通过UltraISO制作启动镜像。</li>\n<li>物理主机最低配置为：4GB内存，65GB硬盘，千兆网卡。</li>\n</ol>\n<ul>\n<li>aCenter安装在VMP平台：</li>\n</ul>\n<p>与VMP上安装VDC虚拟机的过程大致相同，需要在虚拟机操作系统处选虚拟化集中管理平台aCenter，并将aCenter的ISO镜像挂载到虚拟机的光驱上，后续同物理机。配置要求也一样。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211557228.webp\" alt=\"image-20231021155759093\"></p>\n<h2 id=\"aDesk用户和用户组管理\"><a href=\"#aDesk用户和用户组管理\" class=\"headerlink\" title=\"aDesk用户和用户组管理\"></a>aDesk用户和用户组管理</h2><p>在aDesk上可以对VMP，VDC和VDI进行的用户进行管理。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202044429.webp\" alt=\"image-20231020204308752\"></p>\n<p>主要认证还包括第三方认证。</p>\n<blockquote>\n<p>LDAP（Lightweight Directory Access Protocol）认证是一种基于网络协议的身份验证机制，用于验证用户的身份和授权其访问特定资源。LDAP是一种应用层协议，用于访问和维护分布式目录服务（如LDAP服务器）中的信息。它使用客户端-服务器模型，其中客户端发起LDAP请求，服务器响应并提供所需的信息。</p>\n<p>Radius（Remote Authentication Dial-In User Service）认证是一种网络身份验证协议，用于验证和授权用户对网络资源的访问。Radius认证是一种客户端-服务器认证协议，广泛用于网络接入服务，特别是拨号和虚拟专用网络（VPN）服务。它提供了一种中心化的认证和授权机制，允许用户通过一组凭据（例如用户名和密码）进行身份验证，并授予他们访问网络资源的权限。</p>\n</blockquote>\n<h2 id=\"客户端接入\"><a href=\"#客户端接入\" class=\"headerlink\" title=\"客户端接入\"></a>客户端接入</h2><p>常见的终端接入：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202108380.webp\" alt=\"image-20231020210836189\"></p>\n<p>请注意，移动终端不支持登录linux虚拟机，但是可以访问windows虚拟机。 </p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211540608.webp\" alt=\"image-20231021154010471\"></p>\n<h2 id=\"分布式防火墙\"><a href=\"#分布式防火墙\" class=\"headerlink\" title=\"分布式防火墙\"></a>分布式防火墙</h2><ul>\n<li>传统终端安全的实现方式</li>\n</ul>\n<ol>\n<li>接入交换机ACL控制终端PC间互访流量，，防止出现一些主机沦陷病毒扩散问题。</li>\n<li>网络防火墙部署在区域边界节点控制区域互访流量。</li>\n<li>计算机软件防火墙保护计算机系统环境安全。</li>\n</ol>\n<ul>\n<li>分布式防火墙</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202203086.webp\" alt=\"image-20231020220323906\"></p>\n<p>分布式防火墙适用场景：</p>\n<ol>\n<li>用户对于虚拟机之间的网络有微隔离要求。</li>\n<li>出现诸如勒索病毒一类内网安全事件，需要阻断病毒横向传播场景。</li>\n<li>使用传统基于IP做策略的方式难以满足实际网络访问控制需求的场景（如池桌面）。</li>\n</ol>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202207266.webp\" alt=\"image-20231020220752097\"></p>\n<ul>\n<li>新增策略的三种方式：新建策略、复制策略和导入策略。</li>\n</ul>\n<h2 id=\"报表中心-Sangfor-VDC-Report-Center\"><a href=\"#报表中心-Sangfor-VDC-Report-Center\" class=\"headerlink\" title=\"报表中心(Sangfor VDC Report Center)\"></a>报表中心(Sangfor VDC Report Center)</h2><ul>\n<li>报表中心简介</li>\n</ul>\n<p>报表中心可以对VDC和VMP上的数据进行收集，存储和展示，主要包括数据查询、数据分析、报表导出等功能。</p>\n<p>针对VDC传输的数据可以分为：资产信息、管理日志、安全日志、安全策略、并发会话数。</p>\n<p>针对VMP传递的数据可以分为：服务器存储趋势、服务器负载。</p>\n<p>针对用户虚拟机的数据则提供文件导出审计页面。</p>\n<ul>\n<li>报表中心适用场景：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202215944.webp\" alt=\"image-20231020221554753\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211549911.webp\" alt=\"image-20231021154943744\"></p>\n<p>请注意，一个桌面云上的报表中心最多能关联1个VDC集群。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211540065.webp\" alt=\"image-20231021154051939\"></p>\n<h2 id=\"显卡虚拟化3D部署\"><a href=\"#显卡虚拟化3D部署\" class=\"headerlink\" title=\"显卡虚拟化3D部署\"></a>显卡虚拟化3D部署</h2><ul>\n<li>桌面虚拟化的两种架构：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202217225.webp\" alt=\"image-20231020221749987\"></p>\n<ul>\n<li>3D桌面显卡虚拟化(vGPU)优势</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310202220261.webp\" alt=\"image-20231020222010083\"></p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><h3 id=\"Agent安装\"><a href=\"#Agent安装\" class=\"headerlink\" title=\"Agent安装\"></a>Agent安装</h3><p>agent是桌面云的一个重要的组件，虚拟机的正常使用，离不开agent的正常运行。在虚拟机上安装Agent的方法是：虚拟机上面的管理栏下，有安装Agent的相关选项。</p>\n<p>注意！安装Agent后会重启虚拟机。安装Agent之前要安装vmtools：在虚拟机那一栏下拉。</p>\n<h3 id=\"独享桌面资源的创建\"><a href=\"#独享桌面资源的创建\" class=\"headerlink\" title=\"独享桌面资源的创建\"></a>独享桌面资源的创建</h3><ol>\n<li>登入HCI</li>\n<li>虚拟机模板管理——虚拟机转模板</li>\n<li>业务中心——资源管理——新建独享桌面</li>\n<li>按要求配置信息，保存</li>\n</ol>\n<h3 id=\"桌面云用户接入实验\"><a href=\"#桌面云用户接入实验\" class=\"headerlink\" title=\"桌面云用户接入实验\"></a>桌面云用户接入实验</h3><ol>\n<li>登录HCI</li>\n<li>业务中心——用户管理——新建</li>\n<li>输入用户相关信息</li>\n<li>安装VDI客户端并打开</li>\n<li>输入服务器地址，用户名和密码</li>\n</ol>\n<h1 id=\"深信服分布式存储EDS\"><a href=\"#深信服分布式存储EDS\" class=\"headerlink\" title=\"深信服分布式存储EDS\"></a>深信服分布式存储EDS</h1><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211630046.webp\" alt=\"image-20231021163014931\"></p>\n<h2 id=\"存储常见技术\"><a href=\"#存储常见技术\" class=\"headerlink\" title=\"存储常见技术\"></a>存储常见技术</h2><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211140380.webp\" alt=\"image-20231021114010575\"></p>\n<h3 id=\"备份与容灾\"><a href=\"#备份与容灾\" class=\"headerlink\" title=\"备份与容灾\"></a>备份与容灾</h3><p>容灾（Disaster Recovery）是一种综合性的策略和实践，旨在保护和恢复组织的关键业务和数据，以应对各种灾难性事件，如自然灾害、硬件故障、人为错误等。容灾的目标是在灾难发生时，能够尽快地恢复业务运营和数据访问，并最小化停机时间和数据丢失。</p>\n<p>备份（Backup）是一种数据保护的措施，旨在创建数据的副本并存储在另一个位置，以防止数据丢失或损坏。备份可以用于恢复单个文件、文件夹、数据库或整个系统。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192046268.webp\" alt=\"image-20231019204626041\"></p>\n<blockquote>\n<p>RTO（恢复时间目标）是指在发生灾难性事件后，系统需要恢复正常运行所需的时间。它代表了从灾难发生到系统完全恢复正常运行的时间窗口。较短的RTO意味着系统能够更快地恢复，尽快恢复业务运营，减少停机时间和业务中断。RTO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。</p>\n<p>RPO（恢复点目标）是指在发生灾难性事件后，系统需要恢复到的数据恢复点。它代表了在灾难发生前的系统数据状态。较小的RPO意味着系统能够更少地丢失数据，尽可能接近灾难发生前的最新数据。RPO的衡量通常以时间为单位，例如，以小时、分钟或秒为单位。RPO越小，丢失的数据越少。</p>\n</blockquote>\n<p>EC（Erasure Coding）机制和副本机制是在分布式存储系统中用于数据可靠性和容错性的两种不同策略。</p>\n<p>EC机制是一种纠删码技术，它将原始数据分割成多个数据块，并通过添加冗余数据块来实现数据的冗余和容错。EC可以在数据丢失或损坏的情况下进行数据恢复，而<strong>不需要完全复制原始数据</strong>。</p>\n<p>副本机制是一种简单而直接的数据冗余策略，它通过完全复制数据来实现容错性。在副本机制中，<strong>原始数据会被完全复制</strong>到多个存储节点上，以确保数据的可靠性。如果某个节点发生故障或数据损坏，可以通过其他副本来恢复数据。</p>\n<h3 id=\"RAID介绍\"><a href=\"#RAID介绍\" class=\"headerlink\" title=\"RAID介绍\"></a>RAID介绍</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/image-20231019205741595.webp\" alt=\"image-20231019205741595\"></p>\n<h3 id=\"传统存储与分布式存储\"><a href=\"#传统存储与分布式存储\" class=\"headerlink\" title=\"传统存储与分布式存储\"></a>传统存储与分布式存储</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192102639.webp\" alt=\"image-20231019210250465\"></p>\n<h3 id=\"EDS架构简介\"><a href=\"#EDS架构简介\" class=\"headerlink\" title=\"EDS架构简介\"></a>EDS架构简介</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310192056711.webp\" alt=\"image-20231019205631518\"></p>\n<h2 id=\"EDS产品应用场景\"><a href=\"#EDS产品应用场景\" class=\"headerlink\" title=\"EDS产品应用场景\"></a>EDS产品应用场景</h2><p>EDS产品的应用场景涵盖了块存储、文件存储和对象存储三个方面。</p>\n<h2 id=\"EDS产品运维\"><a href=\"#EDS产品运维\" class=\"headerlink\" title=\"EDS产品运维\"></a>EDS产品运维</h2><p>EDS存储巡检：存储巡检是一种定期检查和评估存储系统的健康状况和性能的过程。它旨在发现和解决潜在的问题，以确保存储系统的稳定性、可靠性和性能。</p>\n<p>进行存储巡检是商业维度，技术维度和其他维度的综合考量结果。可以使用深信服adeploy服务（一个可执行文件）进行存储巡检。</p>\n<h1 id=\"深信服应用交付AD平台\"><a href=\"#深信服应用交付AD平台\" class=\"headerlink\" title=\"深信服应用交付AD平台\"></a>深信服应用交付AD平台</h1><h2 id=\"网络部署\"><a href=\"#网络部署\" class=\"headerlink\" title=\"网络部署\"></a>网络部署</h2><ul>\n<li>深信服AD的集群部署模式种，<strong>1个浮动IP</strong>顶多在<strong>1台设备</strong>上生效。</li>\n<li>深信服AD的集群模式中，当组件集群的AD版本号不一致的时候，健康状态应为<strong>故障</strong>。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211631695.webp\" alt=\"image-20231021163102535\"></p>\n<h3 id=\"网络部署基础\"><a href=\"#网络部署基础\" class=\"headerlink\" title=\"网络部署基础\"></a>网络部署基础</h3><h4 id=\"网口配置\"><a href=\"#网口配置\" class=\"headerlink\" title=\"网口配置\"></a>网口配置</h4><p>在HCI的网络部署——网口配置页面，可以配置网口的协商模式，推荐使用Auto配置。</p>\n<h4 id=\"端口聚合\"><a href=\"#端口聚合\" class=\"headerlink\" title=\"端口聚合\"></a>端口聚合</h4><p>端口聚合可以将多个物理接口当作一个单一的逻辑接口来处理，它允许两台设备之间通过多个接口并行连接同时传输数据以提供更高的带宽，更大的吞吐量和可恢复性技术。主要有如下优点：</p>\n<ol>\n<li>增加带宽：带宽相当于聚合的端口的带宽总和。</li>\n<li>增加冗余：其中一个端口坏了还能工作，只是带宽变小。</li>\n<li>负载均衡：可以在组内接口上配置，是流量在接口上自动进行负载均衡。</li>\n</ol>\n<p>操作方法：新建聚合接口——选择绑定策略——选择绑定接口。</p>\n<h4 id=\"VLAN子接口\"><a href=\"#VLAN子接口\" class=\"headerlink\" title=\"VLAN子接口\"></a>VLAN子接口</h4><p>某些情况下与AD设备对接的网口为TRUNK口，要求AD设备对应的接口也可以封装VLAN划分子接口，此时需要配置VLAN子接口。</p>\n<h4 id=\"端口桥接\"><a href=\"#端口桥接\" class=\"headerlink\" title=\"端口桥接\"></a>端口桥接</h4><p>在一些较为复杂的网络结构中，需要AD设备能将两个口划分到一个广播域内，相当于将AD设备的多个口组成一个二层交换机，此时就需要网口桥接功能。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201056310.webp\" alt=\"image-20231020105602015\"></p>\n<h4 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h4><ul>\n<li>ECMP是传统边界路由器的运营商链路负载方式。</li>\n<li>策略路由是传统的边界路由器的运营商链路负载方式。</li>\n<li>路由器策略路由链路负载方式无法根据带宽动态调整，调度策略不灵活，资源利用率低。</li>\n</ul>\n<blockquote>\n<p>ECMP是一种路由算法，用于在网络中选择多个等价路径来转发数据流量。当存在多个具有相同开销（cost）的路径时，ECMP允许路由器将数据流量分散到这些路径上，以实现负载均衡和提高网络性能。ECMP通常在网络中的内部路由中使用，例如在数据中心网络中。</p>\n<p>策略路由是一种根据特定的策略或条件，动态选择路由路径的方法。与传统的静态路由不同，策略路由可以根据网络中的不同因素（如流量负载、链路状态、服务质量要求等）来选择最佳路径，以实现更灵活的路由控制。</p>\n</blockquote>\n<h3 id=\"部署模式\"><a href=\"#部署模式\" class=\"headerlink\" title=\"部署模式\"></a>部署模式</h3><p>部署模式使之设备以什么样的工作方式部署到用户的网络中去，不同的部署方式对于网络影响各不相同。AD支持两种部署模式：网关模式和旁路模式。注意，配置AD设备的时候不需要在界面上选择部署模式，以什么样的方式接入客户网络就是什么部署模式。</p>\n<h4 id=\"网关部署模式\"><a href=\"#网关部署模式\" class=\"headerlink\" title=\"网关部署模式\"></a>网关部署模式</h4><p>一般是将AD部署在互联网出口或者是内网服务器前端，逻辑网络层面，设备有两个或多个接口连接到网络内，数据经过路由转发会穿过设备。设备配置里，既有WAN接口，也有LAN属性接口。</p>\n<ul>\n<li>优点：AD的功能都能满足（出战负载、全局负载、应用负载等等）</li>\n<li>缺点：此种部署对网络的改动比较大，建议在新建网络或者网络改造的时候部署。</li>\n</ul>\n<h4 id=\"旁路模式部署\"><a href=\"#旁路模式部署\" class=\"headerlink\" title=\"旁路模式部署\"></a>旁路模式部署</h4><p>一般是AD旁路在接入或者核心交换机上</p>\n<ul>\n<li>优点：无需改变原网络拓扑结构，只需要单臂挂在核心交换机，进行配置即可，对现有网络无影响</li>\n<li>缺点：无法实现链路负载</li>\n</ul>\n<h4 id=\"三角传输模式\"><a href=\"#三角传输模式\" class=\"headerlink\" title=\"三角传输模式\"></a>三角传输模式</h4><p>一般是AD旁路部署在业务服务器同一台二层交换机下或同一个二层网络中，通过AD虚拟服务关闭DNAT和SNAT功能，服务器配置loopback口与虚拟服务相同IP实现。</p>\n<ul>\n<li><p>优点：服务端可以看到客户端源IP；减轻AD流量负担，回来的包不经过AD设备，而是直接转发回客户端</p>\n</li>\n<li><p>缺点：AD无法感知服务器的loopback口健康状态；AD必须与服务器同网段部署。</p>\n</li>\n</ul>\n<h2 id=\"高可用主备模式\"><a href=\"#高可用主备模式\" class=\"headerlink\" title=\"高可用主备模式\"></a>高可用主备模式</h2><h3 id=\"主备模式简介\"><a href=\"#主备模式简介\" class=\"headerlink\" title=\"主备模式简介\"></a>主备模式简介</h3><p>主备模式：两台AD双击部署，一台处于工作状态，另一台处于冷备状态。两台设备通过心跳口检测对端是否存在，并同步设备和会话。当主设备触发问题切换条件时，设备会自动地把业务切换到备用设备。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201119366.webp\" alt=\"image-20231020111917141\"></p>\n<p>AD设备的各种部署模式都支持双机热备，以下是典型的拓扑图。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310201120265.webp\" alt=\"image-20231020112024952\"></p>\n<h3 id=\"主备模式要求\"><a href=\"#主备模式要求\" class=\"headerlink\" title=\"主备模式要求\"></a>主备模式要求</h3><p>主备模式部署要求：</p>\n<ol>\n<li>网口个数一样</li>\n<li>内存大小一样</li>\n<li>序列号一致</li>\n<li>软件版本一致</li>\n</ol>\n<h3 id=\"主备模式的基本元素\"><a href=\"#主备模式的基本元素\" class=\"headerlink\" title=\"主备模式的基本元素\"></a>主备模式的基本元素</h3><h4 id=\"心跳口\"><a href=\"#心跳口\" class=\"headerlink\" title=\"心跳口\"></a>心跳口</h4><p>又叫HA口，主要功能是检测对端是否还存活，通常两台设备的心跳口通过网线直连，并且通过周期性地发送心跳口包来检测对端是否存活，并且有冗余保障机制。</p>\n<h4 id=\"故障切换\"><a href=\"#故障切换\" class=\"headerlink\" title=\"故障切换\"></a>故障切换</h4><p>用来检测主设备发生故障时，进行主备设备切换保证业务的连续稳定运行，切换条件可以由用户自己定义。</p>\n<h4 id=\"同步对象\"><a href=\"#同步对象\" class=\"headerlink\" title=\"同步对象\"></a>同步对象</h4><h2 id=\"ACL访问控制策略配置\"><a href=\"#ACL访问控制策略配置\" class=\"headerlink\" title=\"ACL访问控制策略配置\"></a>ACL访问控制策略配置</h2><p>ACL(Access Control List)访问控制列表，ACL基于数据连接的五元组来实现外到内或内到外的数据访问控制，可以提升网络的安全性。主要应用场景是禁止内网指定用户访问AD设备或禁止访问互联网，禁止外部主机访问设备或者AD设备发布的内网业务。</p>\n<p>相关的配置在HCI的网络部署——网络安全——ACL配置路径。</p>\n<h2 id=\"健康检测\"><a href=\"#健康检测\" class=\"headerlink\" title=\"健康检测\"></a>健康检测</h2><p>深信服AD设备对某节点业务健康检查失败之后的处理动作：标记该节点异常；AD会将健康检查失败的节点从资源池中剔除；健康检查失败的节点将不能继续提供业务访问。但是<strong>会在资源池中继续进行健康检查</strong>。</p>\n<p>在AD巡检的过程中，进行外观检查的时候，<strong>备机的alarm灯闪属于正常现象</strong>。主设备的alarm灯亮属于告警现象。</p>\n<h2 id=\"AD产品应用场景\"><a href=\"#AD产品应用场景\" class=\"headerlink\" title=\"AD产品应用场景\"></a>AD产品应用场景</h2><h3 id=\"智能路由\"><a href=\"#智能路由\" class=\"headerlink\" title=\"智能路由\"></a>智能路由</h3><ul>\n<li>适用场景</li>\n</ul>\n<p>外网多条线路时，部署的传统路由器总是出现：链路调度不均衡，跨运营商访问慢</p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://veni222987.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"深信服","slug":"深信服","permalink":"https://veni222987.github.io/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"}]},{"title":"Linux简明使用教程","date":"2023-10-17T05:40:19.000Z","path":"2023/10/17/Linux简明使用教程/","text":"下面是Linux操作系统的简单，覆盖了Linux基本使用的常用指令。 Linux简明使用教程基本命令命令行和快捷键 补全命令：使用Tab键可以补全命令 Ctrl+A：光标移动到最前，Ctrl+E：光标移动到最后，Ctrl+L：清除当前窗口 ls -a -l -t和ls -alt是一样的 Linux文件 查看文件 创建文件：使用mknod或者touch创建文件，使用mkdir创建目录 删除文件：使用rm &lt;文件名&gt;指令，使用rm -r &lt;文件名&gt;可以删除目录 移动与复制：使用mv &lt;源文件&gt; &lt;目标目录&gt;移动文件，使用cp &lt;源文件&gt; &lt;目标目录&gt;实现复制文件并移动。 创建链接文件：ln -s &lt;A&gt; &lt;B&gt; 常见的文件类型标识： chmod是一个用于修改文件或目录权限的命令。它可以更改文件的读取、写入和执行权限，以及文件所有者和所属组的权限。 例如，将sh设置为可执行的指令为： 1chmod -x script.sh Vim编辑器的使用Vim有输入模式，命令模式和底行模式三种，其中命令模式和底行模式的区别在于:。 Vim的基础用法不加赘述，下面是Vim的底行模式的一些命令： 磁盘管理查看磁盘空间：df指令 使用df -i查看磁盘INodes使用情况，df -h使用合适的单位显示文件系统信息。 磁盘分区使用fdisk指令可以对磁盘进行分区管理，但是只能划分小于2T的分区。由于磁盘分区使用频率较低，故不详细展开，使用时查阅fdisk指令即可。 磁盘挂载在完成磁盘的分区和格式化之后，还需要挂载到系统路径，才可以使用。 使用mount命令可以手动挂载，示例如下： 然而使用mount指令手动挂载的分区，在系统重启之后会取消挂载，要实现开机自动挂载的方法是使用配置文件&#x2F;etc&#x2F;fstab。 用户管理Linux有三类不同的用户：root用户，一般用户和服务用户。用户的管理文件在&#x2F;etc&#x2F;passwd文件中。一般而言，一个用户的home目录在/home/&lt;用户名&gt;。 新增用户：使用useradd指令。 删除用户：userdel指令，-r可以一并删除用户的home目录。 Linux用户创建完成以后，默认是没有密码的，设置密码的指令是passwd username Linux压缩与解压缩Linux常见的压缩包格式打包在linux下一般是tar，而压缩则可以是zip，gz等等。一般而言，在网上下载某些SDK的时候，最常见的压缩包格式就是tar.gz包。 打包和压缩的区别： 打包是将多个文件和目录合并成为一个； 压缩是将单个文件使用压缩算法减小空间； 常见的压缩工具zip压缩工具zip可以压缩文件和目录，并且zip不会删除压缩的文件。 压缩方法：zip &lt;生成文件&gt; &lt;原始文件&gt;，使用-r可以递归压缩，也就是压缩目录。 解压方法：unzip &lt;压缩文件&gt; -d &lt;解压路径&gt;，如果不使用-d参数，则会解压到当前路径。 gzip压缩工具gzip是用来压缩和解压缩.gz格式的文件的。 压缩方法：gzip &lt;文件名&gt;，使用-#可以指定压缩等级1~9，默认为6。 解压方法：gzip -d &lt;文件名&gt; 注意：gzip压缩和解压缩都会删除源文件。 bzip2压缩工具bzip2是用来压缩和解压缩.bz2格式的文件的。 压缩方法：bzip2 -z &lt;文件名&gt; ，不用-z指令也可以压缩 解压方法：bzip2 -d &lt;文件名&gt; 注意：gzip和bzip2都不能压缩目录，因此需要使用tar将其进行打包。而使用tar打包成为一个文件后，则zip也就失去了打包目录的优势。所以tar一般配合gzip和bzip2使用。 打包和解包工具——tar熟记下面的参数，即可流畅使用tar。 记忆方法： -z -j -J三选一，标识压缩方式，分别是gz, bz2和xz；-x表示解包，-c表示打包，不能同时出现。-v -f一般都有，方便指定文件和观察打包&#x2F;解包过程。如果是打包，则指令格式为：tar -cvf &lt;目标文件名&gt; &lt;源文件名&gt;，而解包后面可以直接接文件名，默认是解包到当前文件夹，如果需要打包到指定文件夹，则指令后面需要加上-C &lt;目标路径&gt;。 Linux软件安装安装包管理在早期的Linux系统中，如果想要添加软件，必须获取源码，然后编译成二进制代码再运行，这种软件包通常是一个压缩包，比如tar.gz模式。直到现在，某些个人开发者开发的软件也还在使用这种打包方式。 后来，为了解决从压缩包安装软件的麻烦，软件包发展出了RPM包和Deb包两种形式。 RPM包：最初是Red Hat Package Manager，后被重命名为RPM，是SUSE，Red Hat和Centos等发行版的首选软件包格式。 Deb包：基于Debian GNU&#x2F;linux的管理包文件，常用于Debian发行版本比如Ubuntu，Linux mint等等。 包管理工具apt(Advanced Package Tool)： apt是Debian和Ubuntu等基于Debian的Linux发行版中的包管理工具。 apt通过命令行工具apt-get和apt-cache提供了用户友好的接口，用于搜索、安装、升级和删除软件包。 apt使用.deb软件包格式。 apt还提供了aptitude和Synaptic等图形化前端工具，简化了软件包管理过程，具备自动下载和安装依赖的能力。 yum(Yellowdog Updater Modified) yum是Red Hat、CentOS和Fedora等基于Red Hat的Linux发行版中的软件包管理工具。 yum通过命令行工具yum提供了用户友好的接口。 yum使用.rpm软件包格式。 yum还具有自动解决依赖关系的能力，可以自动下载和安装软件包的依赖项。 源码安装软件有一些开源软件，需要自行使用gcc等编译，这种场景无法统一，可以查阅官方文档结合日志搜索解决。 Linux网络配置将单一的桌面PC连接到网络是一件容易的事情，但是将Linux服务器连接到网络，比如静态IP，VPN和代理服务器等等。学习网络配置管理，不仅要学会使用网络，更重要的是掌握网络状态，排查系统问题。 传统的Linux网络配置通过network.service来实现，常见的命令有ifconfig, ifup, ifdown，用于查看，启动和关闭某个网络接口，比如eth0等等。 后来，Linux系统诞生了NetworkManager这样的管理工具，但是两种工具使用一种即可，否则会有冲突。 NetwotkManager管理网络通过nmtui管理网络想通过nmtui管理网络的前提是网卡可以直接被NetworkManager管理，在Debian发行版下，下载安装NetworkManager的指令如下： 1sudo apt-get install network-manager 安装完成后，可以使用nmcli device查看网络设备: 直接输入nmtui即可使用GUI管理网络，也可以通过修改配置文件直接管理网络。 nmtui是NetworkManager Text User Interface的缩写，是一个基于文本的图形界面工具，用于配置和管理网络连接。而nmcli则是通过命令行的形式管理计算机网络。 在修改网络之后，需要重启网络服务以生效： 1systemctl restart network 其他网络指令 netstat：使用netstat可以查看整个Linux系统的网络情况 最常用的指令netstat -antp，运行结果如下： ss命令：SocketStatistics的缩写，用来获取socket的统计信息 当服务器的socket连接数量变得非常大的时候，无论是使用netstat命令还是直接cat &#x2F;proc&#x2F;net&#x2F;tcp，执行速度都会很慢，ss用到了TCP协议栈中的tcp_diag，可以获得linux内核的第一手信息，效率极高。 最常用指令：ss -lntp，以数字形式显示tcp连接，并显示进程名： 进程管理Linux的进程在&#x2F;proc目录下，相关信息存在于以ID命名的目录中。 Linux一切皆文件！ 查看进程：ps指令 ps ux|less：查看系统当前用户的所有进程，| less是管道处理，分页显示结果 ps -A查看所有进程 关闭和修改进程：kill指令 使用kill指令可以对某个进程发出信号，常见的信号如下： 例如，在确保安全的情况下，可以使用kill -9 1234强制关闭1234进程。 使用killall指令可以直接根据进程名杀死进程，例如killall bash。 修改CPU使用优先级：nice指令 Linux使用nice值定义进程访问CPU的优先级，位于[-20,19]区间，默认取值为0。 nice值越低，访问CPU优先级越高，默认0。 普通用户只能将自己的进程nice设为0~19。 普通用户只能设置nice值变高。 普通用户只能在自己的进程上设置nice。 1nice -5 vim &amp; 将vim进程放在后台运行，并且设置nice值为0+5 1renice -n -5 1234 对进程ID为1234的nice减少5。 守护进程：所有进程之母 一般守护进程是init或systemd，位于进程表的第一行，Linux内核中有一个PID为0的进程，表示内核，守护进程的PID则设置为1。 守护进程（daemon）是在操作系统后台运行的一种特殊类型的进程。它们通常在系统引导时启动，并且在整个系统运行期间持续运行。守护进程通常不与用户交互，而是在后台执行特定的任务或提供某种服务。它们被设计为在系统启动时自动运行，并且通常会一直运行，直到系统关闭或手动停止。 服务管理： Linux下服务管理有两个指令，分别是service和systemctl指令，systemctl是Linux的最新初始化系统，兼容了service的指令。 service和systemctl指令的本质都是执行&#x2F;etc&#x2F;init.d目录下的脚本 systemctl常用方法如下： Linux运维管理性能与服务 系统状态监控：vmstat，直接使用则输出当前的系统状态，第一个数字是持续输出的间隔秒数，第二个数字是持续时长秒数。例如vmstat 1 5表示间隔1s持续执行5次。 内存资源监控：free 使用free指令可以查看系统的内存使用状态，如下图 计划任务使用crontab可以编辑计划任务，选项如下： -u 指定用户名，不指定为当前用户 -e 编辑计划任务 -l 列出计划任务 -r 删除所有计划任务 创建单个计划任务的方法如下： 如需要周期性地执行某些计划任务，则可以写成如下形式： 系统服务管理系统服务是在操作系统中以守护进程形式运行的软件组件，用于提供特定的功能或服务。这些服务在系统启动时自动启动，并在后台持续运行，以响应系统和用户的需求。 Linux的系统服务一般位于/usr/lib/systemd/system路径下，具有每个系统服务的内容： 后缀名解释： service:系统服务，如crond，sshd都是服务，包括自己安装的mysql-server等。 target:多个unit组成（unit是一个逻辑概念，该目录下的都可以叫做unit，比如service等，target就是组合的unit） device:硬件设备 mount:文件系统挂载点 automount:自动挂载点 创建系统服务： 在服务路径下创建.service文件，该文件由三部分组成： [Unit]描述、文档等等 [Service]类型，环境变量，具体指令 [Install]服务安装到的target 例如，某个service文件如下： 使用不同的target可以设置不同的运行级别，使用systemctl get-default可以查看当前的运行级别。 自启动服务 使用systemctl enable &lt;服务&gt;可以设置服务自启动，反之，使用systemctl disable &lt;服务&gt;可以禁止服务自启动。 防火墙Linux下管理防火墙的软件比较多，在CentOS的5，6版本和Debian中主要使用iptables，在CentOS 7默认的防火墙管理工具是firewalld。主要学习iptables的配置方法，学有余力可以学习其改进版Shorewall。 iptables是Linux系统中最常用的防火墙管理工具之一。它是一个基于内核的防火墙管理工具，通过操作netfilter框架实现网络包过滤和网络地址转换。Shorewall是一个基于iptables的高级防火墙管理工具，适用于各种Linux发行版。它提供了一个配置文件来定义防火墙规则，可以简化复杂的防火墙配置。Shorewall支持多种方式的配置，包括命令行和文本配置文件。 iptablesiptables由四个表，分别是： filter:默认表，用常用于过滤数据包 nat:用于地址转换，侧重于连接管理 mangle:侧重于每一个数据包管理，比如修改TTL raw:异常处理 iptables五个链： input:处理进入系统的网络包 output:处理从系统发送出去的网络包 forward:处理通过系统转发的网络包 prerouting:在路由决策之前处理进入系统的网络包 postrouting:在路由决策之后处理即将离开系统的网络包 iptables四表五链的对应关系： 四表五链关系理解： filter表是最常用的表格，用于过滤网络包。它包含了三个默认的链（chains）：INPUT、OUTPUT和FORWARD。这些链用于处理进入系统、离开系统和通过系统转发的网络包。通过在这些链上配置规则，可以控制网络包的接受、拒绝、转发等。 nat表用于网络地址转换（Network Address Translation，NAT）。它包含了三个默认的链：PREROUTING、OUTPUT和POSTROUTING。这些链用于在网络包进入和离开系统之前或之后修改包的源地址、目标地址、端口等。 mangle表用于修改网络包的特定字段。它包含了五个默认的链：PREROUTING、INPUT、FORWARD、OUTPUT和POSTROUTING。这些链用于在不同的阶段对网络包进行修改，例如修改TTL字段、标记包、更改包的QoS等。 raw表用于进行特定的包处理，如连接追踪（connection tracking）和数据包跳过（packet bypass）。它包含了两个默认的链：PREROUTING和OUTPUT。这些链允许在数据包进入和离开系统之前进行特定的处理和跳过。 数据包的处理顺序如下： 流量包通过防火墙，实际就是在这个处理顺序中检验是否满足规则，定义iptables规则的方法如下： iptables查看规则：iptables -nvL --line-number 该指令可以查看不同的链上的所有规则信息。 iptables规则编写： 新建一条规则，禁止目标端口为TCP22的访问，放在INPUT链的最后： 1iptables -A INPUT -p tcp --dport 22 -j DROP 指定某个规则序号删除指定规则，可以先使用上面的查看规则的指令获取序号，然后删除规则： 1iptables -D INPUT 1 其他示例： FTP服务器配置FTP(文本传输协议)，是一个用于在计算机网络上进行文件传输的应用层协议，一般运行在TCP20和TCP21两个端口，20端口用于在客户端和服务器之间传输数据流，21端口用于传输控制流，并且通向FTP服务器入口。 FTP有两种工作模式，主动模式下，客户端开启端口，服务器主动连接客户端的端口；被动模式下，服务器开启端口，被动等待客户端连接。 FTP配置：vsftpd在Linux中，一般使用vsftpd进行FTP服务配置，vsftpd是很多发行版本的默认软件，但是如果系统没有安装，则需要自行安装。在Debian系统上，配置vsftpd的文件位于&#x2F;etc&#x2F;vsftpd.conf。打开配置文件，可以发现：主动模式默认使用20端口进行连接。 vsftpd账号配置vsftpd使用三种账号访问，匿名帐号，linux本地帐号和虚拟账号，推荐使用虚拟账号访问。使用虚拟账号访问的时候，建议关闭匿名帐号的相关权限，修改方法同样是编辑vsftpd.conf文件： 开启了虚拟账号登录之后，我们需要对虚拟账号进行管理，首先需要配置vsftpd.conf： 接下来就是准备上面配置中的东西，首先是创建一个虚拟账号对应的系统用户名，使用-s禁止该用户登录： 1useradd virtual_ftpuser -s /sbin/nologin 接下来在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd_login文件下加入用户信息，创建test1和test2两个账号，并且指定其密码。 然后生成账号的数据库文件，在Debian发行系统中需要自行安装db_load或使用其他命令（如db_load5.3）替代。 1db_load -T -t hash -f /etc/vsftpd/vsftpd_login /etc/vsftpd/vsftpd_login.db 接下来配置两个用户的权限：在下面的目录创建两个文件： &#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test1 &#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test2 然后输入以下内容： 接下来创建文件和目录，分别所谓两个虚拟用户的访问根目录，并且在里面生成两个文件，当这两个用户登陆的时候，最开始看到的应该就是自己对应的文件。 完成了创建账户之后，我们就可以调用这些账号进行认证了，认证方法如下： 接下来重启系统服务即可： 1systemctl restart vsftpd 后面就可以使用ftp访问当前服务器了，并且可以实现虚拟用户登录。 Shell脚本Shell脚本简介shell脚本在Linux的shell中工作，并不是一门编程语言，而是命令的集合，类似windows的bat文件。 shell和bash之间的关系： Shell是一种命令行解释器（command-line interpreter），它是操作系统与用户之间的接口，用于解释和执行用户输入的命令。而Bash（Bourne Again Shell）是一种Unix shell，它是Shell的一种实现，也是目前最常用的Shell之一。 在编写好shell脚本之后，需要赋予执行权限，才可以直接运行： 123chmod -x test.sh./test.sh 下面编写一个shell脚本示例： 1234567#!/bin/bashd=`date +%H:%M:%S`echo &quot;script start at $d&quot;echo &#x27;wait 2 secs&#x27;sleep 2d1=`date +%H:%M:%S`echo &quot;the script end at $d1&quot; `date +%H:%M:%S`是一个整体的命令，需要用反引号括起来，表示获取当前时间的HHMMSS格式，echo是将内容送到控制台，当echo显示的内容有变量的时候，需要使用双引号，否则单引号即可。$表示获取变量。 执行结果如下： Shell脚本语法数学运算数学运算需要用中括号括起来，要赋值的话还要加$号，例如： 1234a=1b=2sum=$[$a+$b]echo &quot;$a+$b=$sum&quot; 用户输入获取用户交互输入： 1234read -p &quot;please input a number x :&quot; xread -p &quot;please input a number y :&quot; ysum=$[$x+$y]echo &quot;x+y=$sum&quot; 其中-p是设置一条提示消息，用于提示用户需要输入的内容，其后直接跟变量名，无需声明。 脚本参数和脚本选项编写一个脚本，获取其脚本参数的值并相加 1sum=$[$1+$2] 其中$1和$2代表第1个和第2个参数，而$0则表示该脚本名字本身。 脚本则是带-的参数，比如ls -l，在实际执行脚本的时候，可以省略脚本选项。一般来说需要使用额外的脚本选项解析工具如getopt来解析，例如： 12345678910111213141516while getopts &quot;:a:b:c&quot; opt; do case $opt in a) echo &quot;Option -a selected with value $OPTARG&quot; ;; b) echo &quot;Option -b selected with value $OPTARG&quot; ;; c) echo &quot;Option -c selected&quot; ;; \\?) echo &quot;Invalid option: -$OPTARG&quot; ;; esacdone 在上面的示例中，getopts命令用于循环遍历脚本的选项。每个选项都通过case语句进行处理，其中$opt表示当前选项，$OPTARG表示选项的参数值。 条件判断 if语句逻辑判断： 12345678read -p &quot;input your score : &quot; aif [ $a -gt 80 ];then echo &quot;good job&quot;elif [ $a -gt 60 ];then echo &quot;you pass the exam&quot;else echo &quot;you failed&quot;fi 逻辑表达式使用[]括起来，并且中括号内部两侧都需要有一个空格。-gt是greater than的缩写，其他的证书比较缩写如下图： case条件判断 case的语法如下： 12345678910case $Num in 1) echo &#x27;Select 1&#x27; ;; 2) echo &#x27;Select 2&#x27; ;; 4|5) echo &#x27;Select 4 or 5&#x27; ;; *) echo &#x27;Select othor&#x27; ;;esac shell脚本有严格的语法限制，注意分号的位置为下一行的开始，使用*表示其他的任意匹配。 循环 for循环 for循环是一个十分常用的循环结构，常见的用法如下： 1234for &lt;var&gt; in &lt;cases&gt; ;do commanddone while循环 while循环在实际使用中可能会写成一个死循环，用于监控脚本,while语句的格式如下： 123while &lt;条件&gt;; do commanddone until循环，语法和while循环一样，但是满足条件的时候终止循环。 break用于中断，continue用于循环。 下面有一些简单的练习，可供读者熟悉shell脚本编程: grep，sed和awkgrep、sed和awk是在Unix&#x2F;Linux环境中常用的文本处理工具，它们具有不同的特点和用途。 grepgrep命令用于查找文件里面符合条件的字符串，或用于查找内容里包含指定范式的文件。 查找文件内容 语法为 1grep &lt;选项&gt; &lt;目标文字&gt; &lt;目标文件&gt; 例如： 1grep tcpdump /etc/passwd 查找passwd中tcpdump用户的相关信息。 查找指令内容，例如ls -l | grep m* 此外，所有的查找内容都可以使用正则表达式匹配。正则表达式的联系可以到网站练习。 sedsed是一个流式文本编辑器，可用于对文本进行替换、删除、插入、查找等操作。它使用简单的命令来操作文本，并且可以通过正则表达式进行模式匹配和替换。sed通常用于在脚本中批量处理文本数据，或者通过管道操作处理文本流。 例如，一个使用sed将文本中的foo替换成为bar的示例： 1echo &quot;foo foo foo&quot; | sed &#x27;s/foo/bar/&#x27; 输出结果为：s/foo/bar/。 awkawk是一种用于处理和分析文本数据的强大工具。它是一种完整的编程语言，具有变量、循环、条件语句等常见编程特性。awk通过对输入文本逐行处理，并根据指定的模式和动作来提取和操作数据。 使用awk命令从文本数据中提取第一列的示例： 1echo &quot;1,John,Doe&quot; | awk -F&#x27;,&#x27; &#x27;&#123; print $1 &#125;&#x27; 输出结果为1。 Vscode免密登录 使用ssh-keygen创建密钥对 将公钥追加到authorized_keys，然后修改权限，重启sshd 将密钥下载到本地主机 配置.ssh&#x2F;_config","content":"<p>下面是Linux操作系统的简单，覆盖了Linux基本使用的常用指令。<span id=\"more\"></span></p>\n<h1 id=\"Linux简明使用教程\"><a href=\"#Linux简明使用教程\" class=\"headerlink\" title=\"Linux简明使用教程\"></a>Linux简明使用教程</h1><h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><h3 id=\"命令行和快捷键\"><a href=\"#命令行和快捷键\" class=\"headerlink\" title=\"命令行和快捷键\"></a>命令行和快捷键</h3><ul>\n<li>补全命令：使用Tab键可以补全命令</li>\n<li><code>Ctrl+A</code>：光标移动到最前，<code>Ctrl+E</code>：光标移动到最后，<code>Ctrl+L</code>：清除当前窗口</li>\n<li><code>ls -a -l -t</code>和<code>ls -alt</code>是一样的</li>\n</ul>\n<h3 id=\"Linux文件\"><a href=\"#Linux文件\" class=\"headerlink\" title=\"Linux文件\"></a>Linux文件</h3><ul>\n<li>查看文件</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171516725.webp\" alt=\"image-20231017151632556\"></p>\n<ul>\n<li><p>创建文件：使用mknod或者touch创建文件，使用mkdir创建目录</p>\n</li>\n<li><p>删除文件：使用<code>rm &lt;文件名&gt;</code>指令，使用<code>rm -r &lt;文件名&gt;</code>可以删除目录</p>\n</li>\n<li><p>移动与复制：使用<code>mv &lt;源文件&gt; &lt;目标目录&gt;</code>移动文件，使用<code>cp &lt;源文件&gt; &lt;目标目录&gt;</code>实现复制文件并移动。</p>\n</li>\n<li><p>创建链接文件：<code>ln -s &lt;A&gt; &lt;B&gt;</code></p>\n</li>\n<li><p>常见的文件类型标识：</p>\n</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171526100.webp\" alt=\"image-20231017152604976\"></p>\n<ul>\n<li><code>chmod</code>是一个用于修改文件或目录权限的命令。它可以更改文件的读取、写入和执行权限，以及文件所有者和所属组的权限。</li>\n</ul>\n<p>例如，将sh设置为可执行的指令为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod -x script.sh</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vim编辑器的使用\"><a href=\"#Vim编辑器的使用\" class=\"headerlink\" title=\"Vim编辑器的使用\"></a>Vim编辑器的使用</h2><p>Vim有输入模式，命令模式和底行模式三种，其中命令模式和底行模式的区别在于<code>:</code>。</p>\n<p>Vim的基础用法不加赘述，下面是Vim的底行模式的一些命令：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171529532.webp\" alt=\"image-20231017152932416\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171529690.webp\" alt=\"image-20231017152951580\"></p>\n<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><h3 id=\"查看磁盘空间：df指令\"><a href=\"#查看磁盘空间：df指令\" class=\"headerlink\" title=\"查看磁盘空间：df指令\"></a>查看磁盘空间：<code>df</code>指令</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171533093.webp\" alt=\"image-20231017153314957\"></p>\n<p>使用<code>df -i</code>查看磁盘INodes使用情况，<code>df -h</code>使用合适的单位显示文件系统信息。</p>\n<h3 id=\"磁盘分区\"><a href=\"#磁盘分区\" class=\"headerlink\" title=\"磁盘分区\"></a>磁盘分区</h3><p>使用<code>fdisk</code>指令可以对磁盘进行分区管理，但是只能划分小于2T的分区。由于磁盘分区使用频率较低，故不详细展开，使用时查阅fdisk指令即可。</p>\n<h3 id=\"磁盘挂载\"><a href=\"#磁盘挂载\" class=\"headerlink\" title=\"磁盘挂载\"></a>磁盘挂载</h3><p>在完成磁盘的分区和格式化之后，还需要挂载到系统路径，才可以使用。</p>\n<p>使用mount命令可以手动挂载，示例如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171547780.webp\" alt=\"image-20231017154713601\"></p>\n<p>然而使用mount指令手动挂载的分区，在系统重启之后会取消挂载，要实现开机自动挂载的方法是使用配置文件&#x2F;etc&#x2F;fstab。</p>\n<h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><p>Linux有三类不同的用户：root用户，一般用户和服务用户。用户的管理文件在&#x2F;etc&#x2F;passwd文件中。一般而言，一个用户的home目录在<code>/home/&lt;用户名&gt;</code>。</p>\n<ul>\n<li>新增用户：使用<code>useradd</code>指令。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171555253.webp\" alt=\"image-20231017155501128\"></p>\n<ul>\n<li>删除用户：userdel指令，-r可以一并删除用户的home目录。</li>\n<li>Linux用户创建完成以后，默认是没有密码的，设置密码的指令是<code>passwd username</code></li>\n</ul>\n<h2 id=\"Linux压缩与解压缩\"><a href=\"#Linux压缩与解压缩\" class=\"headerlink\" title=\"Linux压缩与解压缩\"></a>Linux压缩与解压缩</h2><h3 id=\"Linux常见的压缩包格式\"><a href=\"#Linux常见的压缩包格式\" class=\"headerlink\" title=\"Linux常见的压缩包格式\"></a>Linux常见的压缩包格式</h3><p>打包在linux下一般是tar，而压缩则可以是zip，gz等等。一般而言，在网上下载某些SDK的时候，最常见的压缩包格式就是tar.gz包。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171601997.webp\" alt=\"image-20231017160148882\"></p>\n<blockquote>\n<p>打包和压缩的区别：</p>\n<p>打包是将多个文件和目录合并成为一个；</p>\n<p>压缩是将单个文件使用压缩算法减小空间；</p>\n</blockquote>\n<h3 id=\"常见的压缩工具\"><a href=\"#常见的压缩工具\" class=\"headerlink\" title=\"常见的压缩工具\"></a>常见的压缩工具</h3><h4 id=\"zip压缩工具\"><a href=\"#zip压缩工具\" class=\"headerlink\" title=\"zip压缩工具\"></a>zip压缩工具</h4><p>zip可以压缩文件和目录，并且zip不会删除压缩的文件。</p>\n<ul>\n<li>压缩方法：<code>zip &lt;生成文件&gt; &lt;原始文件&gt;</code>，使用-r可以递归压缩，也就是压缩目录。</li>\n<li>解压方法：<code>unzip &lt;压缩文件&gt; -d &lt;解压路径&gt;</code>，如果不使用-d参数，则会解压到当前路径。</li>\n</ul>\n<h4 id=\"gzip压缩工具\"><a href=\"#gzip压缩工具\" class=\"headerlink\" title=\"gzip压缩工具\"></a>gzip压缩工具</h4><p>gzip是用来压缩和解压缩.gz格式的文件的。</p>\n<ul>\n<li>压缩方法：<code>gzip &lt;文件名&gt;</code>，使用-#可以指定压缩等级1~9，默认为6。</li>\n<li>解压方法：<code>gzip -d &lt;文件名&gt;</code></li>\n</ul>\n<p>注意：gzip压缩和解压缩都会删除源文件。</p>\n<h4 id=\"bzip2压缩工具\"><a href=\"#bzip2压缩工具\" class=\"headerlink\" title=\"bzip2压缩工具\"></a>bzip2压缩工具</h4><p>bzip2是用来压缩和解压缩.bz2格式的文件的。</p>\n<ul>\n<li>压缩方法：<code>bzip2 -z &lt;文件名&gt;</code> ，不用-z指令也可以压缩</li>\n<li>解压方法：<code>bzip2 -d &lt;文件名&gt;</code></li>\n</ul>\n<blockquote>\n<p>注意：gzip和bzip2都不能压缩目录，因此需要使用tar将其进行打包。而使用tar打包成为一个文件后，则zip也就失去了打包目录的优势。所以tar一般配合gzip和bzip2使用。</p>\n</blockquote>\n<h3 id=\"打包和解包工具——tar\"><a href=\"#打包和解包工具——tar\" class=\"headerlink\" title=\"打包和解包工具——tar\"></a>打包和解包工具——tar</h3><p>熟记下面的参数，即可流畅使用tar。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171627644.webp\" alt=\"image-20231017162706505\"></p>\n<p>记忆方法：</p>\n<p><code>-z -j -J</code>三选一，标识压缩方式，分别是gz, bz2和xz；<code>-x</code>表示解包，<code>-c</code>表示打包，不能同时出现。<code>-v -f</code>一般都有，方便指定文件和观察打包&#x2F;解包过程。如果是打包，则指令格式为：<code>tar -cvf &lt;目标文件名&gt; &lt;源文件名&gt;</code>，而解包后面可以直接接文件名，默认是解包到当前文件夹，如果需要打包到指定文件夹，则指令后面需要加上<code>-C &lt;目标路径&gt;</code>。</p>\n<h2 id=\"Linux软件安装\"><a href=\"#Linux软件安装\" class=\"headerlink\" title=\"Linux软件安装\"></a>Linux软件安装</h2><h3 id=\"安装包管理\"><a href=\"#安装包管理\" class=\"headerlink\" title=\"安装包管理\"></a>安装包管理</h3><p>在早期的Linux系统中，如果想要添加软件，必须获取源码，然后编译成二进制代码再运行，这种软件包通常是一个压缩包，比如tar.gz模式。直到现在，某些个人开发者开发的软件也还在使用这种打包方式。</p>\n<p>后来，为了解决从压缩包安装软件的麻烦，软件包发展出了RPM包和Deb包两种形式。</p>\n<ul>\n<li>RPM包：最初是Red Hat Package Manager，后被重命名为RPM，是SUSE，Red Hat和Centos等发行版的首选软件包格式。</li>\n<li>Deb包：基于Debian GNU&#x2F;linux的管理包文件，常用于Debian发行版本比如Ubuntu，Linux mint等等。</li>\n</ul>\n<h3 id=\"包管理工具\"><a href=\"#包管理工具\" class=\"headerlink\" title=\"包管理工具\"></a>包管理工具</h3><h4 id=\"apt-Advanced-Package-Tool-：\"><a href=\"#apt-Advanced-Package-Tool-：\" class=\"headerlink\" title=\"apt(Advanced Package Tool)：\"></a>apt(Advanced Package Tool)：</h4><ol>\n<li>apt是Debian和Ubuntu等基于Debian的Linux发行版中的包管理工具。</li>\n<li>apt通过命令行工具apt-get和apt-cache提供了用户友好的接口，用于搜索、安装、升级和删除软件包。</li>\n<li>apt使用.deb软件包格式。</li>\n<li>apt还提供了aptitude和Synaptic等图形化前端工具，简化了软件包管理过程，具备自动下载和安装依赖的能力。</li>\n</ol>\n<h4 id=\"yum-Yellowdog-Updater-Modified\"><a href=\"#yum-Yellowdog-Updater-Modified\" class=\"headerlink\" title=\"yum(Yellowdog Updater Modified)\"></a>yum(Yellowdog Updater Modified)</h4><ol>\n<li>yum是Red Hat、CentOS和Fedora等基于Red Hat的Linux发行版中的软件包管理工具。</li>\n<li>yum通过命令行工具yum提供了用户友好的接口。</li>\n<li>yum使用.rpm软件包格式。</li>\n<li>yum还具有自动解决依赖关系的能力，可以自动下载和安装软件包的依赖项。</li>\n</ol>\n<h3 id=\"源码安装软件\"><a href=\"#源码安装软件\" class=\"headerlink\" title=\"源码安装软件\"></a>源码安装软件</h3><p>有一些开源软件，需要自行使用gcc等编译，这种场景无法统一，可以查阅官方文档结合日志搜索解决。</p>\n<h2 id=\"Linux网络配置\"><a href=\"#Linux网络配置\" class=\"headerlink\" title=\"Linux网络配置\"></a>Linux网络配置</h2><p>将单一的桌面PC连接到网络是一件容易的事情，但是将Linux服务器连接到网络，比如静态IP，VPN和代理服务器等等。学习网络配置管理，不仅要学会使用网络，更重要的是掌握网络状态，排查系统问题。</p>\n<p>传统的Linux网络配置通过network.service来实现，常见的命令有<code>ifconfig, ifup, ifdown</code>，用于查看，启动和关闭某个网络接口，比如eth0等等。</p>\n<p>后来，Linux系统诞生了NetworkManager这样的管理工具，但是两种工具使用一种即可，否则会有冲突。</p>\n<h3 id=\"NetwotkManager管理网络\"><a href=\"#NetwotkManager管理网络\" class=\"headerlink\" title=\"NetwotkManager管理网络\"></a>NetwotkManager管理网络</h3><h4 id=\"通过nmtui管理网络\"><a href=\"#通过nmtui管理网络\" class=\"headerlink\" title=\"通过nmtui管理网络\"></a>通过nmtui管理网络</h4><p>想通过nmtui管理网络的前提是网卡可以直接被NetworkManager管理，在Debian发行版下，下载安装NetworkManager的指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install network-manager</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，可以使用<code>nmcli device</code>查看网络设备:</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171812813.webp\" alt=\"image-20231017181234679\"></p>\n<p>直接输入nmtui即可使用GUI管理网络，也可以通过修改配置文件直接管理网络。</p>\n<blockquote>\n<p>nmtui是NetworkManager Text User Interface的缩写，是一个基于文本的图形界面工具，用于配置和管理网络连接。而nmcli则是通过命令行的形式管理计算机网络。</p>\n</blockquote>\n<p>在修改网络之后，需要重启网络服务以生效：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他网络指令\"><a href=\"#其他网络指令\" class=\"headerlink\" title=\"其他网络指令\"></a>其他网络指令</h4><ul>\n<li>netstat：使用netstat可以查看整个Linux系统的网络情况</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171824263.webp\" alt=\"image-20231017182432059\"></p>\n<p>最常用的指令<code>netstat -antp</code>，运行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171826399.webp\" alt=\"image-20231017182650172\"></p>\n<ul>\n<li>ss命令：SocketStatistics的缩写，用来获取socket的统计信息</li>\n</ul>\n<p>当服务器的socket连接数量变得非常大的时候，无论是使用netstat命令还是直接cat &#x2F;proc&#x2F;net&#x2F;tcp，执行速度都会很慢，ss用到了TCP协议栈中的tcp_diag，可以获得linux内核的第一手信息，效率极高。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171830301.webp\" alt=\"image-20231017183018127\"></p>\n<p>最常用指令：<code>ss -lntp</code>，以数字形式显示tcp连接，并显示进程名：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171831280.webp\" alt=\"image-20231017183137109\"></p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><p>Linux的进程在&#x2F;proc目录下，相关信息存在于以ID命名的目录中。</p>\n<blockquote>\n<p>Linux一切皆文件！</p>\n</blockquote>\n<ul>\n<li>查看进程：ps指令</li>\n</ul>\n<p><code>ps ux|less</code>：查看系统当前用户的所有进程，| less是管道处理，分页显示结果</p>\n<p><code>ps -A</code>查看所有进程</p>\n<ul>\n<li>关闭和修改进程：kill指令</li>\n</ul>\n<p>使用kill指令可以对某个进程发出信号，常见的信号如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171839352.webp\" alt=\"image-20231017183953235\"></p>\n<p>例如，在确保安全的情况下，可以使用<code>kill -9 1234</code>强制关闭1234进程。</p>\n<p>使用killall指令可以直接根据进程名杀死进程，例如<code>killall bash</code>。</p>\n<ul>\n<li>修改CPU使用优先级：nice指令</li>\n</ul>\n<p>Linux使用nice值定义进程访问CPU的优先级，位于[-20,19]区间，默认取值为0。</p>\n<ol>\n<li>nice值越低，访问CPU优先级越高，默认0。</li>\n<li>普通用户只能将自己的进程nice设为0~19。</li>\n<li>普通用户只能设置nice值变高。</li>\n<li>普通用户只能在自己的进程上设置nice。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nice -5 vim &amp;</span><br></pre></td></tr></table></figure>\n\n<p>将vim进程放在后台运行，并且设置nice值为0+5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">renice -n -5 1234</span><br></pre></td></tr></table></figure>\n\n<p>对进程ID为1234的nice减少5。</p>\n<ul>\n<li>守护进程：所有进程之母</li>\n</ul>\n<p>一般守护进程是init或systemd，位于进程表的第一行，Linux内核中有一个PID为0的进程，表示内核，守护进程的PID则设置为1。</p>\n<blockquote>\n<p>守护进程（daemon）是在操作系统后台运行的一种特殊类型的进程。它们通常在系统引导时启动，并且在整个系统运行期间持续运行。守护进程通常不与用户交互，而是在后台执行特定的任务或提供某种服务。它们被设计为在系统启动时自动运行，并且通常会一直运行，直到系统关闭或手动停止。</p>\n</blockquote>\n<ul>\n<li>服务管理：</li>\n</ul>\n<p>Linux下服务管理有两个指令，分别是service和systemctl指令，systemctl是Linux的最新初始化系统，兼容了service的指令。</p>\n<blockquote>\n<p>service和systemctl指令的本质都是执行&#x2F;etc&#x2F;init.d目录下的脚本</p>\n</blockquote>\n<p>systemctl常用方法如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171852378.webp\" alt=\"image-20231017185227218\"></p>\n<h2 id=\"Linux运维管理\"><a href=\"#Linux运维管理\" class=\"headerlink\" title=\"Linux运维管理\"></a>Linux运维管理</h2><h3 id=\"性能与服务\"><a href=\"#性能与服务\" class=\"headerlink\" title=\"性能与服务\"></a>性能与服务</h3><ul>\n<li>系统状态监控：<code>vmstat</code>，直接使用则输出当前的系统状态，第一个数字是持续输出的间隔秒数，第二个数字是持续时长秒数。例如<code>vmstat 1 5</code>表示间隔1s持续执行5次。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171855446.webp\" alt=\"image-20231017185513224\"></p>\n<ul>\n<li>内存资源监控：<code>free</code></li>\n</ul>\n<p>使用free指令可以查看系统的内存使用状态，如下图</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171857589.webp\" alt=\"image-20231017185749475\"></p>\n<h3 id=\"计划任务\"><a href=\"#计划任务\" class=\"headerlink\" title=\"计划任务\"></a>计划任务</h3><p>使用<code>crontab</code>可以编辑计划任务，选项如下：</p>\n<ol>\n<li>-u 指定用户名，不指定为当前用户</li>\n<li>-e 编辑计划任务</li>\n<li>-l 列出计划任务</li>\n<li>-r 删除所有计划任务</li>\n</ol>\n<p>创建单个计划任务的方法如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171901769.webp\" alt=\"image-20231017190131628\"></p>\n<p>如需要周期性地执行某些计划任务，则可以写成如下形式：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171903248.webp\" alt=\"image-20231017190308070\"></p>\n<h3 id=\"系统服务管理\"><a href=\"#系统服务管理\" class=\"headerlink\" title=\"系统服务管理\"></a>系统服务管理</h3><p>系统服务是在操作系统中以守护进程形式运行的软件组件，用于提供特定的功能或服务。这些服务在系统启动时自动启动，并在后台持续运行，以响应系统和用户的需求。</p>\n<p>Linux的系统服务一般位于<code>/usr/lib/systemd/system</code>路径下，具有每个系统服务的内容：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171907744.webp\" alt=\"image-20231017190730361\"></p>\n<blockquote>\n<p>后缀名解释：</p>\n<p>service:系统服务，如crond，sshd都是服务，包括自己安装的mysql-server等。</p>\n<p>target:多个unit组成（unit是一个逻辑概念，该目录下的都可以叫做unit，比如service等，target就是组合的unit）</p>\n<p>device:硬件设备</p>\n<p>mount:文件系统挂载点</p>\n<p>automount:自动挂载点</p>\n</blockquote>\n<ul>\n<li>创建系统服务：</li>\n</ul>\n<p>在服务路径下创建.service文件，该文件由三部分组成：</p>\n<ol>\n<li>[Unit]描述、文档等等</li>\n<li>[Service]类型，环境变量，具体指令</li>\n<li>[Install]服务安装到的target</li>\n</ol>\n<p>例如，某个service文件如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171915497.webp\" alt=\"image-20231017191507265\"></p>\n<p>使用不同的target可以设置不同的运行级别，使用<code>systemctl get-default</code>可以查看当前的运行级别。</p>\n<ul>\n<li>自启动服务</li>\n</ul>\n<p>使用<code>systemctl enable &lt;服务&gt;</code>可以设置服务自启动，反之，使用<code>systemctl disable &lt;服务&gt;</code>可以禁止服务自启动。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171920730.webp\" alt=\"image-20231017192014594\"></p>\n<h3 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h3><p>Linux下管理防火墙的软件比较多，在CentOS的5，6版本和Debian中主要使用iptables，在CentOS 7默认的防火墙管理工具是firewalld。主要学习iptables的配置方法，学有余力可以学习其改进版Shorewall。</p>\n<p>iptables是Linux系统中最常用的防火墙管理工具之一。它是一个基于内核的防火墙管理工具，通过操作netfilter框架实现网络包过滤和网络地址转换。Shorewall是一个基于iptables的高级防火墙管理工具，适用于各种Linux发行版。它提供了一个配置文件来定义防火墙规则，可以简化复杂的防火墙配置。Shorewall支持多种方式的配置，包括命令行和文本配置文件。</p>\n<h4 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h4><p>iptables由四个表，分别是：</p>\n<ol>\n<li>filter:默认表，用常用于过滤数据包</li>\n<li>nat:用于地址转换，侧重于连接管理</li>\n<li>mangle:侧重于每一个数据包管理，比如修改TTL</li>\n<li>raw:异常处理</li>\n</ol>\n<p>iptables五个链：</p>\n<ol>\n<li>input:处理进入系统的网络包</li>\n<li>output:处理从系统发送出去的网络包</li>\n<li>forward:处理通过系统转发的网络包</li>\n<li>prerouting:在路由决策之前处理进入系统的网络包</li>\n<li>postrouting:在路由决策之后处理即将离开系统的网络包</li>\n</ol>\n<p>iptables四表五链的对应关系：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171934972.webp\" alt=\"image-20231017193410854\"></p>\n<p>四表五链关系理解：</p>\n<ol>\n<li>filter表是最常用的表格，用于过滤网络包。它包含了三个默认的链（chains）：INPUT、OUTPUT和FORWARD。这些链用于处理进入系统、离开系统和通过系统转发的网络包。通过在这些链上配置规则，可以控制网络包的接受、拒绝、转发等。</li>\n<li>nat表用于网络地址转换（Network Address Translation，NAT）。它包含了三个默认的链：PREROUTING、OUTPUT和POSTROUTING。这些链用于在网络包进入和离开系统之前或之后修改包的源地址、目标地址、端口等。</li>\n<li>mangle表用于修改网络包的特定字段。它包含了五个默认的链：PREROUTING、INPUT、FORWARD、OUTPUT和POSTROUTING。这些链用于在不同的阶段对网络包进行修改，例如修改TTL字段、标记包、更改包的QoS等。</li>\n<li>raw表用于进行特定的包处理，如连接追踪（connection tracking）和数据包跳过（packet bypass）。它包含了两个默认的链：PREROUTING和OUTPUT。这些链允许在数据包进入和离开系统之前进行特定的处理和跳过。</li>\n</ol>\n<p>数据包的处理顺序如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171941869.webp\" alt=\"image-20231017194101680\"></p>\n<p>流量包通过防火墙，实际就是在这个处理顺序中检验是否满足规则，定义iptables规则的方法如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171942799.webp\" alt=\"image-20231017194230628\"></p>\n<ul>\n<li>iptables查看规则：<code>iptables -nvL --line-number</code></li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171947100.webp\" alt=\"image-20231017194700960\"></p>\n<p>该指令可以查看不同的链上的所有规则信息。</p>\n<ul>\n<li>iptables规则编写：</li>\n</ul>\n<p>新建一条规则，禁止目标端口为TCP22的访问，放在INPUT链的最后：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 22 -j DROP</span><br></pre></td></tr></table></figure>\n\n<p>指定某个规则序号删除指定规则，可以先使用上面的查看规则的指令获取序号，然后删除规则：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT 1</span><br></pre></td></tr></table></figure>\n\n<p>其他示例：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171951292.webp\" alt=\"image-20231017195128127\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310171952499.webp\" alt=\"image-20231017195206347\"></p>\n<h2 id=\"FTP服务器配置\"><a href=\"#FTP服务器配置\" class=\"headerlink\" title=\"FTP服务器配置\"></a>FTP服务器配置</h2><p>FTP(文本传输协议)，是一个用于在计算机网络上进行文件传输的应用层协议，一般运行在TCP20和TCP21两个端口，20端口用于在客户端和服务器之间传输数据流，21端口用于传输控制流，并且通向FTP服务器入口。</p>\n<p>FTP有两种工作模式，主动模式下，客户端开启端口，服务器主动连接客户端的端口；被动模式下，服务器开启端口，被动等待客户端连接。</p>\n<h3 id=\"FTP配置：vsftpd\"><a href=\"#FTP配置：vsftpd\" class=\"headerlink\" title=\"FTP配置：vsftpd\"></a>FTP配置：vsftpd</h3><p>在Linux中，一般使用vsftpd进行FTP服务配置，vsftpd是很多发行版本的默认软件，但是如果系统没有安装，则需要自行安装。在Debian系统上，配置vsftpd的文件位于&#x2F;etc&#x2F;vsftpd.conf。打开配置文件，可以发现：主动模式默认使用20端口进行连接。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172008330.webp\" alt=\"image-20231017200833224\"></p>\n<h3 id=\"vsftpd账号配置\"><a href=\"#vsftpd账号配置\" class=\"headerlink\" title=\"vsftpd账号配置\"></a>vsftpd账号配置</h3><p>vsftpd使用三种账号访问，匿名帐号，linux本地帐号和虚拟账号，推荐使用虚拟账号访问。使用虚拟账号访问的时候，建议关闭匿名帐号的相关权限，修改方法同样是编辑vsftpd.conf文件：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172013571.webp\" alt=\"image-20231017201301462\"></p>\n<p>开启了虚拟账号登录之后，我们需要对虚拟账号进行管理，首先需要配置vsftpd.conf：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172021363.webp\" alt=\"image-20231017202150233\"></p>\n<p>接下来就是准备上面配置中的东西，首先是创建一个虚拟账号对应的系统用户名，使用-s禁止该用户登录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd virtual_ftpuser -s /sbin/nologin</span><br></pre></td></tr></table></figure>\n\n<p>接下来在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd_login文件下加入用户信息，创建test1和test2两个账号，并且指定其密码。<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172025851.webp\" alt=\"image-20231017202521753\"></p>\n<p>然后生成账号的数据库文件，在Debian发行系统中需要自行安装db_load或使用其他命令（如db_load5.3）替代。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db_load -T -t hash -f /etc/vsftpd/vsftpd_login /etc/vsftpd/vsftpd_login.db</span><br></pre></td></tr></table></figure>\n\n<p>接下来配置两个用户的权限：在下面的目录创建两个文件：</p>\n<p>&#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test1</p>\n<p>&#x2F;etc&#x2F;vsftpd&#x2F;virtual_ftpuser_conf&#x2F;test2</p>\n<p>然后输入以下内容：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs%2Fvblog%2Fimage-20231017220552283.webp?q-sign-algorithm=sha1&q-ak=AKIDCbLd2jCUzkODBH4_S889m9PJWVKQ4ALCobKv1siJvZ8t0ACnZnNEXCIWIKoQZk0d&q-sign-time=1697551818;1697555418&q-key-time=1697551818;1697555418&q-header-list=&q-url-param-list=ci-process&q-signature=dcebd997749108a08bdcdb3e1c2ddc5df5ae450f&x-cos-security-token=r1H4WgNZExkVuYObwUtENLIhx2aBgJza091351a026a984b1330be7a6566bc7a8Z9fn7Qa58nqDuWUebadOp82oSHapqWPvXiPJAZFUxB9Np--oPJHQmK9oLQ1a_cbfiZ1VLpRUaN8PZ3BhrYxshlh4zeZ-epvl1SN2NZNVVFrXh3X3fB-Tp_EFrl8hU-luVRsdVpXCYfPfxHDdoWjeq9rE7EGUYWRghiHuRMAcu3M7fAha0pvdMWdobCR0XqSv&ci-process=originImage\"></p>\n<p>接下来创建文件和目录，分别所谓两个虚拟用户的访问根目录，并且在里面生成两个文件，当这两个用户登陆的时候，最开始看到的应该就是自己对应的文件。<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172212442.webp\" alt=\"image-20231017221212222\"></p>\n<p>完成了创建账户之后，我们就可以调用这些账号进行认证了，认证方法如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310172213436.webp\" alt=\"image-20231017221335233\"></p>\n<p>接下来重启系统服务即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart vsftpd</span><br></pre></td></tr></table></figure>\n\n<p>后面就可以使用ftp访问当前服务器了，并且可以实现虚拟用户登录。</p>\n<h2 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h2><h3 id=\"Shell脚本简介\"><a href=\"#Shell脚本简介\" class=\"headerlink\" title=\"Shell脚本简介\"></a>Shell脚本简介</h3><p>shell脚本在Linux的shell中工作，并不是一门编程语言，而是命令的集合，类似windows的bat文件。</p>\n<blockquote>\n<p>shell和bash之间的关系：</p>\n<p>Shell是一种命令行解释器（command-line interpreter），它是操作系统与用户之间的接口，用于解释和执行用户输入的命令。而Bash（Bourne Again Shell）是一种Unix shell，它是Shell的一种实现，也是目前最常用的Shell之一。</p>\n</blockquote>\n<p>在编写好shell脚本之后，需要赋予执行权限，才可以直接运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod -x test.sh</span><br><span class=\"line\"></span><br><span class=\"line\">./test.sh</span><br></pre></td></tr></table></figure>\n\n<p>下面编写一个shell脚本示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">d=`date +%H:%M:%S`</span><br><span class=\"line\">echo &quot;script start at $d&quot;</span><br><span class=\"line\">echo &#x27;wait 2 secs&#x27;</span><br><span class=\"line\">sleep 2</span><br><span class=\"line\">d1=`date +%H:%M:%S`</span><br><span class=\"line\">echo &quot;the script end at $d1&quot;</span><br></pre></td></tr></table></figure>\n\n<p>`date +%H:%M:%S`是一个整体的命令，需要用反引号括起来，表示获取当前时间的HHMMSS格式，echo是将内容送到控制台，当echo显示的内容有变量的时候，需要使用双引号，否则单引号即可。$表示获取变量。</p>\n<p>执行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310180958386.webp\" alt=\"image-20231018095811226\"></p>\n<h3 id=\"Shell脚本语法\"><a href=\"#Shell脚本语法\" class=\"headerlink\" title=\"Shell脚本语法\"></a>Shell脚本语法</h3><h4 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h4><p>数学运算需要用中括号括起来，要赋值的话还要加$号，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\">sum=$[$a+$b]</span><br><span class=\"line\">echo &quot;$a+$b=$sum&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h4><p>获取用户交互输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -p &quot;please input a number x :&quot; x</span><br><span class=\"line\">read -p &quot;please input a number y :&quot; y</span><br><span class=\"line\">sum=$[$x+$y]</span><br><span class=\"line\">echo &quot;x+y=$sum&quot;</span><br></pre></td></tr></table></figure>\n\n<p>其中-p是设置一条提示消息，用于提示用户需要输入的内容，其后直接跟变量名，无需声明。</p>\n<h4 id=\"脚本参数和脚本选项\"><a href=\"#脚本参数和脚本选项\" class=\"headerlink\" title=\"脚本参数和脚本选项\"></a>脚本参数和脚本选项</h4><p>编写一个脚本，获取其脚本参数的值并相加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum=$[$1+$2]</span><br></pre></td></tr></table></figure>\n\n<p>其中$1和$2代表第1个和第2个参数，而$0则表示该脚本名字本身。</p>\n<p>脚本则是带<code>-</code>的参数，比如<code>ls -l</code>，在实际执行脚本的时候，可以省略脚本选项。一般来说需要使用额外的脚本选项解析工具如getopt来解析，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:a:b:c&quot; opt; do</span><br><span class=\"line\">  case $opt in</span><br><span class=\"line\">    a)</span><br><span class=\"line\">      echo &quot;Option -a selected with value $OPTARG&quot;</span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    b)</span><br><span class=\"line\">      echo &quot;Option -b selected with value $OPTARG&quot;</span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    c)</span><br><span class=\"line\">      echo &quot;Option -c selected&quot;</span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    \\?)</span><br><span class=\"line\">      echo &quot;Invalid option: -$OPTARG&quot;</span><br><span class=\"line\">      ;;</span><br><span class=\"line\">  esac</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p>在上面的示例中，<code>getopts</code>命令用于循环遍历脚本的选项。每个选项都通过<code>case</code>语句进行处理，其中<code>$opt</code>表示当前选项，<code>$OPTARG</code>表示选项的参数值。</p>\n<h4 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h4><ul>\n<li>if语句逻辑判断：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -p &quot;input your score : &quot; a</span><br><span class=\"line\">if [ $a -gt 80 ];then</span><br><span class=\"line\">\techo &quot;good job&quot;</span><br><span class=\"line\">elif [ $a -gt 60 ];then</span><br><span class=\"line\">\techo &quot;you pass the exam&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">\techo &quot;you failed&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<p>逻辑表达式使用[]括起来，并且中括号内部两侧都需要有一个空格。-gt是greater than的缩写，其他的证书比较缩写如下图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181029738.webp\" alt=\"image-20231018102922511\"></p>\n<ul>\n<li>case条件判断</li>\n</ul>\n<p>case的语法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case $Num in</span><br><span class=\"line\">\t1) echo &#x27;Select 1&#x27;</span><br><span class=\"line\">\t;;</span><br><span class=\"line\">\t2) echo &#x27;Select 2&#x27;</span><br><span class=\"line\">\t;;</span><br><span class=\"line\">\t4|5) echo &#x27;Select 4 or 5&#x27;</span><br><span class=\"line\">\t;;</span><br><span class=\"line\">\t*) echo &#x27;Select othor&#x27;</span><br><span class=\"line\">\t;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n\n<p>shell脚本有严格的语法限制，注意分号的位置为下一行的开始，使用*表示其他的任意匹配。</p>\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><ul>\n<li>for循环</li>\n</ul>\n<p>for循环是一个十分常用的循环结构，常见的用法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &lt;var&gt; in &lt;cases&gt; ;do</span><br><span class=\"line\">\tcommand</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>while循环</li>\n</ul>\n<p>while循环在实际使用中可能会写成一个死循环，用于监控脚本,while语句的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while &lt;条件&gt;; do</span><br><span class=\"line\">\tcommand</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>until循环，语法和while循环一样，但是满足条件的时候终止循环。</li>\n<li>break用于中断，continue用于循环。</li>\n</ul>\n<p>下面有一些简单的练习，可供读者熟悉shell脚本编程:</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181105774.webp\" alt=\"image-20231018110505536\"></p>\n<h2 id=\"grep，sed和awk\"><a href=\"#grep，sed和awk\" class=\"headerlink\" title=\"grep，sed和awk\"></a>grep，sed和awk</h2><p><code>grep</code>、<code>sed</code>和<code>awk</code>是在Unix&#x2F;Linux环境中常用的文本处理工具，它们具有不同的特点和用途。</p>\n<h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>grep命令用于查找文件里面符合条件的字符串，或用于查找内容里包含指定范式的文件。</p>\n<ul>\n<li>查找文件内容</li>\n</ul>\n<p>语法为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep &lt;选项&gt; &lt;目标文字&gt; &lt;目标文件&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep tcpdump /etc/passwd</span><br></pre></td></tr></table></figure>\n\n<p>查找passwd中tcpdump用户的相关信息。</p>\n<ul>\n<li>查找指令内容，例如<code>ls -l | grep m*</code></li>\n</ul>\n<p>此外，所有的查找内容都可以使用正则表达式匹配。正则表达式的联系可以到<a href=\"https://tool.oschina.net/regex/\">网站</a>练习。</p>\n<h3 id=\"sed\"><a href=\"#sed\" class=\"headerlink\" title=\"sed\"></a>sed</h3><p><code>sed</code>是一个流式文本编辑器，可用于对文本进行替换、删除、插入、查找等操作。它使用简单的命令来操作文本，并且可以通过正则表达式进行模式匹配和替换。<code>sed</code>通常用于在脚本中批量处理文本数据，或者通过管道操作处理文本流。</p>\n<p>例如，一个使用sed将文本中的foo替换成为bar的示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;foo foo foo&quot; | sed &#x27;s/foo/bar/&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：<code>s/foo/bar/</code>。</p>\n<h3 id=\"awk\"><a href=\"#awk\" class=\"headerlink\" title=\"awk\"></a>awk</h3><p><code>awk</code>是一种用于处理和分析文本数据的强大工具。它是一种完整的编程语言，具有变量、循环、条件语句等常见编程特性。<code>awk</code>通过对输入文本逐行处理，并根据指定的模式和动作来提取和操作数据。</p>\n<p>使用awk命令从文本数据中提取第一列的示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;1,John,Doe&quot; | awk -F&#x27;,&#x27; &#x27;&#123; print $1 &#125;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为1。</p>\n<h1 id=\"Vscode免密登录\"><a href=\"#Vscode免密登录\" class=\"headerlink\" title=\"Vscode免密登录\"></a>Vscode免密登录</h1><ol>\n<li>使用ssh-keygen创建密钥对</li>\n<li>将公钥追加到authorized_keys，然后修改权限，重启sshd</li>\n<li>将密钥下载到本地主机</li>\n<li>配置.ssh&#x2F;_config</li>\n</ol>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202401021836117.webp\" alt=\"image-20240102183647945\"></p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://veni222987.github.io/tags/Linux/"}]},{"title":"【Sangfor】数据中心与云计算","date":"2023-10-16T09:23:04.000Z","path":"2023/10/16/【Sangfor】数据中心与云计算/","text":"本文是深信服云计算学习课程的笔记，主要记录了数据中心、负载均衡的相关重点知识。 数据中心与云计算数据中心数据中心概述数据中心（DC）是为集中放置的电子信息设备提供运行环境的建筑场所，包括主机房、辅助区等等，也就是一个实现信息的集中处理、存储、传输交换的物理空间。 互联网数据中心（IDC）包括了高速的接入带宽、高性能局域网等等。 云数据中心 2006年亚马逊推出云数据中心，开创了云数据中心的时代。我国在2007年底开始使用云服务。 传统的IT架构： 传统的数据中心缺点：资源分布分散，利用率低，平均业务恢复时间长，手工分配资源，资源无法弹性适配，多DC分散管理，协同性差。于是云数据中心成为了主流。 云数据中心优点：虚拟化、安全可靠、敏捷性高。 数据中心和服务器什么是服务器？服务器是计算机的一种，指在网络环境下运行特定的软件，为客户提供服务的计算机。服务器的特性：高可用性、可靠性、可扩展性、易用性、易管理性。 服务器应用部署的常见架构： 服务器的常见软件： 特殊系统软件：openstack虚拟化软件 服务器虚拟化：将物理资源抽象成为逻辑资源：将一台服务器变成几台甚至上百台相互隔离的虚拟服务器。 服务器的常见处理器架构： 安装软件的时候需要注意架构，鲲鹏、ARM和x86、AMD64一般有区别。 服务器总体层次下图总结了服务器的总体层次架构： 服务器的硬件结构服务器的硬件结构与一般的计算机结构基本一致，此处只摘取重点记录。 服务器内存条的注意事项： 硬盘的接口性能示意图： 所以买硬盘优先选择PCIe接口，最好不要选择SATA接口。 RAID技术（服务器关键技术）：有多个独立的高性能磁盘驱动器组成的磁盘子系统，提供比单个磁盘更高的性能。实现方式有两种： 硬件RAID：使用硬件RAID卡 软件RAID：通过操作系统在磁盘管理的方式管理磁盘组 BMC：BMC是基础管理控制器（Baseboard Management Controller）的缩写。它是一种嵌入式硬件设备，位于服务器或计算机系统的主板上，用于远程管理和监控系统的运行。BMC是一个独立的系统，不依赖其他硬件，也不依赖BIOS，OS等等，但可以与之交互。 负载均衡负载均衡概述负载均衡是一种在计算机网络中分配工作负载的技术，通过将请求分发到多个服务器上，以平衡服务器之间的负载，从而实现更高的吞吐量和更快的响应时间。 下面是一个负载均衡的示例：假设有一个负载均衡器和三台服务器（Server A、Server B和Server C）。当客户端发送请求时，请求首先到达负载均衡器。然后，负载均衡器根据预定义的算法（例如轮询、最小连接数等）选择一个服务器，并将请求转发到该服务器。 负载均衡分类：四层负载均衡（TCP）：流量分配到ip+port，一般用LVS实现 七层负载均衡（http）：流量分配到不同的url，一般用Nginx实现 负载均衡实现案例：DNS轮询多个服务器分配不同的IP地址，每次发过来的流量轮流发到不同的服务器中。 工作原理如下： 分配域名：在DNS服务器的配置中，为同一个域名（例如example.com）配置多个A记录，每个A记录对应一个服务器的IP地址。 轮询IP：当客户端发送一个DNS查询请求以获取域名的IP地址时，DNS服务器会按照预定义的顺序返回这些IP地址。 连接服务器：客户端将使用返回的IP地址之一，发起与服务器的连接。 下次选择：下一个客户端请求会按照相同的顺序，再次选择下一个IP地址。 负载均衡方案LVSLVS基础知识LVS全称Linux virtual server的简称。LVS服务器集群一般采用三层结构： 负载调度器：整个集群对外前端机，负责将客户的请求发到一组服务器执行，而客户认为服务来自同一个IP地址。 服务器池：一组真正执行客户请求的服务器，如WEB，MAIL，FTP和DNS服务器等。 共享存储：为服务器池提供共享的存储区 LVS部署模式：三种LVS相关的几种IP：CIP, VIP, DIP, RIP NAT模式：通过数据报头的修改，使得企业内部的私有IP地址可以访问外网，以及外部用户可以访问公司内网的私有IP主机。NAT有一个哈希表记录映射关系，用于实现流量通信的匹配。 访问WEB服务器的VIP-&gt;从调度列表中选出一台服务器，修改报头为DIP-&gt;访问RIP，从服务器返回实际的报文-&gt;建立通信，多次发送。 NAT模式的基本属性： RIP和DIP处于同一私有网段中（如无法满足，则确保它们能通信） 各RealServer指向DIP，保证响应能够交给Director。 缺点是Director负责所有进出数据，而响应数据比请求数据大得多，调度器容易出现瓶颈。 TUN模式：IP隧道是一种数据包装技术，它可以将原始数据包封装并且添加新的报头，将其发送给真正的服务器。一般用于VPN等。数据流图如下： 与NAT相比，RealServer直接返回客户机，修复了NAT中Director的瓶颈问题。 TUN模式的基本属性和要求： 各个RIP不需要处在同一网段，但是RIP必须和公网通信 RealServer的TUN接口上需要配置VIP地址，以便接受Director的数据包以及作为响应报文的源IP。 隧道位于Director和RealServer之间，隧道外层的IP头部的源IP是DIP，目标IP是RIP。而隧道内层的IP头可以分析得到源IP（VIP）和目标IP（CIP）。 需要添加一条特殊路由，使得后端服务器返回客户端的时候源IP为VIP。 DR模式：直接路由模式（Direct Routing）：DR模式中LVS依然只承担入站请求和选取服务器的任务，由后端真实服务器将其发回客户端。与隧道模式不同的是，RIP需要处在同一网段之中，返回的数据包中，源地址是VIP地址，目标地址是CIP地址。既不修改也不封装IP报文，而是将数据帧的MAC该为真正的MAC地址。 工作流图如下： 要求和DR和TUN模式类似，但是RIP必须在同一网段。 三种模式的比较： 比较项 NAT TUN DR 真实网关 负载调度器 自有路由器 自有路由器 IP地址 公网+私网 公网 私网 优点 安全性高 Wan加密数据 性能最高 缺点 效率低 需要隧道支持 无法跨LAN LVS调度算法LVS有八种调度算法： 轮询调度 加权轮询调度 最小连接调度 加权最小连接调度 基于局部性的最少链接 带复制的基于局部性的最少链接 目标地址散列调度 源地址散列调度 调度算法与操作系统课程中的思想类似，此处不加赘述，感兴趣者可自行了解。 LVS典型方案 LVS+Keepalived： keepalived是一个用于实现高可用性的软件，它通常与LVS结合使用。keepalived通过检测服务器的状态，例如网络连通性和服务可用性，来决定是否切换负载均衡器的主备角色。当主负载均衡器发生故障或不可用时，keepalived会自动将备负载均衡器切换为主角色，确保服务的持续可用性。 负载均衡方案Nginx理解Nginx应用场景Nginx是俄罗斯人编写的轻量级Web服务器。 什么是反向代理？客户端无感知代理的存在，以代理服务器接受Internet上面的请求，并将服务器上的结果返回请求的客户端。 什么是正向代理？当客户端无法访问外部资源的时候（比如墙），可以通过一个正向代理间接地去访问，所以正向代理是客户端需要配置代理服务器的ip。 Nginx基本模块 upstream模块：定义后端服务器列表，例如： 1234567891011# 动态服务器组upstream dynamic_server&#123; server localhost:8080; server localhost:8081;&#125;# 其他页面反向代理location ~.*$ &#123; index index.jsp index.html; proxy_pass http://dynamic_server;&#125; location ~.*$：这是一个正则表达式模式，表示匹配所有请求URI。~.*$的意思是忽略大小写的匹配任意字符，并且$表示匹配结尾。 理解Nginx调度算法目前Nginx服务器的upstream模块支持六种方式的分配：分别是轮询，权重，依据ip的分配，最小连接时间，相应时间和依据url的分配。 Nginx的高可用负载均衡架构 上述方法是主从服务器的架构图，使用Nginx和Keepalived实现了高可用性和安全性。 云计算云计算基础基础知识 云计算是一种基于网络的计算模型，它通过互联网连接和共享的方式，提供各种计算资源和服务，包括计算能力、存储空间、数据库、应用程序等。 云计算的主要特点是将计算和存储资源从本地的物理设备转移到云服务提供商的服务器上。 云计算主要分为三种服务模型：IaaS（如OpenStack)，PaaS(如阿里云等)，SaaS(如讯飞听见)。 平台的发展趋势是ABCD融合：A人工智能(AI)，B大数据(Big Data)，C云计算(Cloud)，D物联网(Device)。 云计算的关键技术在于虚拟化，虚拟化的思想将资源抽象成为共享的资源池，然后由云平台从资源池分配资源。 服务器虚拟化由多种技术架构，其中主要的四种如下： 典型方案是KVM和Xen两种，KVM（Kernel-based Virtual Machine）和Xen是两种常见的开源虚拟化方案。 KVM是一种基于Linux内核的虚拟化技术。它利用Linux内核中的虚拟化扩展（如Intel的VT或AMD的AMD-V）来实现硬件虚拟化，允许多个虚拟机在同一物理服务器上同时运行。KVM提供了直接访问物理硬件的能力，因此在性能方面表现良好。KVM是Linux内核的一部分，因此无需额外的内核模块。 Xen是一种基于虚拟机监视器（Hypervisor）的虚拟化技术。它通过将操作系统直接运行在硬件上，实现了虚拟机的创建和管理。Xen支持多种操作系统，包括Linux、Windows和其他一些主流操作系统。 典型的云服务实例：云服务由很多种，包括云主机、私有云、弹性伸缩、负载均衡等等。常见的需求和方案对应的云服务如下： “标准云”的架构可以分为三层：云管理平台、云平台和资源层。三层对应的著名产品如下： 虚拟化技术前面我们已经讲过，云计算最重要的一步就是将硬件资源虚拟化。虚拟化技术可以将计算机的硬件资源（如处理器、内存、存储和网络）进行抽象，使得多个虚拟机可以共享这些资源，并在逻辑上与物理计算机相隔离。这样，每个虚拟机就可以在自己的虚拟环境中运行操作系统和应用程序，就像独立的计算机一样。 虚拟化技术经过多年发展，已经成为一个庞大的家族，其中技术繁多，但是主要有四个分类指标： 按照实现方法分类按照实现方法分类的分类标准是通过软件辅助还是硬件辅助的方式实现对物理资源的访问拦截并且重定向。 按照上面的标准，可以将虚拟化分为软件辅助的虚拟化和硬件支持的虚拟化。 软件辅助的虚拟化 通过软件让客户机的特权指令陷入异常，从而触发宿主机进行虚拟化处理，实现对物理资源的截获和处理。常见的软件虚拟化工具有QEMU和Vmware Workstation。 优点：成本低廉，部署方便，管理维护简单 缺点：额外性能开销，增加了复杂性 硬件支持的虚拟化 通过物理平台本身提供的特殊指令，实现对硬件资源的模拟与支持。常见的有Intel的VT-x和AMD的AMD-V。 优点：性能优势，提供不同位数的操作系统支持 缺点：成本较高，维护麻烦 按照实现机制分类 半虚拟化 通过对客户操作系统内核进行修改，加入特定指令，直接调用硬件资源，避免由VMM层转换指令带来的性能开销。典型的半虚拟化技术如Xen。 全虚拟化 客户机的操作系统是不需要做任何修改的，客户机操作系统和底层硬件完全隔离，由VMM转化成底层调用代码，具备良好的兼容性。如KVM，VMWareStation。 虚拟化技术分类 裸机架构：直接使用VMM管理软件 宿主架构：硬件之上有一个普适操作系统 混合架构：兼而有之，其中KVM属于混合虚拟化。 还有其他的许多虚拟化技术，感兴趣者可自行查阅相关资料。 云计算典型方案下面我们将讲一下深信服的服务器虚拟化方案aSV、分布式存储方案aSAN、网络虚拟化方案aNET和深信服HCI超融合方案，这一部分直接了解即可，后面会单独详细讲解。 服务器虚拟化方案——aSV 分布式存储方案——aSAN 网络虚拟化方案——aNET 深信服超融合方案HCI 容器技术 Kubernetes是一个开源的容器编排和管理平台，用于自动化部署、扩展和管理容器化应用程序，不是虚拟化技术。 容器概述容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。 chroot技术 chroot，即change root directory，改变root目录。在Linux中，根目录为&#x2F;，执行上述指令可以改变用户的根目录。 namespace技术 Linux namespace是Linux提供的一种内核级别环境隔离方法，提供了对UTS、IPC、mount、PID和Network等的隔离机制。 Cgroup技术 与namespace技术类似，也是将程序进行分组。但是Cgroup是对一组进程进行统一的资源监控和限制。 容器规范：OCI 典型容器——DockerDocker是使用最广泛的开源容器引擎，是一种操作系统级的虚拟化技术，依赖于namespace和Cgroups技术。 Docker的基本组成如下： 具体的Docker容器可以自行查阅资料学习。 云原生云原生是一种构建和运行应用程序的方法，是技术体系和方法论。在云原生的架构下，开发模式，应用架构，部署运维都应当以云平台为基础： 云原生由四个要素： 微服务：几乎每个云原生的定义都包含微服务。 容器化：容器化为微服务提供保障。 DevOps：DevOps是一个敏捷思维，是一个沟通文化，也是组织形式。 持续交付：不误开发的交付，不停机实现更新，小步快跑，与传统的瀑布模型不同。 DevOps是一种融合软件开发（Development）和信息技术运维（Operations）的文化、方法和实践，旨在实现快速而可靠的软件交付和持续改进。DevOps的主要目标是通过增强开发团队和运维团队之间的协作和沟通，实现更快速、更频繁的软件交付。它强调自动化、持续集成和持续交付等实践，以减少部署错误、加快软件交付时间和提高系统稳定性。 云计算关键技术云计算的关键技术是虚拟化技术，而虚拟化技术又主要包括计算虚拟化、存储虚拟化和网络虚拟化。先来看一下虚拟化的几个基本概念： IDV（Integrated Desktop Virtualization）是一种虚拟化技术，它允许将整个桌面环境虚拟化并交付给用户。IDV技术将操作系统、应用程序和用户数据打包到一个虚拟桌面中，并通过网络将其传输到用户的终端设备上。 计算虚拟化内存虚拟化网络虚拟化OpenStackCMP介绍CMP(Cloud Management Platforms)是指云管理平台，是一种管理公有云、私有云和混合云环境的整合性产品。CMP可以用来管理OpenStack云环境，而Horizon只是用来管理OpenStack的Dashboard的。因此，CMP往往是以应用为中心的，而OpenStack是以基础设施为中心的。 OpenStackOpenStack是一个开源的云计算平台，用于构建和管理私有云和公有云基础设施。它提供了一组模块化的软件组件，用于实现虚拟化、网络、存储和计算等基础设施服务。OpenStack的主要组件如下： Nova（计算）：Nova是OpenStack的计算组件，负责管理和调度计算资源。它可以创建和管理虚拟机实例，并提供弹性计算能力。 Neutron（网络）：Neutron是OpenStack的网络组件，用于提供网络服务和管理网络资源。它支持虚拟网络的创建、子网和路由的配置，以及负载均衡和防火墙等网络功能。 Cinder（存储）：Cinder是OpenStack的存储组件，用于提供持久化块存储服务。它可以创建和管理块存储卷，并将其附加到虚拟机实例中。 Swift（对象存储）：Swift是OpenStack的对象存储组件，用于存储和检索大规模的非结构化数据。它提供了可扩展、冗余和持久的对象存储服务。 Keystone（身份认证）：Keystone是OpenStack的身份认证组件，用于管理用户、角色和权限等身份信息。它提供了统一的身份认证和授权机制，以确保只有经过授权的用户可以访问OpenStack的服务。 Horizon（管理界面）：Horizon是OpenStack的Web管理界面，用于管理和监控OpenStack的各个组件。它提供了直观的图形界面，使用户可以方便地管理云基础设施。 Glance（镜像服务）：Glance是OpenStack镜像服务的组件。 OpenStack的设计基本上是按照亚马逊设置的，可以将OpenStack理解为开源版本的AWS。OpenStack火起来的原因一个是Apache旗下的开源软件，另外就是使用python进行编写。 云计算交付和运维体系云计算商业应用存储基础存储方式 外挂存储的分类： DAS——直连式存储DAS(Direct Attached Storage)即开放系统的直连式存储，即主机设备或者计算设备直接通过物理接口和线缆连接存储磁盘，从而获得存储资源。是一种连接方式，不是协议。可以是服务器上自带的硬盘或者线缆直连硬盘盒。DAS与服务器之间的通道通常采用SCSI连接。 DAS有两种模式，JBOD的RAID。 DAS架构特点： 资源浪费，不利于共享：DAS直接挂在服务器上，随着需求增大，服务器和存储的设备数量变多，资源利用率地下。 占用服务器资源大：以来主机操作系统进行IO读写和存储维护。 扩展性差：采用SCSI连接，资源有限。 管理性差：由原设备厂商提供升级和扩展。 SAN——存储区域网络SAN是英文Storage Area Network的缩写，通常译为“存储区域网络”，它是一种在服务器和外部存储资源或独立的存储资源之间实现高速可靠的访问网络。其工作原理示意图如下： SAN存储，主要包括两种网络架构的SAN，一种是基于IP的SAN，一种是基于FC网络的SAN。两种架构的对比如下： NAS——网络附加存储NAS(Network Attached Storage)：网络附加存储，是一种集中存储、支持备份、可实现跨平台的数据共享，兼容性好的存储结构。特点如下： 支持网络文件共享协议NFS，CIFS NAS有自己的文件系统 基于TCP&#x2F;IP协议 NAS和CIFS协议 NFS(Network File System)即网络文件系统，是FreeBSD支持的文件系统中的一种，适用于类Unix操作系统，允许网络中的计算机之间通过TCP&#x2F;IP共享网络资源。在NFS中，本地NFS客户端应用可以透明地读写服务器上的文件，就像访问本地文件一样。 CIFS(Common Internet File System)仅适用于Windows操作系统，使客户端可以远程访问Internet计算机上的文件并提供服务，CIFS使用客户端服务器模式。 对比：CIFS面向网络连接的共享协议，常用TCP协议，而NFS可使用TCP或UDP。NFS缺点之一，要求client必须安装专用软件，而CIFS集成在OS内部，无需额外添加软件。 以下是DAS，NAS和SAN三种存储架构的对比： 存储协议不同的架构下，有不同的存储协议。下面是DAS，NAS和SAN的存储协议示意图： 这些协议作了解即可。 RAID技术RAID(Redundant Array of Independent Disk)即独立磁盘冗余阵列，通常简称为磁盘阵列。有软件RAID和硬件RAID两种连接方式。 RAID技术有三个关键概念：镜像(Mirroring)、数据条带(Data Stripping)和数据检验(Data parity)。 业界和学术界一般把RAID分成七个标准的RAID等级，等级之间不存在高低之分。","content":"<p>本文是深信服云计算学习课程的笔记，主要记录了数据中心、负载均衡的相关重点知识。<span id=\"more\"></span></p>\n<h1 id=\"数据中心与云计算\"><a href=\"#数据中心与云计算\" class=\"headerlink\" title=\"数据中心与云计算\"></a>数据中心与云计算</h1><h2 id=\"数据中心\"><a href=\"#数据中心\" class=\"headerlink\" title=\"数据中心\"></a>数据中心</h2><h3 id=\"数据中心概述\"><a href=\"#数据中心概述\" class=\"headerlink\" title=\"数据中心概述\"></a>数据中心概述</h3><p>数据中心（DC）是为集中放置的电子信息设备提供运行环境的建筑场所，包括主机房、辅助区等等，也就是一个实现信息的集中处理、存储、传输交换的物理空间。</p>\n<p>互联网数据中心（IDC）包括了高速的接入带宽、高性能局域网等等。</p>\n<h4 id=\"云数据中心\"><a href=\"#云数据中心\" class=\"headerlink\" title=\"云数据中心\"></a>云数据中心</h4><blockquote>\n<p>2006年亚马逊推出云数据中心，开创了云数据中心的时代。我国在2007年底开始使用云服务。</p>\n</blockquote>\n<p>传统的IT架构：</p>\n<div style=\"text-align:center\">\n    <img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161738200.webp\" alt=\"image\" />\n</div>\n\n<p>传统的数据中心缺点：资源分布分散，利用率低，平均业务恢复时间长，手工分配资源，资源无法弹性适配，多DC分散管理，协同性差。于是云数据中心成为了主流。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161749114.webp\" alt=\"image-20231016174921857\"></p>\n<p>云数据中心优点：虚拟化、安全可靠、敏捷性高。</p>\n<h3 id=\"数据中心和服务器\"><a href=\"#数据中心和服务器\" class=\"headerlink\" title=\"数据中心和服务器\"></a>数据中心和服务器</h3><h4 id=\"什么是服务器？\"><a href=\"#什么是服务器？\" class=\"headerlink\" title=\"什么是服务器？\"></a>什么是服务器？</h4><p>服务器是计算机的一种，指在网络环境下运行特定的软件，为客户提供服务的计算机。服务器的特性：高可用性、可靠性、可扩展性、易用性、易管理性。</p>\n<p>服务器应用部署的常见架构：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161752124.webp\" alt=\"image-20231016175247891\"></p>\n<h4 id=\"服务器的常见软件：\"><a href=\"#服务器的常见软件：\" class=\"headerlink\" title=\"服务器的常见软件：\"></a>服务器的常见软件：</h4><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161754636.webp\" alt=\"image-20231016175458410\"></p>\n<p>特殊系统软件：openstack虚拟化软件</p>\n<p><strong>服务器虚拟化</strong>：将物理资源抽象成为逻辑资源：将一台服务器变成几台甚至上百台相互隔离的虚拟服务器。</p>\n<p>服务器的常见处理器架构：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161800839.webp\" alt=\"image-20231016180057517\"></p>\n<p>安装软件的时候需要注意架构，鲲鹏、ARM和x86、AMD64一般有区别。</p>\n<h4 id=\"服务器总体层次\"><a href=\"#服务器总体层次\" class=\"headerlink\" title=\"服务器总体层次\"></a>服务器总体层次</h4><p>下图总结了服务器的总体层次架构：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161804776.webp\" alt=\"image-20231016180432518\"></p>\n<h4 id=\"服务器的硬件结构\"><a href=\"#服务器的硬件结构\" class=\"headerlink\" title=\"服务器的硬件结构\"></a>服务器的硬件结构</h4><p>服务器的硬件结构与一般的计算机结构基本一致，此处只摘取重点记录。</p>\n<p>服务器内存条的注意事项：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161808782.webp\" alt=\"image-20231016180838403\"></p>\n<p>硬盘的接口性能示意图：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161810386.webp\" alt=\"image-20231016181032036\"></p>\n<p>所以买硬盘优先选择PCIe接口，最好不要选择SATA接口。</p>\n<p><strong>RAID技术（服务器关键技术）</strong>：有多个独立的高性能磁盘驱动器组成的磁盘子系统，提供比单个磁盘更高的性能。实现方式有两种：</p>\n<ul>\n<li>硬件RAID：使用硬件RAID卡</li>\n<li>软件RAID：通过操作系统在磁盘管理的方式管理磁盘组</li>\n</ul>\n<p>BMC：BMC是基础管理控制器（Baseboard Management Controller）的缩写。它是一种嵌入式硬件设备，位于服务器或计算机系统的主板上，用于远程管理和监控系统的运行。BMC是一个独立的系统，不依赖其他硬件，也不依赖BIOS，OS等等，但可以与之交互。</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><h4 id=\"负载均衡概述\"><a href=\"#负载均衡概述\" class=\"headerlink\" title=\"负载均衡概述\"></a>负载均衡概述</h4><p>负载均衡是一种在计算机网络中分配工作负载的技术，通过将请求分发到多个服务器上，以平衡服务器之间的负载，从而实现更高的吞吐量和更快的响应时间。</p>\n<p>下面是一个负载均衡的示例：假设有一个负载均衡器和三台服务器（Server A、Server B和Server C）。当客户端发送请求时，请求首先到达负载均衡器。然后，负载均衡器根据预定义的算法（例如轮询、最小连接数等）选择一个服务器，并将请求转发到该服务器。</p>\n<p>负载均衡分类：<br><strong>四层负载均衡（TCP）</strong>：流量分配到<strong>ip+port</strong>，一般用<strong>LVS</strong>实现</p>\n<p><strong>七层负载均衡（http）</strong>：流量分配到不同的<strong>url</strong>，一般用<strong>Nginx</strong>实现</p>\n<h4 id=\"负载均衡实现案例：DNS轮询\"><a href=\"#负载均衡实现案例：DNS轮询\" class=\"headerlink\" title=\"负载均衡实现案例：DNS轮询\"></a>负载均衡实现案例：DNS轮询</h4><p>多个服务器分配不同的IP地址，每次发过来的流量轮流发到不同的服务器中。</p>\n<p>工作原理如下：</p>\n<ul>\n<li><strong>分配域名：</strong>在DNS服务器的配置中，为同一个域名（例如example.com）配置多个A记录，每个A记录对应一个服务器的IP地址。</li>\n<li><strong>轮询IP：</strong>当客户端发送一个DNS查询请求以获取域名的IP地址时，DNS服务器会按照预定义的顺序返回这些IP地址。</li>\n<li><strong>连接服务器：</strong>客户端将使用返回的IP地址之一，发起与服务器的连接。</li>\n<li><strong>下次选择：</strong>下一个客户端请求会按照相同的顺序，再次选择下一个IP地址。</li>\n</ul>\n<h4 id=\"负载均衡方案LVS\"><a href=\"#负载均衡方案LVS\" class=\"headerlink\" title=\"负载均衡方案LVS\"></a>负载均衡方案LVS</h4><h5 id=\"LVS基础知识\"><a href=\"#LVS基础知识\" class=\"headerlink\" title=\"LVS基础知识\"></a>LVS基础知识</h5><p>LVS全称Linux virtual server的简称。LVS服务器集群一般采用三层结构：</p>\n<ul>\n<li><strong>负载调度器：</strong>整个集群对外前端机，负责将客户的请求发到一组服务器执行，而客户认为服务来自同一个IP地址。</li>\n<li><strong>服务器池：</strong>一组真正执行客户请求的服务器，如WEB，MAIL，FTP和DNS服务器等。</li>\n<li><strong>共享存储：</strong>为服务器池提供共享的存储区</li>\n</ul>\n<h5 id=\"LVS部署模式：三种\"><a href=\"#LVS部署模式：三种\" class=\"headerlink\" title=\"LVS部署模式：三种\"></a>LVS部署模式：三种</h5><p>LVS相关的几种IP：CIP, VIP, DIP, RIP</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161846727.webp\" alt=\"image-20231016184603525\"></p>\n<h6 id=\"NAT模式：\"><a href=\"#NAT模式：\" class=\"headerlink\" title=\"NAT模式：\"></a>NAT模式：</h6><p>通过数据报头的修改，使得企业内部的私有IP地址可以访问外网，以及外部用户可以访问公司内网的私有IP主机。NAT有一个哈希表记录映射关系，用于实现流量通信的匹配。</p>\n<p>访问WEB服务器的VIP-&gt;从调度列表中选出一台服务器，修改报头为DIP-&gt;访问RIP，从服务器返回实际的报文-&gt;建立通信，多次发送。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161852789.webp\" alt=\"image-20231016185245577\"></p>\n<p>NAT模式的基本属性：</p>\n<ol>\n<li>RIP和DIP处于同一私有网段中（如无法满足，则确保它们能通信）</li>\n<li>各RealServer指向DIP，保证响应能够交给Director。</li>\n<li>缺点是Director负责所有进出数据，而响应数据比请求数据大得多，调度器容易出现瓶颈。</li>\n</ol>\n<h6 id=\"TUN模式：\"><a href=\"#TUN模式：\" class=\"headerlink\" title=\"TUN模式：\"></a>TUN模式：</h6><p>IP隧道是一种数据包装技术，它可以将原始数据包封装并且添加新的报头，将其发送给真正的服务器。一般用于VPN等。数据流图如下：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161902587.webp\" alt=\"image-20231016190254377\"></p>\n<p>与NAT相比，RealServer直接返回客户机，修复了NAT中Director的瓶颈问题。</p>\n<p>TUN模式的基本属性和要求：</p>\n<ol>\n<li>各个RIP不需要处在同一网段，但是RIP必须和公网通信</li>\n<li>RealServer的TUN接口上需要配置VIP地址，以便接受Director的数据包以及作为响应报文的源IP。</li>\n<li>隧道位于Director和RealServer之间，隧道外层的IP头部的源IP是DIP，目标IP是RIP。而隧道内层的IP头可以分析得到源IP（VIP）和目标IP（CIP）。</li>\n<li>需要添加一条特殊路由，使得后端服务器返回客户端的时候源IP为VIP。</li>\n</ol>\n<h6 id=\"DR模式：\"><a href=\"#DR模式：\" class=\"headerlink\" title=\"DR模式：\"></a>DR模式：</h6><p>直接路由模式（Direct Routing）：DR模式中LVS依然只承担入站请求和选取服务器的任务，由后端真实服务器将其发回客户端。与隧道模式不同的是，RIP需要处在同一网段之中，返回的数据包中，源地址是VIP地址，目标地址是CIP地址。既不修改也不封装IP报文，而是将数据帧的MAC该为真正的MAC地址。</p>\n<p>工作流图如下：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161927813.webp\" alt=\"image-20231016192757568\"></p>\n<p>要求和DR和TUN模式类似，但是RIP必须在同一网段。</p>\n<p>三种模式的比较：</p>\n<table>\n<thead>\n<tr>\n<th>比较项</th>\n<th>NAT</th>\n<th>TUN</th>\n<th>DR</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>真实网关</td>\n<td>负载调度器</td>\n<td>自有路由器</td>\n<td>自有路由器</td>\n</tr>\n<tr>\n<td>IP地址</td>\n<td>公网+私网</td>\n<td>公网</td>\n<td>私网</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>安全性高</td>\n<td>Wan加密数据</td>\n<td>性能最高</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>效率低</td>\n<td>需要隧道支持</td>\n<td>无法跨LAN</td>\n</tr>\n</tbody></table>\n<h5 id=\"LVS调度算法\"><a href=\"#LVS调度算法\" class=\"headerlink\" title=\"LVS调度算法\"></a>LVS调度算法</h5><p>LVS有八种调度算法：</p>\n<ol>\n<li>轮询调度</li>\n<li>加权轮询调度</li>\n<li>最小连接调度</li>\n<li>加权最小连接调度</li>\n<li>基于局部性的最少链接</li>\n<li>带复制的基于局部性的最少链接</li>\n<li>目标地址散列调度</li>\n<li>源地址散列调度</li>\n</ol>\n<p>调度算法与操作系统课程中的思想类似，此处不加赘述，感兴趣者可自行了解。</p>\n<h5 id=\"LVS典型方案\"><a href=\"#LVS典型方案\" class=\"headerlink\" title=\"LVS典型方案\"></a>LVS典型方案</h5><ul>\n<li><p>LVS+Keepalived：</p>\n<p>  keepalived是一个用于实现高可用性的软件，它通常与LVS结合使用。keepalived通过检测服务器的状态，例如网络连通性和服务可用性，来决定是否切换负载均衡器的主备角色。当主负载均衡器发生故障或不可用时，keepalived会自动将备负载均衡器切换为主角色，确保服务的持续可用性。</p>\n</li>\n</ul>\n<h4 id=\"负载均衡方案Nginx\"><a href=\"#负载均衡方案Nginx\" class=\"headerlink\" title=\"负载均衡方案Nginx\"></a>负载均衡方案Nginx</h4><h5 id=\"理解Nginx应用场景\"><a href=\"#理解Nginx应用场景\" class=\"headerlink\" title=\"理解Nginx应用场景\"></a>理解Nginx应用场景</h5><p>Nginx是俄罗斯人编写的轻量级Web服务器。</p>\n<p>什么是反向代理？客户端无感知代理的存在，以代理服务器接受Internet上面的请求，并将服务器上的结果返回请求的客户端。</p>\n<p>什么是正向代理？当客户端无法访问外部资源的时候（比如墙），可以通过一个正向代理间接地去访问，所以正向代理是客户端需要配置代理服务器的ip。</p>\n<h6 id=\"Nginx基本模块\"><a href=\"#Nginx基本模块\" class=\"headerlink\" title=\"Nginx基本模块\"></a>Nginx基本模块</h6><ul>\n<li>upstream模块：定义后端服务器列表，例如：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 动态服务器组</span><br><span class=\"line\">upstream dynamic_server&#123;</span><br><span class=\"line\">\tserver localhost:8080;</span><br><span class=\"line\">\tserver localhost:8081;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 其他页面反向代理</span><br><span class=\"line\">location ~.*$ &#123;</span><br><span class=\"line\">\tindex index.jsp index.html;</span><br><span class=\"line\">\tproxy_pass http://dynamic_server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>location ~.*$</code>：这是一个正则表达式模式，表示匹配所有请求URI。<code>~.*$</code>的意思是忽略大小写的匹配任意字符，并且<code>$</code>表示匹配结尾。</li>\n</ul>\n<h5 id=\"理解Nginx调度算法\"><a href=\"#理解Nginx调度算法\" class=\"headerlink\" title=\"理解Nginx调度算法\"></a>理解Nginx调度算法</h5><p>目前Nginx服务器的upstream模块支持六种方式的分配：分别是轮询，权重，依据ip的分配，最小连接时间，相应时间和依据url的分配。</p>\n<h5 id=\"Nginx的高可用负载均衡架构\"><a href=\"#Nginx的高可用负载均衡架构\" class=\"headerlink\" title=\"Nginx的高可用负载均衡架构\"></a>Nginx的高可用负载均衡架构</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310161957039.webp\" alt=\"image-20231016195718716\"></p>\n<p>上述方法是主从服务器的架构图，使用Nginx和Keepalived实现了高可用性和安全性。</p>\n<h2 id=\"云计算\"><a href=\"#云计算\" class=\"headerlink\" title=\"云计算\"></a>云计算</h2><h3 id=\"云计算基础\"><a href=\"#云计算基础\" class=\"headerlink\" title=\"云计算基础\"></a>云计算基础</h3><h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211632769.webp\" alt=\"image-20231021163237669\"></p>\n<p>云计算是一种基于网络的计算模型，它通过互联网连接和共享的方式，提供各种计算资源和服务，包括计算能力、存储空间、数据库、应用程序等。</p>\n<p>云计算的主要特点是将计算和存储资源从本地的物理设备转移到云服务提供商的服务器上。</p>\n<p>云计算主要分为三种服务模型：IaaS（如OpenStack)，PaaS(如阿里云等)，SaaS(如讯飞听见)。</p>\n<p>平台的发展趋势是ABCD融合：A人工智能(AI)，B大数据(Big Data)，C云计算(Cloud)，D物联网(Device)。</p>\n<p>云计算的关键技术在于虚拟化，虚拟化的思想将资源抽象成为共享的资源池，然后由云平台从资源池分配资源。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181159548.webp\" alt=\"image-20231018115943283\"></p>\n<p>服务器虚拟化由多种技术架构，其中主要的四种如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181751512.webp\" alt=\"image-20231018173203055\"></p>\n<p>典型方案是KVM和Xen两种，KVM（Kernel-based Virtual Machine）和Xen是两种常见的开源虚拟化方案。</p>\n<p>KVM是一种基于Linux内核的虚拟化技术。它利用Linux内核中的虚拟化扩展（如Intel的VT或AMD的AMD-V）来实现硬件虚拟化，允许多个虚拟机在同一物理服务器上同时运行。KVM提供了直接访问物理硬件的能力，因此在性能方面表现良好。KVM是Linux内核的一部分，因此无需额外的内核模块。</p>\n<p>Xen是一种基于虚拟机监视器（Hypervisor）的虚拟化技术。它通过将操作系统直接运行在硬件上，实现了虚拟机的创建和管理。Xen支持多种操作系统，包括Linux、Windows和其他一些主流操作系统。</p>\n<p>典型的云服务实例：云服务由很多种，包括云主机、私有云、弹性伸缩、负载均衡等等。常见的需求和方案对应的云服务如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181759399.webp\" alt=\"image-20231018175947141\"></p>\n<p>“标准云”的架构可以分为三层：云管理平台、云平台和资源层。三层对应的著名产品如下：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211102854.webp\" alt=\"image-20231021110156554\"></p>\n<h4 id=\"虚拟化技术\"><a href=\"#虚拟化技术\" class=\"headerlink\" title=\"虚拟化技术\"></a>虚拟化技术</h4><p>前面我们已经讲过，云计算最重要的一步就是将硬件资源虚拟化。虚拟化技术可以将计算机的硬件资源（如处理器、内存、存储和网络）进行抽象，使得多个虚拟机可以共享这些资源，并在逻辑上与物理计算机相隔离。这样，每个虚拟机就可以在自己的虚拟环境中运行操作系统和应用程序，就像独立的计算机一样。</p>\n<p>虚拟化技术经过多年发展，已经成为一个庞大的家族，其中技术繁多，但是主要有四个分类指标：</p>\n<h5 id=\"按照实现方法分类\"><a href=\"#按照实现方法分类\" class=\"headerlink\" title=\"按照实现方法分类\"></a>按照实现方法分类</h5><p>按照实现方法分类的分类标准是通过软件辅助还是硬件辅助的方式实现对物理资源的访问拦截并且重定向。</p>\n<p>按照上面的标准，可以将虚拟化分为软件辅助的虚拟化和硬件支持的虚拟化。</p>\n<ul>\n<li>软件辅助的虚拟化</li>\n</ul>\n<p>通过软件让客户机的特权指令陷入异常，从而触发宿主机进行虚拟化处理，实现对物理资源的截获和处理。常见的软件虚拟化工具有<strong>QEMU和Vmware Workstation</strong>。</p>\n<p>优点：成本低廉，部署方便，管理维护简单</p>\n<p>缺点：额外性能开销，增加了复杂性</p>\n<ul>\n<li>硬件支持的虚拟化</li>\n</ul>\n<p>通过物理平台本身提供的特殊指令，实现对硬件资源的模拟与支持。常见的有<strong>Intel的VT-x和AMD的AMD-V</strong>。</p>\n<p>优点：性能优势，提供不同位数的操作系统支持</p>\n<p>缺点：成本较高，维护麻烦</p>\n<h5 id=\"按照实现机制分类\"><a href=\"#按照实现机制分类\" class=\"headerlink\" title=\"按照实现机制分类\"></a>按照实现机制分类</h5><ul>\n<li>半虚拟化</li>\n</ul>\n<p>通过对客户操作系统内核进行修改，加入特定指令，直接调用硬件资源，避免由VMM层转换指令带来的性能开销。典型的<strong>半虚拟化技术如Xen</strong>。</p>\n<ul>\n<li>全虚拟化</li>\n</ul>\n<p>客户机的操作系统是不需要做任何修改的，客户机操作系统和底层硬件完全隔离，由VMM转化成底层调用代码，具备良好的兼容性。<strong>如KVM，VMWareStation。</strong></p>\n<h5 id=\"虚拟化技术分类\"><a href=\"#虚拟化技术分类\" class=\"headerlink\" title=\"虚拟化技术分类\"></a>虚拟化技术分类</h5><ul>\n<li>裸机架构：直接使用VMM管理软件</li>\n<li>宿主架构：硬件之上有一个普适操作系统</li>\n<li>混合架构：兼而有之，<strong>其中KVM属于混合虚拟化</strong>。</li>\n</ul>\n<p>还有其他的许多虚拟化技术，感兴趣者可自行查阅相关资料。</p>\n<h4 id=\"云计算典型方案\"><a href=\"#云计算典型方案\" class=\"headerlink\" title=\"云计算典型方案\"></a>云计算典型方案</h4><p>下面我们将讲一下深信服的服务器虚拟化方案aSV、分布式存储方案aSAN、网络虚拟化方案aNET和深信服HCI超融合方案，这一部分直接了解即可，后面会单独详细讲解。</p>\n<h5 id=\"服务器虚拟化方案——aSV\"><a href=\"#服务器虚拟化方案——aSV\" class=\"headerlink\" title=\"服务器虚拟化方案——aSV\"></a>服务器虚拟化方案——aSV</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181823623.webp\" alt=\"image-20231018182330353\"></p>\n<h5 id=\"分布式存储方案——aSAN\"><a href=\"#分布式存储方案——aSAN\" class=\"headerlink\" title=\"分布式存储方案——aSAN\"></a>分布式存储方案——aSAN</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181824926.webp\" alt=\"image-20231018182432624\"></p>\n<h5 id=\"网络虚拟化方案——aNET\"><a href=\"#网络虚拟化方案——aNET\" class=\"headerlink\" title=\"网络虚拟化方案——aNET\"></a>网络虚拟化方案——aNET</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181825999.webp\" alt=\"image-20231018182516725\"></p>\n<h5 id=\"深信服超融合方案HCI\"><a href=\"#深信服超融合方案HCI\" class=\"headerlink\" title=\"深信服超融合方案HCI\"></a>深信服超融合方案HCI</h5><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181826692.webp\" alt=\"image-20231018182617359\"></p>\n<h4 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h4><ul>\n<li><strong>Kubernetes</strong>是一个开源的容器编排和管理平台，用于自动化部署、扩展和管理容器化应用程序，不是虚拟化技术。</li>\n</ul>\n<h5 id=\"容器概述\"><a href=\"#容器概述\" class=\"headerlink\" title=\"容器概述\"></a>容器概述</h5><p>容器技术是一种虚拟化技术，用于将应用程序及其所有依赖项打包成独立的运行时环境，称为容器。每个容器都是相互隔离的，拥有自己的文件系统、进程空间和网络接口。容器可以理解成为“运行在一个操作系统上的一个独立系统”。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211629334.webp\" alt=\"image-20231021162923235\"></p>\n<ul>\n<li>chroot技术</li>\n</ul>\n<p>chroot，即change root directory，改变root目录。在Linux中，根目录为&#x2F;，执行上述指令可以改变用户的根目录。</p>\n<ul>\n<li>namespace技术</li>\n</ul>\n<p>Linux namespace是Linux提供的一种内核级别环境隔离方法，提供了对UTS、IPC、mount、PID和Network等的隔离机制。</p>\n<ul>\n<li>Cgroup技术</li>\n</ul>\n<p>与namespace技术类似，也是将程序进行分组。但是Cgroup是对一组进程进行统一的资源监控和限制。</p>\n<p>容器规范：OCI</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181836779.webp\" alt=\"image-20231018183649557\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181837337.webp\" alt=\"image-20231018183710065\"></p>\n<h5 id=\"典型容器——Docker\"><a href=\"#典型容器——Docker\" class=\"headerlink\" title=\"典型容器——Docker\"></a>典型容器——Docker</h5><p>Docker是使用最广泛的开源容器引擎，是一种操作系统级的虚拟化技术，依赖于namespace和Cgroups技术。</p>\n<p>Docker的基本组成如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181839117.webp\" alt=\"image-20231018183931847\"></p>\n<p>具体的Docker容器可以自行查阅资料学习。</p>\n<h4 id=\"云原生\"><a href=\"#云原生\" class=\"headerlink\" title=\"云原生\"></a>云原生</h4><p>云原生是一种构建和运行应用程序的方法，是技术体系和方法论。在云原生的架构下，开发模式，应用架构，部署运维都应当以云平台为基础：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181843006.webp\" alt=\"image-20231018184308771\"></p>\n<p>云原生由四个要素：</p>\n<ol>\n<li>微服务：几乎每个云原生的定义都包含微服务。</li>\n<li>容器化：容器化为微服务提供保障。</li>\n<li>DevOps：DevOps是一个敏捷思维，是一个沟通文化，也是组织形式。</li>\n<li>持续交付：不误开发的交付，不停机实现更新，小步快跑，与传统的瀑布模型不同。</li>\n</ol>\n<blockquote>\n<p>DevOps是一种融合软件开发（Development）和信息技术运维（Operations）的文化、方法和实践，旨在实现快速而可靠的软件交付和持续改进。DevOps的主要目标是通过增强开发团队和运维团队之间的协作和沟通，实现更快速、更频繁的软件交付。它强调自动化、持续集成和持续交付等实践，以减少部署错误、加快软件交付时间和提高系统稳定性。</p>\n</blockquote>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211603341.webp\" alt=\"image-20231021160331229\"></p>\n<h3 id=\"云计算关键技术\"><a href=\"#云计算关键技术\" class=\"headerlink\" title=\"云计算关键技术\"></a>云计算关键技术</h3><p>云计算的关键技术是虚拟化技术，而虚拟化技术又主要包括计算虚拟化、存储虚拟化和网络虚拟化。先来看一下虚拟化的几个基本概念：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310181851942.webp\" alt=\"image-20231018185123724\"></p>\n<p>IDV（Integrated Desktop Virtualization）是一种虚拟化技术，它允许将整个桌面环境虚拟化并交付给用户。<strong>IDV技术将操作系统、应用程序和用户数据打包到一个虚拟桌面中，并通过网络将其传输到用户的终端设备上</strong>。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211625919.webp\" alt=\"image-20231021162425358\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211627113.webp\" alt=\"image-20231021162748995\"></p>\n<h4 id=\"计算虚拟化\"><a href=\"#计算虚拟化\" class=\"headerlink\" title=\"计算虚拟化\"></a>计算虚拟化</h4><h4 id=\"内存虚拟化\"><a href=\"#内存虚拟化\" class=\"headerlink\" title=\"内存虚拟化\"></a>内存虚拟化</h4><h4 id=\"网络虚拟化\"><a href=\"#网络虚拟化\" class=\"headerlink\" title=\"网络虚拟化\"></a>网络虚拟化</h4><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><h4 id=\"CMP介绍\"><a href=\"#CMP介绍\" class=\"headerlink\" title=\"CMP介绍\"></a>CMP介绍</h4><p>CMP(Cloud Management Platforms)是指云管理平台，是一种管理公有云、私有云和混合云环境的整合性产品。CMP可以用来管理OpenStack云环境，而Horizon只是用来管理OpenStack的Dashboard的。因此，CMP往往是以应用为中心的，而OpenStack是以基础设施为中心的。</p>\n<h4 id=\"OpenStack-1\"><a href=\"#OpenStack-1\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h4><p>OpenStack是一个开源的云计算平台，用于构建和管理私有云和公有云基础设施。它提供了一组模块化的软件组件，用于实现虚拟化、网络、存储和计算等基础设施服务。OpenStack的主要组件如下：</p>\n<ol>\n<li><strong>Nova（计算）</strong>：Nova是OpenStack的计算组件，负责管理和调度计算资源。它可以创建和管理虚拟机实例，并提供弹性计算能力。</li>\n<li><strong>Neutron（网络）</strong>：Neutron是OpenStack的网络组件，用于提供网络服务和管理网络资源。它支持虚拟网络的创建、子网和路由的配置，以及负载均衡和防火墙等网络功能。</li>\n<li><strong>Cinder（存储）</strong>：Cinder是OpenStack的存储组件，用于提供持久化块存储服务。它可以创建和管理块存储卷，并将其附加到虚拟机实例中。</li>\n<li><strong>Swift（对象存储）</strong>：Swift是OpenStack的对象存储组件，用于存储和检索大规模的非结构化数据。它提供了可扩展、冗余和持久的对象存储服务。</li>\n<li><strong>Keystone（身份认证）</strong>：Keystone是OpenStack的身份认证组件，用于管理用户、角色和权限等身份信息。它提供了统一的身份认证和授权机制，以确保只有经过授权的用户可以访问OpenStack的服务。</li>\n<li><strong>Horizon（管理界面）</strong>：Horizon是OpenStack的Web管理界面，用于管理和监控OpenStack的各个组件。它提供了直观的图形界面，使用户可以方便地管理云基础设施。</li>\n<li><strong>Glance（镜像服务）</strong>：Glance是OpenStack镜像服务的组件。</li>\n</ol>\n<p>OpenStack的设计基本上是按照亚马逊设置的，可以将OpenStack理解为开源版本的AWS。OpenStack火起来的原因一个是Apache旗下的开源软件，另外就是使用python进行编写。</p>\n<h3 id=\"云计算交付和运维体系\"><a href=\"#云计算交付和运维体系\" class=\"headerlink\" title=\"云计算交付和运维体系\"></a>云计算交付和运维体系</h3><h3 id=\"云计算商业应用\"><a href=\"#云计算商业应用\" class=\"headerlink\" title=\"云计算商业应用\"></a>云计算商业应用</h3><h2 id=\"存储基础\"><a href=\"#存储基础\" class=\"headerlink\" title=\"存储基础\"></a>存储基础</h2><h3 id=\"存储方式\"><a href=\"#存储方式\" class=\"headerlink\" title=\"存储方式\"></a>存储方式</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211144206.webp\" alt=\"image-20231021114422063\"></p>\n<p>外挂存储的分类：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211153332.webp\" alt=\"image-20231021115335090\"></p>\n<h4 id=\"DAS——直连式存储\"><a href=\"#DAS——直连式存储\" class=\"headerlink\" title=\"DAS——直连式存储\"></a>DAS——直连式存储</h4><p>DAS(Direct Attached Storage)即开放系统的直连式存储，即主机设备或者计算设备直接通过物理接口和线缆连接存储磁盘，从而获得存储资源。是一种连接方式，不是协议。可以是服务器上自带的硬盘或者线缆直连硬盘盒。DAS与服务器之间的通道通常采用SCSI连接。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211156540.webp\" alt=\"image-20231021115639268\"></p>\n<p>DAS有两种模式，JBOD的RAID。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211200496.webp\" alt=\"image-20231021120040252\"></p>\n<p>DAS架构特点：</p>\n<ol>\n<li>资源浪费，不利于共享：DAS直接挂在服务器上，随着需求增大，服务器和存储的设备数量变多，资源利用率地下。</li>\n<li>占用服务器资源大：以来主机操作系统进行IO读写和存储维护。</li>\n<li>扩展性差：采用SCSI连接，资源有限。</li>\n<li>管理性差：由原设备厂商提供升级和扩展。</li>\n</ol>\n<h4 id=\"SAN——存储区域网络\"><a href=\"#SAN——存储区域网络\" class=\"headerlink\" title=\"SAN——存储区域网络\"></a>SAN——存储区域网络</h4><p>SAN是英文Storage Area Network的缩写，通常译为“存储区域网络”，它是一种在服务器和外部存储资源或独立的存储资源之间实现高速可靠的访问网络。其工作原理示意图如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211424735.webp\" alt=\"image-20231021142447574\"></p>\n<p>SAN存储，主要包括两种网络架构的SAN，一种是基于IP的SAN，一种是基于FC网络的SAN。两种架构的对比如下：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211426782.webp\" alt=\"image-20231021142641606\"></p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211427016.webp\" alt=\"image-20231021142705777\"></p>\n<h4 id=\"NAS——网络附加存储\"><a href=\"#NAS——网络附加存储\" class=\"headerlink\" title=\"NAS——网络附加存储\"></a>NAS——网络附加存储</h4><p>NAS(Network Attached Storage)：网络附加存储，是一种集中存储、支持备份、可实现跨平台的数据共享，兼容性好的存储结构。特点如下：</p>\n<ol>\n<li>支持网络文件共享协议NFS，CIFS</li>\n<li>NAS有自己的文件系统</li>\n<li>基于TCP&#x2F;IP协议</li>\n</ol>\n<ul>\n<li>NAS和CIFS协议</li>\n</ul>\n<p>NFS(Network File System)即网络文件系统，是FreeBSD支持的文件系统中的一种，适用于<strong>类Unix操作系统</strong>，允许网络中的计算机之间通过TCP&#x2F;IP共享网络资源。在NFS中，本地NFS客户端应用可以透明地读写服务器上的文件，就像访问本地文件一样。</p>\n<p>CIFS(Common Internet File System)仅适用于Windows操作系统，使客户端可以远程访问Internet计算机上的文件并提供服务，CIFS使用客户端服务器模式。</p>\n<p>对比：CIFS面向网络连接的共享协议，常用TCP协议，而NFS可使用TCP或UDP。NFS缺点之一，要求client必须安装专用软件，而CIFS集成在OS内部，无需额外添加软件。</p>\n<p>以下是DAS，NAS和SAN三种存储架构的对比：<br><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211443203.webp\" alt=\"image-20231021144339995\"></p>\n<h3 id=\"存储协议\"><a href=\"#存储协议\" class=\"headerlink\" title=\"存储协议\"></a>存储协议</h3><p>不同的架构下，有不同的存储协议。下面是DAS，NAS和SAN的存储协议示意图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211451131.webp\" alt=\"image-20231021145110855\"></p>\n<p>这些协议作了解即可。</p>\n<h3 id=\"RAID技术\"><a href=\"#RAID技术\" class=\"headerlink\" title=\"RAID技术\"></a>RAID技术</h3><p>RAID(Redundant Array of Independent Disk)即独立磁盘冗余阵列，通常简称为磁盘阵列。有软件RAID和硬件RAID两种连接方式。</p>\n<p>RAID技术有三个关键概念：镜像(Mirroring)、数据条带(Data Stripping)和数据检验(Data parity)。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211457197.webp\" alt=\"image-20231021145752935\"></p>\n<p>业界和学术界一般把RAID分成七个标准的RAID等级，等级之间不存在高低之分。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202310211459697.webp\" alt=\"image-20231021145952455\"></p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://veni222987.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"一看就明白的Go语言并发教程","date":"2023-08-24T10:57:33.000Z","path":"2023/08/24/一看就明白的Go语言并发教程/","text":"Go语言提供了强大的并发编程能力，通过Goroutines、Channels和互斥锁等机制，使得并发编程变得简单和高效。本文将使用通俗的语言和简单的案例讲述Go语言并发编程的那些事儿。 一看就明白的Go语言并发教程Go线程实现原理Go线程模型的三要素 M(machine)：一个M代表一个内核级线程，或称“工作线程”，在Go语言中，Machine通常对应于一个操作系统线程，它可以在CPU上执行指令。 P(processor)：一个P代表一个Go语言代码片段所需要的资源（或称上下文环境），它是Go调度器自己实现的一种调度单元。 G(goroutine)：一个G代表一个Go语言的代码片段，G是对Go代码段的封装。 三者之间的关系如下图： graph TD; Machine((Machine)) --> Processor((Processor)); Processor((Processor)) --> Machine((Machine)); Processor --> Goroutine1((Goroutine 1)); Processor --> Goroutine2((Goroutine 2)); Processor --> ...((...)); Processor --> Goroutinen((Goroutine n)); 简单来说，G的执行需要P和M的支持，一个M在与P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境），每一个P都会包含一个可运行的G队列，该队列中的G会被依次传递给与其上层P关联的M中，即可以使用CPU运行G中的代码。 这个模型的核心思想是将多个goroutine调度到少量的处理器上执行，避免了每个goroutine都与操作系统线程直接关联，从而提高了并发效率。 Go调度器Go语言调度器是Go运行时的一部分，负责管理和调度goroutine的执行。调度器是Go语言并发模型的核心组件之一，它实现了在多个goroutine之间进行切换，从而实现并发执行的能力。调度器的主要目标是充分利用CPU资源，实现高效的并发和并行执行。 Go语言调度器具有以下特点： 基于G-P-M模型：即上文的Goroutine，Processor，Machine模型。 调度单位是处理器P：一个处理器可以在一个操作系统线程上运行，但是多个处理器可以在同一个线程上轮流执行，以实现更高的并发。处理器还负责管理goroutine的调度、垃圾回收等任务。 抢占式调度与协作式调度：在调度策略中，调度器的调度是抢占式的：当一个goroutine执行时间超过一定阈值时，调度器可以中断它并切换到另一个goroutine。而goroutine也可以自行退出，比如遇到网络请求或者IO操作的时候，可以自愿放弃执行，这种方式叫做协作式调度。 垃圾回收：调度器还负责协调垃圾回收。当垃圾回收器运行时，调度器会暂停所有goroutine的执行，确保垃圾回收可以安全地执行。垃圾回收通常会在处理器完成当前任务后执行，以减少对应用程序的干扰。 并发与协程(Goroutine)Goroutine简介在操作系统提供的线程模型之上，Go语言通过goroutine实现了协程的概念，它是一种非常轻量级的执行单元。与传统的线程相比，goroutine的创建和销毁开销非常小，因此可以创建成千上万个goroutine，而不会消耗大量的内存和系统资源。 协程：用户态，轻量级线程，栈大小处于KB级别 线程：内核态，线程可以跑多个协程，栈大小处于MB级别 协程的调度和使用由Go语言完成，这就是Go语言的高并发的基本条件。 GO语言实现协程通过使用关键字go，可以在Go程序中启动一个goroutine，使得一个函数在一个独立的协程中并发执行。例如： 123456789101112func hello(i int) &#123; fmt.Println(&quot;hello routine&quot;, i)&#125;func main() &#123; for i := 0; i &lt; 5; i++ &#123; go func(j int) &#123; hello(j) &#125;(i) &#125; time.Sleep(time.Second)&#125; go func(j int) &#123; ... &#125;(i)：在每次循环迭代时，都会启动一个新的goroutine，执行一个匿名函数。这个匿名函数接受一个整数参数j，该参数被初始化为当前循环变量i的值。time.Sleep(time.Second)是为了能够确保所有goroutine都结束之后再结束主函数。 上述代码也可以简写成为如下形式： 123456func main() &#123; for i := 0; i &lt; 5; i++ &#123; go hello(i) &#125; time.Sleep(time.Second)&#125; 分别运行两次，结果如下： 这里可以看到五个协程的执行顺序是不一样的，这是由于操作系统的调度和Go语言调度的不确定性，Go的调度器会根据不同的策略将goroutines分配给不同的线程执行。这会导致不同的goroutines在不同的时间上交替执行，从而产生不确定的结果。 协程间通信Go语言有一句著名的标语：通过通信实现共享内存，而不是通过共享内存实现通信。下图展现了这两种思想的不同： 在传统的操作系统做法中，把数据放在共享内存中以供多个线程访问，这种思想看似简单，实际上使得并发控制变得异常困难。Go不推荐使用共享内存传递数据，而是采用channel通信传递数据，当然还保留一些传统方法的实现（比如互斥量）。 Channel通道分为有缓冲通道和无缓冲通道。使用通道的一个实例，一个协程输入数字，一个协程计算平方，主协程打印结果，代码如下： 12345678910111213141516171819202122232425262728293031func calSquare() &#123; src := make(chan int) dest := make(chan int, 3) //子协程1发送数字0-9 go func() &#123; defer close(src) for i := 0; i &lt; 10; i++ &#123; src &lt;- i //time.Sleep(time.Second) &#125; &#125;() //子协程2计算输入数字的平方 go func() &#123; defer close(dest) for i := range src &#123; dest &lt;- i * i &#125; &#125;() //主协程打印数字 for i := range dest &#123; println(time.Now().Format(&quot;15:04:05&quot;), &quot;平方数&quot;, i, &quot;通道内元素个数&quot;, len(dest)) &#125;&#125;func main() &#123; calSquare()&#125; 创建channel：使用make关键字可以创建channel，比如make(chan,int)是一个传递整形的无缓冲channel，而make(chan int, 3)则是一个缓冲区大小为3的channel。 channel输入：往channel里面输入数据需要用到左箭头&lt;-，表示将右操作数送到左操作数表示的channel中。 channel输出：需要获取channel里面的内容时，句式为for i := range dest，需要注意的是：当通道为空时，for循环会停止执行，并等待新的数据到达通道，然后继续处理数据。 我们可以看一下，上述代码在正常情况下时可以在ms级别的时间内完成运算的，如下图： 然而，当我们使得生产数据的协程每生产完一个数据后休息1秒，输出结果： 我们发现每次处理完之后，channel的大小都为0，但是都进行了下一次的平方数计算。这个例子说明了for循环把channel缓冲区里面的数据读完之后并不会立刻结束循环，而是陷入阻塞状态，等到有新的数据来到，就立刻工作。举个形象的例子，这三个协程就像是流水线上面的三个工人，子协程1效率比较低，1秒钟才生产一个配件，给到后面的协程都是立刻完成，但是后面的协程看到传送带没东西来就下班了吗？并不是，而是继续在原地等待新的零件到来，直到这条流水线关闭，即defer close(src)语句执行。 graph TD; A[子协程1] -->|src| B[子协程2]; B -->|dest| C[主协程]; 线程同步WaitGroup在 Go 语言中，sync.WaitGroup 是用于等待一组 Goroutine 完成执行的同步原语。当我们开启多个协程的时候，我们并不知道哪一个协程最先完成，如果main函数结束的时候有部分协程还未结束，则会影响最终的输出结果。在上文中我们使用了time.Sleep(time.Second)确保所有协程都完成（因为人为可以确定1s的时间足够了），然后再退出主函数。但是当我们无法确定的时候，我们就需要使用WaitGroup再确保所有的Goroutine完成之后再执行下一步工作。下面这段代码演示了五个人开始工作，直到所有人完成工作再结束的场景： 1234567891011121314151617func worker(id int, wg *sync.WaitGroup) &#123; wg.Add(1) defer wg.Done() // 减少 WaitGroup 计数器 fmt.Printf(&quot;%d开始\\n&quot;, id) time.Sleep(time.Second) // 模拟工作时间 fmt.Printf(&quot;%d结束\\n&quot;, id)&#125;func main() &#123; var wg sync.WaitGroup for i := 0; i &lt; 5; i++ &#123; go worker(i, &amp;wg) &#125; wg.Wait() // 等待所有 Goroutine 完成 fmt.Println(&quot;所有协程结束&quot;)&#125; 运行结果： 可以看到，wg.Wait()一行代码等待所有 Goroutine 完成之后才算执行完毕，进入后面的打印代码。如果将这一行注释掉，那么所有Goroutine还未结束的时候就已经打印”所有协程结束”了，这很明显不符合逻辑，读者可以修改运行试试。 Go语言同步锁Go语言中使用标准库代码包sync和sync&#x2F;atomic实现同步操作。这一部分的知识需要一部分操作系统的基础知识，建议先去了解临界区、互斥量、信号量等名词。 互斥锁Mutex互斥锁是传统并发程序对于共享资源进行访问控制的主要手段，它由标准库代码包中的synnc中的Mutex类型表示。Muext类型只有三个公开的指针方法：Lock、Unlock和TryLock。其中TryLock是测试并加锁的函数，返回值为bool，当可以上锁的时候返回true。Lock方法尝试对互斥量进行加锁，如果互斥量未被锁，那么该方法会对Lock进行加锁。如果该互斥量已被上锁，那么调用该方法的goroutine会阻塞直到获取互斥量。 下面将使用一个例子具体描述互斥锁的工作过程。 12345678910111213141516171819202122232425262728293031323334// AddWithMutex 使用互斥锁对num1进行加1操作func AddWithMutex(num1 *int, mutex *sync.Mutex, wg *sync.WaitGroup) &#123; defer wg.Done() mutex.Lock() defer mutex.Unlock() *num1++&#125;// AddWithoutMutex 不使用互斥锁对num2进行加1操作func AddWithoutMutex(num2 *int, wg *sync.WaitGroup) &#123; defer wg.Done() *num2++&#125;func AddTest() &#123; num1 := 0 num2 := 0 var mutex sync.Mutex var wg sync.WaitGroup // 10000个协程同时对num1和num2进行加1操作 for i := 0; i &lt; 10000; i++ &#123; wg.Add(2) go AddWithMutex(&amp;num1, &amp;mutex, &amp;wg) go AddWithoutMutex(&amp;num2, &amp;wg) &#125; wg.Wait() fmt.Println(&quot;num1 with lock:&quot;, num1) fmt.Println(&quot;num2 without lock:&quot;, num2)&#125;func main() &#123; AddTest()&#125; 这里分别启动了10000个协程，对两个整数进行+1操作。其中num1使用互斥锁相加，每次+1之前对变量进行上锁，结束后释放锁，而num2不使用互斥锁。来看一下运行结果： num2没有加到10000，读者可以copy上述代码多运行几次，可以发现num2每次运行的结果都不一样，但是永远不会超过10000，怎么回事呢？这是因为num2的某些线程的修改丢失了，当某个goroutine拿到内存中的num2的值（假设为100）但还未+1时，突然它的运行时间到了，根据前面抢占式的原理，它被踢出运行态，改为就绪态，但是goroutine切换的时候寄存器还会保留当前goroutine的信息（即num2&#x3D;100），当他再次切回运行态的时候，num2已经是101了，但是这个被切换出去的goroutine还是会执行100+1&#x3D;101的操作，并将其写回内存地址中，最后导致其中一次修改丢失。 举个更容易理解的例子：在某一年的春运上，有很多人在抢最后一张机票，当用户A点击了购票但是还没付款的时候，假如购票系统没有对机票上锁，用户B也点击了购票并且比用户A更早付款完毕，写回机票数量为0。当A付款完毕之后，也写回机票数量为0，这就发生了丢失修改，两个人得到了机票，但是机票数量只减少了一张，这是明显不符合逻辑的。 正确的做法是对临界区的变量操作时，需要先对其进行上锁，操作完毕之后就释放锁。这样就可以保证每一个goroutine的修改都是有效的。 读写锁RWMutex读写锁与一般互斥锁的主要区别为： 当临界区未上锁时，可以添加读锁和写锁。 当临界区已有读锁时，可以继续添加读锁，但无法添加写锁。 当临界区已有写锁时，不可以再添加任何锁。 写解锁会试图唤醒所有因为要进行读或写锁定而阻塞的goroutine，而读解锁只会在没有任何锁定的情况下试图唤醒因为要进行写锁定而被阻塞的goroutine。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 模拟读操作func read(mutex *sync.RWMutex, wg *sync.WaitGroup) &#123; wg.Add(1) defer wg.Done() if mutex.TryRLock() &#123; println(&quot;上读锁&quot;) &#125; else &#123; println(&quot;无法上读锁&quot;) mutex.RLock() &#125; //模拟读2秒 time.Sleep(2 * time.Second) println(time.Now().Format(&quot;15:04:05&quot;), &quot;读操作执行完毕&quot;) mutex.RUnlock()&#125;// 模拟写操作func write(mutex *sync.RWMutex, wg *sync.WaitGroup) &#123; wg.Add(1) if mutex.TryLock() &#123; println(&quot;上写锁&quot;) &#125; else &#123; println(&quot;无法上写锁&quot;) mutex.Lock() &#125; time.Sleep(5 * time.Second) println(time.Now().Format(&quot;15:04:05&quot;), &quot;写操作执行完毕&quot;) mutex.Unlock() wg.Done()&#125;// 读写锁测试func RWLock() &#123; println(&quot;开始时间&quot;, time.Now().Format(&quot;15:04:05&quot;)) rwMutex := sync.RWMutex&#123;&#125; wg := sync.WaitGroup&#123;&#125; //先读 go read(&amp;rwMutex, &amp;wg) //1秒后尝试读，尝试写 time.Sleep(time.Second) println(&quot;尝试读写&quot;, time.Now().Format(&quot;15:04:05&quot;)) go read(&amp;rwMutex, &amp;wg) go write(&amp;rwMutex, &amp;wg) wg.Wait()&#125; 运行观察结果： 开始后立刻进行读操作（记为0s），读操作需要耗时两秒，而1s时刻同时开始读和写操作，由于临界区处于读加锁的情况，可以继续加读锁，但是不可以添加写锁，所以读操作被阻塞。2s时刻和3s时刻分别完成两次读操作，然后唤醒了写操作，经过5s后（即8s时刻），写操作完成，整个进程结束。 条件变量CondCond简介在Go语言中，条件变量（Cond）是一种用于实现协程之间的条件同步的机制。它允许协程在满足某个条件时等待其他协程的通知。条件变量常用于实现线程池、事件循环等并发场景。条件变量是利用共享的全局变量进行同步的一种机制： 一个线程等待”条件变量的条件成立”挂起（或者说等待一个信号而睡眠） 另一个线程使”条件成立”（发送唤醒信号） 因此条件变量的使用总是和一个互斥锁结合在一起使用，这种思想就像是IPC中的睡眠与唤醒。 Cond使用场景Mutex 通常用来保护临界区和共享资源，条件变量Cond 用来协调想要访问的共享资源。有一个协程正在接收数据，其他协程必须等待这个协程接收完数据，才能读取到正确的数据（比如生产者消费者问题）。 上述情形下，如果单纯的使用 channel 或者互斥锁，只能有一个协程可以等待，并读取到数据，没办法通知其他协程也读取数据。 Go语言sync.Cond创建一个条件变量需要使用sync.NewCond的，sync.NewCond的唯一参数时sync.Locker类型的，可以是Mutex或者RWMutex，返回的结果是*sync.Cond类型的结构体，具有三个方法： Wait()：Wait方法会自动对与该条件变量相关联的那个锁进行解锁，并使它所在的goroutine阻塞。一旦收到通知，该方法所在的goroutine就会被唤醒，并且该方法会立即尝试锁定该锁。 Signal()：通知任意一个正在等待的goroutine，唤醒一个为此而阻塞的goroutine。 Broadcast()：通知所有正在等待的goroutine，唤醒所有为此而阻塞的goroutine。 需要注意的是Wait方法会释放锁，如果在调用该方法之前没有获得锁，就会报错fatal error: sync: unlock of unlocked mutex，因此Cond的使用应该是goroutine进入临界区之后，某个条件还没到位，调用Wait释放锁并睡眠，等待Signal或者Broadcast唤醒。 下面是使用Go语言sync.Cond解决生产者消费者问题的示例。 123456789101112131415161718192021222324252627func CondExample() &#123; var wg sync.WaitGroup var mu sync.Mutex cond := sync.NewCond(&amp;mu) wg.Add(2) // 生产者协程 go func() &#123; defer wg.Done() mu.Lock() defer mu.Unlock() println(time.Now().Format(&quot;04:05&quot;), &quot;开始生产&quot;) time.Sleep(2 * time.Second) // 模拟生产过程 cond.Broadcast() // 发送信号通知消费者协程 &#125;() // 消费者协程 go func() &#123; defer wg.Done() mu.Lock() defer mu.Unlock() cond.Wait() // 等待信号 fmt.Println(time.Now().Format(&quot;04:05&quot;), &quot;消费者收到信号，开始处理&quot;) &#125;() wg.Wait() fmt.Println(time.Now().Format(&quot;04:05&quot;), &quot;程序结束&quot;)&#125; 假设生产者协程需要2秒，消费者协程可以立刻进行，那么程序开始后，生产者开始生产，两秒后生产完成并broadcast，消费者收到信号，立即开始消费，程序结束。运行结果如下： 原子操作原子操作（Atomic Operation）是计算机科学中的一个重要概念，它表示一组操作在执行过程中不会被中断，不会被其他并发操作干扰，并且在执行完毕后不可再分割为更小的操作单元。例如，Go语言提供了sync/atomic包，用于执行原子操作。这些操作通常包括原子加载、原子存储、原子增加、原子交换等。 原子增&#x2F;减原子增加（Atomic Increment）： 这是一个原子操作，用于增加一个共享变量的值。无论有多少个线程或进程尝试增加这个变量的值，只有一个线程能够成功执行增加操作。原子减少（Atomic Decrement）也同理。 在Go语言的 sync/atomic 包中，AddInt32、AddInt64、AddUint32、AddUint64 等函数用于执行原子增加操作。想要执行原子减操作时，可以在函数参数中传入负数，下面是一个原子增操作的示例： 123456789101112131415161718192021func atomicAdd() &#123; var i32 int32 = 0 var ii2 int32 = 0 var wg sync.WaitGroup for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func() &#123; defer wg.Done() ii2++ &#125;() wg.Add(1) go func() &#123; defer wg.Done() atomic.AddInt32(&amp;i32, 1) &#125;() &#125; wg.Wait() println(&quot;原子加&quot;, i32) println(&quot;直接++&quot;, ii2)&#125; 高并发的情况下，10000个goroutine使用原子操作依然能够保证程序的正确性，而直接相加则会在高并发的情况下出现丢失修改，无法达到10000。 比较和交换CAS比较和交换（Compare and Swap，通常缩写为CAS）是计算机科学中的一种原子操作，用于实现并发编程中的同步和互斥。它是一种基于共享内存模型的原子操作，通常用于多线程或多进程并发环境中，以确保对共享数据的安全访问。 atomic.CompareAndSwap 是 Go 语言中用于执行比较和交换（CAS）操作的函数，它允许在多个 goroutine 之间安全地操作共享变量。该函数有三个参数： 指针参数（ptr）： 这是一个指向共享变量的指针，通常是一个内存地址。 旧值参数（old）： 这是你期望共享变量的当前值等于的值。 新值参数（new）： 如果共享变量的当前值等于旧值参数，那么它将被更新为新值参数。 例如，一个int32类型的CAS函数形式：func CompareAndSwapInt32(addr *int32, old, new int32) bool,执行该函数的时候，会先判断参数addr指向的地址值是否等于old值，如果等于old值，才会替换成为new值。如不相等，后面的替换操作就会忽略。 CAS的思想总是存在一个假设，就是该操作的值未曾改变，也就是和old值相等，一旦确认这个假设的真实性就进行替换。而使用锁则是更加谨慎，锁的思想总是假设会有并发的操作修改目标变量，并需要用锁将相关的操作保护起来。可以说，使用锁的方法比较悲观，使用CAS的方法比较乐观。所以CAS的优势是不创建互斥量的情况下完成并发操作，减少同步程序的性能消耗。劣势是目标变量被频繁修改的情况下CAS操作成功率低，甚至需要一个for循环来确保该操作完成（这就是函数返回bool类型的原因）。 下面是一个使用CAS完成并发操作的代码示例： 12345678910111213141516171819202122func CAS() &#123; var counter int32 var wg sync.WaitGroup const numGoroutines = 100000000 wg.Add(numGoroutines) for i := 0; i &lt; numGoroutines; i++ &#123; go func() &#123; defer wg.Done() // 死循环尝试递增计数器的值 for &#123; oldValue := atomic.LoadInt32(&amp;counter) newValue := oldValue + 1 // 尝试 CAS 操作 if atomic.CompareAndSwapInt32(&amp;counter, oldValue, newValue) &#123; break // CAS 成功，退出循环 &#125; &#125; &#125;() &#125; wg.Wait() println(&quot;结束时间&quot;, time.Now().Format(&quot;04:05&quot;), &quot;变量值&quot;, counter)&#125; 原子载入&#x2F;存储**原子载入（Atomic Load) ** 是一种原子操作，用于从内存中读取共享变量的当前值。原子载入操作是多线程和多协程编程中的重要概念，它确保了共享数据的安全读取，是避免竞态条件和数据不一致问题的关键工具之一。Go 语言提供了 sync/atomic 包，其中包括 LoadInt32、LoadInt64、LoadUint32、LoadUint64 等函数，用于执行原子载入操作，读取相应类型的共享变量的当前值。 原子载入的函数形式为：func LoadInt32(addr *int32) (val int32)，当执行原子加载的时候，没有任何其他操作可以对此值进行读写操作，这里的约束由语言本身和底层硬件实现。 在go语言中，访问共享变量的时候应该使用原子操作。 123456func main() &#123; var sharedValue int32 = 42 // 使用原子载入操作读取共享变量的值 value := atomic.LoadInt32(&amp;sharedValue) fmt.Println(&quot;Current value:&quot;, value)&#125; 原子存储（Atomic Store）与原子载入类似，在原子地存储某个值的过程中，任何操作都不会针对这个值进行读写。在go语言中修改共享变量应该使用原子存储。 总结还记得本文前面说的Go名言吗？通过通信实现共享内存，而不是通过共享内存实现通信，事实上，我们上面使用到的线程间通信方法都遵循了这个原则。比如在互斥锁和原子操作中，我们做的事情不过是确保一个shareValue的值在高并发中不会被错误读写，而通信只是我们实现这一目标的手段，无论是锁还是条件变量，都是通信手段而不是目标。只要确保了共享内存中的值是正确的，Go语言并发的问题也就迎刃而解了。","content":"<p>Go语言提供了强大的并发编程能力，通过Goroutines、Channels和互斥锁等机制，使得并发编程变得简单和高效。本文将使用通俗的语言和简单的案例讲述Go语言并发编程的那些事儿。<span id=\"more\"></span></p>\n<h1 id=\"一看就明白的Go语言并发教程\"><a href=\"#一看就明白的Go语言并发教程\" class=\"headerlink\" title=\"一看就明白的Go语言并发教程\"></a>一看就明白的Go语言并发教程</h1><h2 id=\"Go线程实现原理\"><a href=\"#Go线程实现原理\" class=\"headerlink\" title=\"Go线程实现原理\"></a>Go线程实现原理</h2><h3 id=\"Go线程模型的三要素\"><a href=\"#Go线程模型的三要素\" class=\"headerlink\" title=\"Go线程模型的三要素\"></a>Go线程模型的三要素</h3><ul>\n<li>M(machine)：一个M代表一个内核级线程，或称“工作线程”，在Go语言中，Machine通常对应于一个操作系统线程，它可以在CPU上执行指令。</li>\n<li>P(processor)：一个P代表一个Go语言代码片段所需要的资源（或称上下文环境），它是Go调度器自己实现的一种调度单元。</li>\n<li>G(goroutine)：一个G代表一个Go语言的代码片段，G是对Go代码段的封装。</li>\n</ul>\n<p>三者之间的关系如下图：</p>\n<pre class=\"mermaid\">graph TD;\n  Machine((Machine)) --> Processor((Processor));\n  Processor((Processor)) --> Machine((Machine));\n  Processor --> Goroutine1((Goroutine 1));\n  Processor --> Goroutine2((Goroutine 2));\n  Processor --> ...((...));\n  Processor --> Goroutinen((Goroutine n));</pre>\n\n<p>简单来说，G的执行需要P和M的支持，一个M在与P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境），每一个P都会包含一个可运行的G队列，该队列中的G会被依次传递给与其上层P关联的M中，即可以使用CPU运行G中的代码。</p>\n<p>这个模型的核心思想是将多个goroutine调度到少量的处理器上执行，避免了每个goroutine都与操作系统线程直接关联，从而提高了并发效率。</p>\n<h3 id=\"Go调度器\"><a href=\"#Go调度器\" class=\"headerlink\" title=\"Go调度器\"></a>Go调度器</h3><p>Go语言调度器是Go运行时的一部分，负责管理和调度goroutine的执行。调度器是Go语言并发模型的核心组件之一，它实现了在多个goroutine之间进行切换，从而实现并发执行的能力。调度器的主要目标是充分利用CPU资源，实现高效的并发和并行执行。</p>\n<p>Go语言调度器具有以下特点：</p>\n<ul>\n<li>基于G-P-M模型：即上文的Goroutine，Processor，Machine模型。</li>\n<li>调度单位是处理器P：一个处理器可以在一个操作系统线程上运行，但是多个处理器可以在同一个线程上轮流执行，以实现更高的并发。处理器还负责管理goroutine的调度、垃圾回收等任务。</li>\n<li>抢占式调度与协作式调度：在调度策略中，调度器的调度是抢占式的：当一个goroutine执行时间超过一定阈值时，调度器可以中断它并切换到另一个goroutine。而goroutine也可以自行退出，比如遇到网络请求或者IO操作的时候，可以自愿放弃执行，这种方式叫做协作式调度。</li>\n<li>垃圾回收：调度器还负责协调垃圾回收。当垃圾回收器运行时，调度器会暂停所有goroutine的执行，确保垃圾回收可以安全地执行。垃圾回收通常会在处理器完成当前任务后执行，以减少对应用程序的干扰。</li>\n</ul>\n<h2 id=\"并发与协程-Goroutine\"><a href=\"#并发与协程-Goroutine\" class=\"headerlink\" title=\"并发与协程(Goroutine)\"></a>并发与协程(Goroutine)</h2><h3 id=\"Goroutine简介\"><a href=\"#Goroutine简介\" class=\"headerlink\" title=\"Goroutine简介\"></a>Goroutine简介</h3><p>在操作系统提供的线程模型之上，Go语言通过goroutine实现了协程的概念，它是一种非常轻量级的执行单元。与传统的线程相比，goroutine的创建和销毁开销非常小，因此可以创建成千上万个goroutine，而不会消耗大量的内存和系统资源。</p>\n<ul>\n<li>协程：用户态，轻量级线程，栈大小处于KB级别</li>\n<li>线程：内核态，线程可以跑多个协程，栈大小处于MB级别</li>\n</ul>\n<p>协程的调度和使用由Go语言完成，这就是Go语言的高并发的基本条件。</p>\n<h3 id=\"GO语言实现协程\"><a href=\"#GO语言实现协程\" class=\"headerlink\" title=\"GO语言实现协程\"></a>GO语言实现协程</h3><p>通过使用关键字<code>go</code>，可以在Go程序中启动一个goroutine，使得一个函数在一个独立的协程中并发执行。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;hello routine&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(j <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\thello(j)</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>go func(j int) &#123; ... &#125;(i)</code>：在每次循环迭代时，都会启动一个新的goroutine，执行一个匿名函数。这个匿名函数接受一个整数参数<code>j</code>，该参数被初始化为当前循环变量<code>i</code>的值。<code>time.Sleep(time.Second)</code>是为了能够确保所有goroutine都结束之后再结束主函数。</p>\n<p>上述代码也可以简写成为如下形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> hello(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分别运行两次，结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308241954085.webp\" alt=\"image-20230824195449942\"></p>\n<p>这里可以看到五个协程的执行顺序是不一样的，这是由于操作系统的调度和Go语言调度的不确定性，Go的调度器会根据不同的策略将goroutines分配给不同的线程执行。这会导致不同的goroutines在不同的时间上交替执行，从而产生不确定的结果。</p>\n<h3 id=\"协程间通信\"><a href=\"#协程间通信\" class=\"headerlink\" title=\"协程间通信\"></a>协程间通信</h3><p>Go语言有一句著名的标语：通过通信实现共享内存，而不是通过共享内存实现通信。下图展现了这两种思想的不同：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021453324.webp\" alt=\"image-20230726101648650\"></p>\n<p>在传统的操作系统做法中，把数据放在共享内存中以供多个线程访问，这种思想看似简单，实际上使得并发控制变得异常困难。Go不推荐使用共享内存传递数据，而是采用channel通信传递数据，当然还保留一些传统方法的实现（比如互斥量）。</p>\n<h3 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h3><p>通道分为有缓冲通道和无缓冲通道。使用通道的一个实例，一个协程输入数字，一个协程计算平方，主协程打印结果，代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calSquare</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsrc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\tdest := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//子协程1发送数字0-9</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(src)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t\tsrc &lt;- i</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//time.Sleep(time.Second)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//子协程2计算输入数字的平方</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(dest)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> src &#123;</span><br><span class=\"line\">\t\t\tdest &lt;- i * i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//主协程打印数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> dest &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(time.Now().Format(<span class=\"string\">&quot;15:04:05&quot;</span>), <span class=\"string\">&quot;平方数&quot;</span>, i, <span class=\"string\">&quot;通道内元素个数&quot;</span>, <span class=\"built_in\">len</span>(dest))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcalSquare()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建channel：使用make关键字可以创建channel，比如<code>make(chan,int)</code>是一个传递整形的无缓冲channel，而<code>make(chan int, 3)</code>则是一个缓冲区大小为3的channel。</li>\n<li>channel输入：往channel里面输入数据需要用到左箭头<code>&lt;-</code>，表示将右操作数送到左操作数表示的channel中。</li>\n<li>channel输出：需要获取channel里面的内容时，句式为<code>for i := range dest</code>，需要注意的是：当通道为空时，<code>for</code>循环会停止执行，并等待新的数据到达通道，然后继续处理数据。</li>\n</ul>\n<p>我们可以看一下，上述代码在正常情况下时可以在ms级别的时间内完成运算的，如下图：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251359124.webp\" alt=\"image-20230825135945958\"></p>\n<p>然而，当我们使得生产数据的协程每生产完一个数据后休息1秒，输出结果：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251401755.webp\" alt=\"image-20230825140134605\"></p>\n<p>我们发现每次处理完之后，channel的大小都为0，但是都进行了下一次的平方数计算。这个例子说明了for循环把channel缓冲区里面的数据读完之后并不会立刻结束循环，而是陷入阻塞状态，等到有新的数据来到，就立刻工作。举个形象的例子，这三个协程就像是流水线上面的三个工人，子协程1效率比较低，1秒钟才生产一个配件，给到后面的协程都是立刻完成，但是后面的协程看到传送带没东西来就下班了吗？并不是，而是继续在原地等待新的零件到来，直到这条流水线关闭，即<code>defer close(src)</code>语句执行。</p>\n<pre class=\"mermaid\">graph TD;\n    A[子协程1] -->|src| B[子协程2];\n    B -->|dest| C[主协程];</pre>\n\n<h3 id=\"线程同步WaitGroup\"><a href=\"#线程同步WaitGroup\" class=\"headerlink\" title=\"线程同步WaitGroup\"></a>线程同步WaitGroup</h3><p>在 Go 语言中，<code>sync.WaitGroup</code> 是用于等待一组 Goroutine 完成执行的同步原语。当我们开启多个协程的时候，我们并不知道哪一个协程最先完成，如果main函数结束的时候有部分协程还未结束，则会影响最终的输出结果。在上文中我们使用了<code>time.Sleep(time.Second)</code>确保所有协程都完成（因为人为可以确定1s的时间足够了），然后再退出主函数。但是当我们无法确定的时候，我们就需要使用WaitGroup再确保所有的Goroutine完成之后再执行下一步工作。下面这段代码演示了五个人开始工作，直到所有人完成工作再结束的场景：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker</span><span class=\"params\">(id <span class=\"type\">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done() <span class=\"comment\">// 减少 WaitGroup 计数器</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d开始\\n&quot;</span>, id)</span><br><span class=\"line\">\ttime.Sleep(time.Second) <span class=\"comment\">// 模拟工作时间</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d结束\\n&quot;</span>, id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> worker(i, &amp;wg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait() <span class=\"comment\">// 等待所有 Goroutine 完成</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;所有协程结束&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308251637828.webp\" alt=\"image-20230825163731709\"></p>\n<p>可以看到，<code>wg.Wait()</code>一行代码等待所有 Goroutine 完成之后才算执行完毕，进入后面的打印代码。如果将这一行注释掉，那么所有Goroutine还未结束的时候就已经打印”所有协程结束”了，这很明显不符合逻辑，读者可以修改运行试试。</p>\n<h2 id=\"Go语言同步\"><a href=\"#Go语言同步\" class=\"headerlink\" title=\"Go语言同步\"></a>Go语言同步</h2><h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>Go语言中使用标准库代码包sync和sync&#x2F;atomic实现同步操作。这一部分的知识需要一部分操作系统的基础知识，建议先去了解临界区、互斥量、信号量等名词。</p>\n<h4 id=\"互斥锁Mutex\"><a href=\"#互斥锁Mutex\" class=\"headerlink\" title=\"互斥锁Mutex\"></a>互斥锁Mutex</h4><p>互斥锁是传统并发程序对于共享资源进行访问控制的主要手段，它由标准库代码包中的synnc中的Mutex类型表示。Muext类型只有三个公开的指针方法：Lock、Unlock和TryLock。其中TryLock是测试并加锁的函数，返回值为bool，当可以上锁的时候返回true。Lock方法尝试对互斥量进行加锁，如果互斥量未被锁，那么该方法会对Lock进行加锁。如果该互斥量已被上锁，那么调用该方法的goroutine会阻塞直到获取互斥量。</p>\n<p>下面将使用一个例子具体描述互斥锁的工作过程。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddWithMutex 使用互斥锁对num1进行加1操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddWithMutex</span><span class=\"params\">(num1 *<span class=\"type\">int</span>, mutex *sync.Mutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\tmutex.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mutex.Unlock()</span><br><span class=\"line\">\t*num1++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddWithoutMutex 不使用互斥锁对num2进行加1操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddWithoutMutex</span><span class=\"params\">(num2 *<span class=\"type\">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t*num2++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddTest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tnum1 := <span class=\"number\">0</span></span><br><span class=\"line\">\tnum2 := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mutex sync.Mutex</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\t<span class=\"comment\">// 10000个协程同时对num1和num2进行加1操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> AddWithMutex(&amp;num1, &amp;mutex, &amp;wg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> AddWithoutMutex(&amp;num2, &amp;wg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;num1 with lock:&quot;</span>, num1)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;num2 without lock:&quot;</span>, num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tAddTest()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里分别启动了10000个协程，对两个整数进行+1操作。其中num1使用互斥锁相加，每次+1之前对变量进行上锁，结束后释放锁，而num2不使用互斥锁。来看一下运行结果：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308282326129.webp\" alt=\"image-20230828232559958\"></p>\n<p>num2没有加到10000，读者可以copy上述代码多运行几次，可以发现num2每次运行的结果都不一样，但是永远不会超过10000，怎么回事呢？这是因为num2的某些线程的修改丢失了，当某个goroutine拿到内存中的num2的值（假设为100）但还未+1时，突然它的运行时间到了，根据前面抢占式的原理，它被踢出运行态，改为就绪态，但是goroutine切换的时候寄存器还会保留当前goroutine的信息（即num2&#x3D;100），当他再次切回运行态的时候，num2已经是101了，但是这个被切换出去的goroutine还是会执行100+1&#x3D;101的操作，并将其写回内存地址中，最后导致其中一次修改丢失。</p>\n<p>举个更容易理解的例子：在某一年的春运上，有很多人在抢最后一张机票，当用户A点击了购票但是还没付款的时候，假如购票系统没有对机票上锁，用户B也点击了购票并且比用户A更早付款完毕，写回机票数量为0。当A付款完毕之后，也写回机票数量为0，这就发生了丢失修改，两个人得到了机票，但是机票数量只减少了一张，这是明显不符合逻辑的。</p>\n<p>正确的做法是对临界区的变量操作时，需要先对其进行上锁，操作完毕之后就释放锁。这样就可以保证每一个goroutine的修改都是有效的。</p>\n<h4 id=\"读写锁RWMutex\"><a href=\"#读写锁RWMutex\" class=\"headerlink\" title=\"读写锁RWMutex\"></a>读写锁RWMutex</h4><p>读写锁与一般互斥锁的主要区别为：</p>\n<ul>\n<li>当临界区未上锁时，可以添加读锁和写锁。</li>\n<li>当临界区已有读锁时，可以继续添加读锁，但无法添加写锁。</li>\n<li>当临界区已有写锁时，不可以再添加任何锁。</li>\n</ul>\n<p>写解锁会试图唤醒所有因为要进行读或写锁定而阻塞的goroutine，而读解锁只会在没有任何锁定的情况下试图唤醒因为要进行写锁定而被阻塞的goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模拟读操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">read</span><span class=\"params\">(mutex *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mutex.TryRLock() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;上读锁&quot;</span>)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;无法上读锁&quot;</span>)</span><br><span class=\"line\">\t\tmutex.RLock()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//模拟读2秒</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">2</span> * time.Second)</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(time.Now().Format(<span class=\"string\">&quot;15:04:05&quot;</span>), <span class=\"string\">&quot;读操作执行完毕&quot;</span>)</span><br><span class=\"line\">\tmutex.RUnlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟写操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">write</span><span class=\"params\">(mutex *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mutex.TryLock() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;上写锁&quot;</span>)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;无法上写锁&quot;</span>)</span><br><span class=\"line\">\t\tmutex.Lock()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(time.Now().Format(<span class=\"string\">&quot;15:04:05&quot;</span>), <span class=\"string\">&quot;写操作执行完毕&quot;</span>)</span><br><span class=\"line\">\tmutex.Unlock()</span><br><span class=\"line\">\twg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读写锁测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RWLock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;开始时间&quot;</span>, time.Now().Format(<span class=\"string\">&quot;15:04:05&quot;</span>))</span><br><span class=\"line\">\trwMutex := sync.RWMutex&#123;&#125;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//先读</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> read(&amp;rwMutex, &amp;wg)</span><br><span class=\"line\">\t<span class=\"comment\">//1秒后尝试读，尝试写</span></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;尝试读写&quot;</span>, time.Now().Format(<span class=\"string\">&quot;15:04:05&quot;</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> read(&amp;rwMutex, &amp;wg)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> write(&amp;rwMutex, &amp;wg)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行观察结果：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308302051036.webp\" alt=\"image-20230830205143846\"></p>\n<p>开始后立刻进行读操作（记为0s），读操作需要耗时两秒，而1s时刻同时开始读和写操作，由于临界区处于读加锁的情况，可以继续加读锁，但是不可以添加写锁，所以读操作被阻塞。2s时刻和3s时刻分别完成两次读操作，然后唤醒了写操作，经过5s后（即8s时刻），写操作完成，整个进程结束。</p>\n<h3 id=\"条件变量Cond\"><a href=\"#条件变量Cond\" class=\"headerlink\" title=\"条件变量Cond\"></a>条件变量Cond</h3><h4 id=\"Cond简介\"><a href=\"#Cond简介\" class=\"headerlink\" title=\"Cond简介\"></a>Cond简介</h4><p>在Go语言中，条件变量（<code>Cond</code>）是一种用于实现协程之间的条件同步的机制。它允许协程在满足某个条件时等待其他协程的通知。条件变量常用于实现线程池、事件循环等并发场景。条件变量是利用共享的全局变量进行同步的一种机制：</p>\n<ul>\n<li>一个线程等待”条件变量的条件成立”挂起（或者说等待一个信号而睡眠）</li>\n<li>另一个线程使”条件成立”（发送唤醒信号）</li>\n</ul>\n<p>因此条件变量的使用总是和一个互斥锁结合在一起使用，这种思想就像是IPC中的睡眠与唤醒。</p>\n<h4 id=\"Cond使用场景\"><a href=\"#Cond使用场景\" class=\"headerlink\" title=\"Cond使用场景\"></a>Cond使用场景</h4><p>Mutex 通常用来保护临界区和共享资源，条件变量Cond 用来协调想要访问的共享资源。有一个协程正在接收数据，其他协程必须等待这个协程接收完数据，才能读取到正确的数据（比如生产者消费者问题）。</p>\n<p>上述情形下，如果单纯的使用 channel 或者互斥锁，只能有一个协程可以等待，并读取到数据，没办法通知其他协程也读取数据。</p>\n<h4 id=\"Go语言sync-Cond\"><a href=\"#Go语言sync-Cond\" class=\"headerlink\" title=\"Go语言sync.Cond\"></a>Go语言sync.Cond</h4><p>创建一个条件变量需要使用sync.NewCond的，sync.NewCond的唯一参数时sync.Locker类型的，可以是Mutex或者RWMutex，返回的结果是*sync.Cond类型的结构体，具有三个方法：</p>\n<ul>\n<li>Wait()：Wait方法会自动对与该条件变量相关联的那个锁进行解锁，并使它所在的goroutine阻塞。一旦收到通知，该方法所在的goroutine就会被唤醒，并且该方法会立即尝试锁定该锁。</li>\n<li>Signal()：通知任意一个正在等待的goroutine，唤醒一个为此而阻塞的goroutine。</li>\n<li>Broadcast()：通知所有正在等待的goroutine，唤醒所有为此而阻塞的goroutine。</li>\n</ul>\n<p>需要注意的是Wait方法会释放锁，如果在调用该方法之前没有获得锁，就会报错<code>fatal error: sync: unlock of unlocked mutex</code>，因此Cond的使用应该是goroutine进入临界区之后，某个条件还没到位，调用Wait释放锁并睡眠，等待Signal或者Broadcast唤醒。</p>\n<p>下面是使用Go语言sync.Cond解决生产者消费者问题的示例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CondExample</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\">\tcond := sync.NewCond(&amp;mu)</span><br><span class=\"line\"></span><br><span class=\"line\">\twg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 生产者协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\tmu.Lock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(time.Now().Format(<span class=\"string\">&quot;04:05&quot;</span>), <span class=\"string\">&quot;开始生产&quot;</span>)</span><br><span class=\"line\">\t\ttime.Sleep(<span class=\"number\">2</span> * time.Second) <span class=\"comment\">// 模拟生产过程</span></span><br><span class=\"line\">\t\tcond.Broadcast()            <span class=\"comment\">// 发送信号通知消费者协程</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 消费者协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\tmu.Lock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\t\tcond.Wait() <span class=\"comment\">// 等待信号</span></span><br><span class=\"line\">\t\tfmt.Println(time.Now().Format(<span class=\"string\">&quot;04:05&quot;</span>), <span class=\"string\">&quot;消费者收到信号，开始处理&quot;</span>)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Println(time.Now().Format(<span class=\"string\">&quot;04:05&quot;</span>), <span class=\"string\">&quot;程序结束&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设生产者协程需要2秒，消费者协程可以立刻进行，那么程序开始后，生产者开始生产，两秒后生产完成并broadcast，消费者收到信号，立即开始消费，程序结束。运行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202309032029555.webp\" alt=\"image-20230903202854380\"></p>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p>原子操作（Atomic Operation）是计算机科学中的一个重要概念，它表示一组操作在执行过程中不会被中断，不会被其他并发操作干扰，并且在执行完毕后不可再分割为更小的操作单元。例如，Go语言提供了<code>sync/atomic</code>包，用于执行原子操作。这些操作通常包括原子加载、原子存储、原子增加、原子交换等。</p>\n<h4 id=\"原子增-减\"><a href=\"#原子增-减\" class=\"headerlink\" title=\"原子增&#x2F;减\"></a>原子增&#x2F;减</h4><p><strong>原子增加（Atomic Increment）：</strong> 这是一个原子操作，用于增加一个共享变量的值。无论有多少个线程或进程尝试增加这个变量的值，只有一个线程能够成功执行增加操作。<strong>原子减少（Atomic Decrement）</strong>也同理。</p>\n<p>在Go语言的 <code>sync/atomic</code> 包中，<code>AddInt32</code>、<code>AddInt64</code>、<code>AddUint32</code>、<code>AddUint64</code> 等函数用于执行原子增加操作。想要执行原子减操作时，可以在函数参数中传入负数，下面是一个原子增操作的示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">atomicAdd</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i32 <span class=\"type\">int32</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> ii2 <span class=\"type\">int32</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tii2++</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tatomic.AddInt32(&amp;i32, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;原子加&quot;</span>, i32)</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;直接++&quot;</span>, ii2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>高并发的情况下，10000个goroutine使用原子操作依然能够保证程序的正确性，而直接相加则会在高并发的情况下出现丢失修改，无法达到10000。</p>\n<h4 id=\"比较和交换CAS\"><a href=\"#比较和交换CAS\" class=\"headerlink\" title=\"比较和交换CAS\"></a>比较和交换CAS</h4><p>比较和交换（Compare and Swap，通常缩写为CAS）是计算机科学中的一种原子操作，用于实现并发编程中的同步和互斥。它是一种基于共享内存模型的原子操作，通常用于多线程或多进程并发环境中，以确保对共享数据的安全访问。</p>\n<p><code>atomic.CompareAndSwap</code> 是 Go 语言中用于执行比较和交换（CAS）操作的函数，它允许在多个 goroutine 之间安全地操作共享变量。该函数有三个参数：</p>\n<ul>\n<li><strong>指针参数（ptr）：</strong> 这是一个指向共享变量的指针，通常是一个内存地址。</li>\n<li><strong>旧值参数（old）：</strong> 这是你期望共享变量的当前值等于的值。</li>\n<li><strong>新值参数（new）：</strong> 如果共享变量的当前值等于旧值参数，那么它将被更新为新值参数。</li>\n</ul>\n<p>例如，一个int32类型的CAS函数形式：<code>func CompareAndSwapInt32(addr *int32, old, new int32) bool</code>,执行该函数的时候，会先判断参数addr指向的地址值是否等于old值，如果等于old值，才会替换成为new值。如不相等，后面的替换操作就会忽略。</p>\n<p>CAS的思想总是存在一个假设，就是该操作的值未曾改变，也就是和old值相等，一旦确认这个假设的真实性就进行替换。而使用锁则是更加谨慎，锁的思想总是假设会有并发的操作修改目标变量，并需要用锁将相关的操作保护起来。可以说，使用锁的方法比较悲观，使用CAS的方法比较乐观。所以CAS的优势是不创建互斥量的情况下完成并发操作，减少同步程序的性能消耗。劣势是目标变量被频繁修改的情况下CAS操作成功率低，甚至需要一个for循环来确保该操作完成（这就是函数返回bool类型的原因）。</p>\n<p>下面是一个使用CAS完成并发操作的代码示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CAS</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> counter <span class=\"type\">int32</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">    <span class=\"keyword\">const</span> numGoroutines = <span class=\"number\">100000000</span></span><br><span class=\"line\">    wg.Add(numGoroutines)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            <span class=\"comment\">// 死循环尝试递增计数器的值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">                oldValue := atomic.LoadInt32(&amp;counter)</span><br><span class=\"line\">                newValue := oldValue + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\">// 尝试 CAS 操作</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;counter, oldValue, newValue) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span> <span class=\"comment\">// CAS 成功，退出循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(<span class=\"string\">&quot;结束时间&quot;</span>, time.Now().Format(<span class=\"string\">&quot;04:05&quot;</span>), <span class=\"string\">&quot;变量值&quot;</span>, counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原子载入-存储\"><a href=\"#原子载入-存储\" class=\"headerlink\" title=\"原子载入&#x2F;存储\"></a>原子载入&#x2F;存储</h4><p>**原子载入（Atomic Load) ** 是一种原子操作，用于从内存中读取共享变量的当前值。原子载入操作是多线程和多协程编程中的重要概念，它确保了共享数据的安全读取，是避免竞态条件和数据不一致问题的关键工具之一。Go 语言提供了 <code>sync/atomic</code> 包，其中包括 <code>LoadInt32</code>、<code>LoadInt64</code>、<code>LoadUint32</code>、<code>LoadUint64</code> 等函数，用于执行原子载入操作，读取相应类型的共享变量的当前值。</p>\n<p>原子载入的函数形式为：<code>func LoadInt32(addr *int32) (val int32)</code>，当执行原子加载的时候，没有任何其他操作可以对此值进行读写操作，这里的约束由语言本身和底层硬件实现。</p>\n<p>在go语言中，访问共享变量的时候应该使用原子操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> sharedValue <span class=\"type\">int32</span> = <span class=\"number\">42</span></span><br><span class=\"line\">\t<span class=\"comment\">// 使用原子载入操作读取共享变量的值</span></span><br><span class=\"line\">\tvalue := atomic.LoadInt32(&amp;sharedValue)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Current value:&quot;</span>, value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>原子存储（Atomic Store）</strong>与原子载入类似，在原子地存储某个值的过程中，任何操作都不会针对这个值进行读写。在go语言中修改共享变量应该使用原子存储。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>还记得本文前面说的Go名言吗？<code>通过通信实现共享内存，而不是通过共享内存实现通信</code>，事实上，我们上面使用到的线程间通信方法都遵循了这个原则。比如在互斥锁和原子操作中，我们做的事情不过是确保一个shareValue的值在高并发中不会被错误读写，而通信只是我们实现这一目标的手段，无论是锁还是条件变量，都是通信手段而不是目标。只要确保了共享内存中的值是正确的，Go语言并发的问题也就迎刃而解了。</p>\n","categories":[{"name":"go","slug":"go","permalink":"https://veni222987.github.io/categories/go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://veni222987.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"go","slug":"go","permalink":"https://veni222987.github.io/tags/go/"}]},{"title":"GORM入门教程与最佳实践","date":"2023-08-10T08:50:54.000Z","path":"2023/08/10/GORM入门教程与最佳实践/","text":"GORM是一种Go语言的ORM（对象关系映射）库，用于简化数据库的操作。它提供了一种简单、易于使用的方式来进行数据库的增删改查操作，支持多种数据库，如MySQL、PostgreSQL、SQLite等。下面，我们将从理论和实践的角度学习GORM框架。 GORM入门教程与最佳实践简介对象关系映射（ORM）先来讲讲什么是ORM。ORM（对象关系映射）是一种编程技术，用于将关系型数据库中的数据映射到面向对象编程语言中的对象模型。它能够自动地在数据库表和对象之间建立映射关系，并提供一种简化数据库操作的方式。 相信有过Java开发经验的人都不会对MyBatis感到陌生，GORM的思想与MyBatis相似，都是为了简化数据库的操作，将数据库的一个关系映射到业务中的一个类或者结构体（尽管MyBatis并不认为是一个ORM框架，因为其保留了使用xml编辑数据库操作语言）。 ORM的核心思想是通过将数据库表的行数据映射为对象的属性，将数据库表的列映射为对象的字段，从而实现数据库和对象之间的无缝转换。ORM框架负责处理数据库的增删改查操作，以及数据库表和对象之间的映射关系，开发者只需要操作对象，而无需直接与底层数据库打交道 GORM的优点GORM框架有许多优点，这些优点减少了开发的工作量的同时还提高了系统的效率。 数据库模型定义：使用结构体来定义数据库表结构，通过结构体的字段和标签来映射数据库表的列。 CRUD操作：提供了丰富的方法来进行数据库的增删改查操作，如Create、Read、Update和Delete等。 查询构建器：支持链式调用和条件语句来构建复杂的查询，包括条件查询、排序、分页等。 关联查询：支持通过预加载、延迟加载等方式进行关联查询，方便处理数据库表之间的关系。 事务支持：提供了事务的开启、提交和回滚等操作，保证原子性和数据一致性。 数据迁移：支持数据库结构的自动迁移，可以根据模型定义自动生成数据库表结构。 钩子函数：支持在数据库操作前后触发的钩子函数，方便进行数据验证、处理等操作。 软删除：支持逻辑删除，可以通过标记字段来实现数据的软删除和恢复。 GORM框架下载1go get -u gorm.io/gorm 使用上述指令可以获取到最新的gorm框架。 数据库的连接要想使用GORM框架，首先需要连接自己的数据库。此处略去如何安装数据库，并且以MySQL为例，建立连接并进行数据库操作。 建立连接的代码如下： 12345678910111213username := &quot;your_username&quot; //用户名password := &quot;your_password&quot; //密码host := &quot;127.0.0.1&quot; //数据库地址，可以是Ip或者域名port := 3306 //数据库端口Dbname := &quot;test&quot; //数据库名//MYSQL dsn格式： &#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&quot;, username, password, host, port, Dbname)//gorm.Open()用于建立连接，打开数据库db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123; panic(&quot;连接数据库失败, error=&quot; + err.Error())&#125; dsn是数据源名称(Data Source Name)，在GORM框架中，MySQL的dsn格式为：&#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4，?后面的是可选参数，可以设置字符集，时区等等。 db是一个gorm.DB类型的对象，建立连接之后，后面对于数据库的所有操作都可以由这个对象实现。如果没有报错，那么证明数据库连接成功。 GORM实现CRUD这里再科普一遍CRUD的英文单词吧。CRUD 是一个常用的缩写词，代表了常见的数据库操作，包括创建（Create）、读取（Read）、更新（Update）和删除（Delete）。下面我们将分别讲讲如何使用GORM框架实现CRUD，同时也给出官方文档地址gorm.io&#x2F;docs&#x2F;。 插入数据使用GORM框架之后，插入数据变得非常简单，实现代码如下： 123456789101112131415161718192021222324type User struct &#123; Id int `gorm:&quot;id&quot;` Name string `gorm:&quot;name&quot;` Age int `gorm:&quot;age&quot;`&#125;func (*User) TableName() string &#123; return &quot;user&quot;&#125;func main()&#123; //--------------------- //此处省略连接数据库的代码 //--------------------- res := db.Create(User&#123;1, &quot;Veni&quot;, 20&#125;) if res.Error != nil &#123; panic(res.Error) &#125; //插入指定字段，使用Select选择插入的字段，使用Omit选择忽略的字段，Omit字段使用数据库默认值 db.Select(&quot;id&quot;).Omit(&quot;name&quot;,&quot;age&quot;).Create(User&#123;1,&quot;Veni&quot;,20&#125;) &#125; 上面我们讲述了ORM的定义，一个对象对应一个关系，在定义结构体的时候，gorm:&quot;id&quot;的作用是将结构的变量与数据库关系表中的字段建立映射。并且func (*User) TableName() string是一个结构体函数的写法，其return的值就是想要建立映射关系的表名。如果没有这个结构体函数，那么表名就是蛇形复数，比如User对应users表，UserName对应user_names表。这里我建了一张user表，注释掉结构体函数报错如下： Create函数自动创建了一个INSERT语句用于插入信息，并且将结构体中的数据传入数据库。 读取数据读取数据可以比较灵活，比如使用.分的控制语句查找符合要求的数据。比如： 123456789101112131415161718192021func main()&#123; //--------------------- //此处省略连接数据库的代码 //--------------------- //声明对象用以接收查询结果 u := User&#123;&#125; res := db.Where(&quot;name=?&quot;, &quot;Veni&quot;).Find(&amp;u) if res.Error != nil &#123; panic(res.Error) &#125; fmt.Printf(&quot;%+v&quot;, u) //声明切片用于保存多个查询结果 uu := []User&#123;&#125; res = db.Find(&amp;uu) if res.Error != nil &#123; panic(res.Error) &#125; fmt.Printf(&quot;%+v&quot;, uu)&#125; 指定查找范围和接收对象GORM中用于指定接收对象的关键字有First，Last，Take，Find。此类关键字一般放在查询语句的最后，用于指定查询的范围和接收的对象。记得加取址符号&amp;，这样才能修改u的内容。 12345678910//找到符合条件并且按照主键排序的第一个userres := db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;u)//找到按照age字段升序排列的第一个user——Firstres := db.Order(&quot;age asc&quot;).First(&amp;u)//找到最后一个——Lastres := db.Order(&quot;age asc&quot;).Last(&amp;u)//随便找到一个——Takeres := db.Order(&quot;age asc&quot;).Take(&amp;u)//找到所有满足条件的——Findres := db.Order(&quot;age asc&quot;).Find(&amp;uu) 使用First查询不到数据的时候，会返回ErrRecoedNotFound，而使用Find查询不到的时候返回空数组。 选择语句使用Where方法可以实现条件查询，即数据库的选择操作。 1res := db.Where(&quot;name = ?&quot;,&quot;Veni&quot;).Find(&amp;uu) 需要注意的是，在gorm框架使用Where需要放在Find函数前面。这一点不同于数据库查询语言DQL中的写法：Where语句写在最后。 投影语句gorm框架中的Select方法，对应的是DQL中的Select语句。 1res := db.Select(&quot;name,age&quot;).Where(&quot;age &gt; ?&quot;, 0).Find(&amp;u) 执行查询语句：[&#123;Id:0 Name:Veni Age:20&#125; &#123;Id:0 Name:Moss Age:75&#125;]，可以看到，由于我没有选择Id字段，查找结果里面的所有对象的Id均为0（因为int的空置为0，string的空值为空串）。但是，作为一个ORM框架，每一个字段都应该对应着一个对象的一个属性，即便没有Select，该属性还是会占用内存，也就是说存储一个10和一个0是差别不大的，所以Select语句使用相对较少。当然在分组语句和聚合函数中还是会使用的。 分组语句分组语句的实现方法： 1db.Group(&quot;age&quot;).Find(&amp;result) 需要注意的是：不在分组函数中的字段必须在聚合函数中。比如一张工人薪资表，按照部门求平均工资，则group的字段为部门，那么薪资必须要使用average（或者sum等聚集函数）。这是因为，分组语句会改变行数，因此不同字段需要使用聚集函数同时改变行数才能维持表的行列形态。 聚合函数聚合函数包括sum, average,count,max,min等，使用聚合函数的方法类似，都是在Select或者Having语句中嵌套使用。 12345678type temp struct &#123; Count int Name string Age int&#125;tempArr := []temp&#123;&#125;//读取数据res := db.Table(&quot;user&quot;).Select(&quot;count(*) as `count`,name,age&quot;).Group(&quot;id,name,age&quot;).Having(&quot;count(*) &gt;?&quot;, 0).Find(&amp;tempArr) 需要注意的是，使用聚合函数建立的查找表的字段一般都不是model对应的字段，因此需要定义一个新的结构体去接收和存储查询结果。字段名遵循蛇形命名方法，同时使用Table方法指定表。 having语句分组或聚集之后的查询表需要进行选择操作时，不能使用where语句，需要使用having语句，比如： 1res := db.Table(&quot;user&quot;).Select(&quot;count(*) as `count`,name,age&quot;).Group(&quot;id,name,age&quot;).Having(&quot;count(*) &gt;?&quot;, 0).Find(&amp;tempArr) 更新数据给定数据更新：1234//使用model指定操作的表名db.Model(&amp;User&#123;&#125;).Where(&quot;name=?&quot;, &quot;Veni&quot;).Update(&quot;age&quot;, 20)//使用table指定操作的表名db.Table(&quot;user&quot;).Where(&quot;name=?&quot;, &quot;Veni&quot;).Update(&quot;age&quot;, 20) 这里推荐使用Table指定表名，因为使用Table比较接近于数据库查询语言DML的写法。 SQL表达式更新：1db.Table(&quot;user&quot;).Where(&quot;name = ?&quot;, &quot;Moss&quot;).Update(&quot;age&quot;, gorm.Expr(&quot;age * 2 + ?&quot;, 1)) 这里使用了gorm.Expr()方法，这个方法是表达式更新的写法，表达式为age=age*2+1，这个写法比较灵活，可以指定多个参数或不指定参数。 删除数据物理删除123456789//直接删除，后面接的都是主键的值db.Delete(&amp;User&#123;&#125;,1)//删除主键为1的记录db.Delete(&amp;User&#123;&#125;,[]int&#123;1,2&#125;)//删除主键为1和2的记录//Where条件语句删除db.Where(&quot;name = ?&quot;,&quot;Moss&quot;).Delete(&amp;User&#123;&#125;)//简洁的条件删除db.Delete(&amp;User&#123;&#125;,&quot;Name = ?&quot;,&quot;Moss&quot;) 软删除gorm提供了goem.DeleteAt用于帮助用户实现软删。定义方法： 123456type User struct&#123; Id int Name string age int Deleted gorm.DeleteAt&#125; 拥有软删除能力的Model调用Delete的时候，记录不会从数据库中真正删除，但是gorm会将DeleteAt设置为当前时间，并且无法正常查询。使用Unscoped可以查询到软删的数据。 GORM的事务数据库的事务是指一组数据库操作（如插入、更新、删除等）被视为一个不可分割的工作单元，并且要么全部成功执行，要么全部回滚（撤销）。事务可以确保数据库的一致性和完整性，同时提供了并发控制和故障恢复的机制。GORM提供了Begin、Commit、Rollback等方法用于事务。 123456789tx:=db.Begin() //开始事务//在事务中执行db操作需要全部换成txres=tx.Create(&amp;User&#123;Name:&quot;name&quot;&#125;)if res.Error!=nil&#123; //遇到错误时回滚 tx.Rollback() return&#125;tx.Commit()///提交事务 Transaction方法自动提交事务： 123456789101112if err = db.Transaction(func(tx *gorm.DB) error &#123; if err = tx.Create(&amp;User&#123;1, &quot;M&quot;, 18&#125;).Error; err != nil &#123; return err &#125; if err = tx.Create(&amp;User&#123;1, &quot;Name&quot;, 11&#125;).Error; err != nil &#123; tx.Rollback() return err &#125; return nil&#125;); err != nil &#123; return&#125; 推荐使用Transaction方法提交事务，这样可以防止忘记提交的情况。 GORM HookGorm提供了CRUD的Hook（钩子函数）能力，在创建，查询，更新，删除等操作前后自动调用的函数。 1234567func (u *User) BeforeCreate (tx *gorm.DB)(err error)&#123; if u.Age&lt;0&#123; return errors.New(&quot;Age cannot be negative&quot;) &#125; return&#125;//同理也可以创建AfterCreate的Hook。 GORM生态GORM框架有着极其丰富的生态，以下是一些常见的GORM框架的工具及其仓库地址。在熟练使用GORM原生框架之后，可以尝试使用下面的工具提高开发效率或者系统性能。 工具名 地址 GORM 代码生成工具 https://github.com/go-gorm/gen GORM 分片库方案 https://github.com/go-gorm/sharding GORM 手动索引 https://github.com/go-gorm/hints GORM 乐观锁 https://github.com/go-gorm/optimisticlock GORM 读写分离 https://github.com/go-gorm/dbresolver GORM OpenTelemetry 扩展 https://github.com/go-gorm/opentelemetry","content":"<p>GORM是一种Go语言的ORM（对象关系映射）库，用于简化数据库的操作。它提供了一种简单、易于使用的方式来进行数据库的增删改查操作，支持多种数据库，如MySQL、PostgreSQL、SQLite等。下面，我们将从理论和实践的角度学习GORM框架。<span id=\"more\"></span></p>\n<h1 id=\"GORM入门教程与最佳实践\"><a href=\"#GORM入门教程与最佳实践\" class=\"headerlink\" title=\"GORM入门教程与最佳实践\"></a>GORM入门教程与最佳实践</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"对象关系映射（ORM）\"><a href=\"#对象关系映射（ORM）\" class=\"headerlink\" title=\"对象关系映射（ORM）\"></a>对象关系映射（ORM）</h3><p>先来讲讲什么是ORM。ORM（对象关系映射）是一种编程技术，用于将关系型数据库中的数据映射到面向对象编程语言中的对象模型。它能够自动地在数据库表和对象之间建立映射关系，并提供一种简化数据库操作的方式。</p>\n<p>相信有过Java开发经验的人都不会对MyBatis感到陌生，GORM的思想与MyBatis相似，都是为了简化数据库的操作，<strong>将数据库的一个关系映射到业务中的一个类或者结构体</strong>（尽管MyBatis并不认为是一个ORM框架，因为其保留了使用xml编辑数据库操作语言）。</p>\n<p>ORM的核心思想是通过将数据库表的行数据映射为对象的属性，将数据库表的列映射为对象的字段，从而实现数据库和对象之间的无缝转换。ORM框架负责处理数据库的增删改查操作，以及数据库表和对象之间的映射关系，开发者只需要操作对象，而无需直接与底层数据库打交道</p>\n<h3 id=\"GORM的优点\"><a href=\"#GORM的优点\" class=\"headerlink\" title=\"GORM的优点\"></a>GORM的优点</h3><p>GORM框架有许多优点，这些优点减少了开发的工作量的同时还提高了系统的效率。</p>\n<ul>\n<li>数据库模型定义：使用结构体来定义数据库表结构，通过结构体的字段和标签来映射数据库表的列。</li>\n<li>CRUD操作：提供了丰富的方法来进行数据库的增删改查操作，如Create、Read、Update和Delete等。</li>\n<li>查询构建器：支持链式调用和条件语句来构建复杂的查询，包括条件查询、排序、分页等。</li>\n<li>关联查询：支持通过预加载、延迟加载等方式进行关联查询，方便处理数据库表之间的关系。</li>\n<li>事务支持：提供了事务的开启、提交和回滚等操作，保证原子性和数据一致性。</li>\n<li>数据迁移：支持数据库结构的自动迁移，可以根据模型定义自动生成数据库表结构。</li>\n<li>钩子函数：支持在数据库操作前后触发的钩子函数，方便进行数据验证、处理等操作。</li>\n<li>软删除：支持逻辑删除，可以通过标记字段来实现数据的软删除和恢复。</li>\n</ul>\n<h3 id=\"GORM框架下载\"><a href=\"#GORM框架下载\" class=\"headerlink\" title=\"GORM框架下载\"></a>GORM框架下载</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u gorm.io/gorm</span><br></pre></td></tr></table></figure>\n\n<p>使用上述指令可以获取到最新的gorm框架。</p>\n<h2 id=\"数据库的连接\"><a href=\"#数据库的连接\" class=\"headerlink\" title=\"数据库的连接\"></a>数据库的连接</h2><p>要想使用GORM框架，首先需要连接自己的数据库。此处略去如何安装数据库，并且以MySQL为例，建立连接并进行数据库操作。</p>\n<p>建立连接的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username := <span class=\"string\">&quot;your_username&quot;</span>    <span class=\"comment\">//用户名</span></span><br><span class=\"line\">password := <span class=\"string\">&quot;your_password&quot;</span> <span class=\"comment\">//密码</span></span><br><span class=\"line\">host := <span class=\"string\">&quot;127.0.0.1&quot;</span>   <span class=\"comment\">//数据库地址，可以是Ip或者域名</span></span><br><span class=\"line\">port := <span class=\"number\">3306</span>          <span class=\"comment\">//数据库端口</span></span><br><span class=\"line\">Dbname := <span class=\"string\">&quot;test&quot;</span>      <span class=\"comment\">//数据库名</span></span><br><span class=\"line\"><span class=\"comment\">//MYSQL dsn格式： &#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4</span></span><br><span class=\"line\">dsn := fmt.Sprintf(<span class=\"string\">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&quot;</span>, username, password, host, port, Dbname)</span><br><span class=\"line\"><span class=\"comment\">//gorm.Open()用于建立连接，打开数据库</span></span><br><span class=\"line\">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;连接数据库失败, error=&quot;</span> + err.Error())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>dsn是数据源名称(Data Source Name)，在GORM框架中，MySQL的dsn格式为：<code>&#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8mb4</code>，?后面的是可选参数，可以设置字符集，时区等等。</p>\n<p>db是一个gorm.DB类型的对象，建立连接之后，后面对于数据库的所有操作都可以由这个对象实现。如果没有报错，那么证明数据库连接成功。</p>\n<h2 id=\"GORM实现CRUD\"><a href=\"#GORM实现CRUD\" class=\"headerlink\" title=\"GORM实现CRUD\"></a>GORM实现CRUD</h2><p>这里再科普一遍CRUD的英文单词吧。CRUD 是一个常用的缩写词，代表了常见的数据库操作，包括创建（Create）、读取（Read）、更新（Update）和删除（Delete）。下面我们将分别讲讲如何使用GORM框架实现CRUD，同时也给出官方文档地址<a href=\"https://gorm.io/docs/\">gorm.io&#x2F;docs&#x2F;</a>。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>使用GORM框架之后，插入数据变得非常简单，实现代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tId   <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;id&quot;`</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span> <span class=\"string\">`gorm:&quot;name&quot;`</span></span><br><span class=\"line\">\tAge  <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;age&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*User)</span></span> TableName() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;user&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//---------------------</span></span><br><span class=\"line\">    <span class=\"comment\">//此处省略连接数据库的代码</span></span><br><span class=\"line\">    <span class=\"comment\">//---------------------</span></span><br><span class=\"line\">    res := db.Create(User&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;Veni&quot;</span>, <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.Error != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(res.Error)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//插入指定字段，使用Select选择插入的字段，使用Omit选择忽略的字段，Omit字段使用数据库默认值</span></span><br><span class=\"line\">    db.Select(<span class=\"string\">&quot;id&quot;</span>).Omit(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;age&quot;</span>).Create(User&#123;<span class=\"number\">1</span>,<span class=\"string\">&quot;Veni&quot;</span>,<span class=\"number\">20</span>&#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面我们讲述了ORM的定义，一个对象对应一个关系，在定义结构体的时候，<code>gorm:&quot;id&quot;</code>的作用是将结构的变量与数据库关系表中的字段建立映射。并且<code>func (*User) TableName() string</code>是一个结构体函数的写法，其<code>return</code>的值就是想要建立映射关系的表名。如果没有这个结构体函数，那么表名就是蛇形复数，比如User对应users表，UserName对应user_names表。这里我建了一张user表，注释掉结构体函数报错如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308102015271.webp\" alt=\"image-20230810201529078\"></p>\n<p>Create函数自动创建了一个INSERT语句用于插入信息，并且将结构体中的数据传入数据库。</p>\n<h3 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h3><p>读取数据可以比较灵活，比如使用.分的控制语句查找符合要求的数据。比如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//---------------------</span></span><br><span class=\"line\">    <span class=\"comment\">//此处省略连接数据库的代码</span></span><br><span class=\"line\">    <span class=\"comment\">//---------------------</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//声明对象用以接收查询结果</span></span><br><span class=\"line\">\tu := User&#123;&#125;</span><br><span class=\"line\">\tres := db.Where(<span class=\"string\">&quot;name=?&quot;</span>, <span class=\"string\">&quot;Veni&quot;</span>).Find(&amp;u)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.Error != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(res.Error)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, u)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//声明切片用于保存多个查询结果</span></span><br><span class=\"line\">    uu := []User&#123;&#125;</span><br><span class=\"line\">\tres = db.Find(&amp;uu)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.Error != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(res.Error)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, uu)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指定查找范围和接收对象\"><a href=\"#指定查找范围和接收对象\" class=\"headerlink\" title=\"指定查找范围和接收对象\"></a>指定查找范围和接收对象</h4><p>GORM中用于指定接收对象的关键字有First，Last，Take，Find。此类关键字一般放在查询语句的最后，用于指定查询的范围和接收的对象。记得加取址符号&amp;，这样才能修改u的内容。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到符合条件并且按照主键排序的第一个user</span></span><br><span class=\"line\">res := db.Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;u)</span><br><span class=\"line\"><span class=\"comment\">//找到按照age字段升序排列的第一个user——First</span></span><br><span class=\"line\">res := db.Order(<span class=\"string\">&quot;age asc&quot;</span>).First(&amp;u)</span><br><span class=\"line\"><span class=\"comment\">//找到最后一个——Last</span></span><br><span class=\"line\">res := db.Order(<span class=\"string\">&quot;age asc&quot;</span>).Last(&amp;u)</span><br><span class=\"line\"><span class=\"comment\">//随便找到一个——Take</span></span><br><span class=\"line\">res := db.Order(<span class=\"string\">&quot;age asc&quot;</span>).Take(&amp;u)</span><br><span class=\"line\"><span class=\"comment\">//找到所有满足条件的——Find</span></span><br><span class=\"line\">res := db.Order(<span class=\"string\">&quot;age asc&quot;</span>).Find(&amp;uu)</span><br></pre></td></tr></table></figure>\n\n<p>使用First查询不到数据的时候，会返回ErrRecoedNotFound，而使用Find查询不到的时候返回空数组。</p>\n<h4 id=\"选择语句\"><a href=\"#选择语句\" class=\"headerlink\" title=\"选择语句\"></a>选择语句</h4><p>使用Where方法可以实现条件查询，即数据库的选择操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res := db.Where(<span class=\"string\">&quot;name = ?&quot;</span>,<span class=\"string\">&quot;Veni&quot;</span>).Find(&amp;uu)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在gorm框架使用Where需要放在Find函数前面。这一点不同于数据库查询语言DQL中的写法：Where语句写在最后。</p>\n<h4 id=\"投影语句\"><a href=\"#投影语句\" class=\"headerlink\" title=\"投影语句\"></a>投影语句</h4><p>gorm框架中的Select方法，对应的是DQL中的Select语句。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res := db.Select(<span class=\"string\">&quot;name,age&quot;</span>).Where(<span class=\"string\">&quot;age &gt; ?&quot;</span>, <span class=\"number\">0</span>).Find(&amp;u)</span><br></pre></td></tr></table></figure>\n\n<p>执行查询语句：<code>[&#123;Id:0 Name:Veni Age:20&#125; &#123;Id:0 Name:Moss Age:75&#125;]</code>，可以看到，由于我没有选择Id字段，查找结果里面的所有对象的Id均为0（因为int的空置为0，string的空值为空串）。但是，作为一个ORM框架，每一个字段都应该对应着一个对象的一个属性，即便没有Select，该属性还是会占用内存，也就是说存储一个10和一个0是差别不大的，所以Select语句使用相对较少。当然在分组语句和聚合函数中还是会使用的。</p>\n<h4 id=\"分组语句\"><a href=\"#分组语句\" class=\"headerlink\" title=\"分组语句\"></a>分组语句</h4><p>分组语句的实现方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.Group(<span class=\"string\">&quot;age&quot;</span>).Find(&amp;result)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：不在分组函数中的字段必须在聚合函数中。比如一张工人薪资表，按照部门求平均工资，则group的字段为部门，那么薪资必须要使用average（或者sum等聚集函数）。这是因为，分组语句会改变行数，因此不同字段需要使用聚集函数同时改变行数才能维持表的行列形态。</p>\n<h4 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h4><p>聚合函数包括sum, average,count,max,min等，使用聚合函数的方法类似，都是在Select或者Having语句中嵌套使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> temp <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Count <span class=\"type\">int</span></span><br><span class=\"line\">    Name  <span class=\"type\">string</span></span><br><span class=\"line\">    Age   <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tempArr := []temp&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//读取数据</span></span><br><span class=\"line\">res := db.Table(<span class=\"string\">&quot;user&quot;</span>).Select(<span class=\"string\">&quot;count(*) as `count`,name,age&quot;</span>).Group(<span class=\"string\">&quot;id,name,age&quot;</span>).Having(<span class=\"string\">&quot;count(*) &gt;?&quot;</span>, <span class=\"number\">0</span>).Find(&amp;tempArr)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用聚合函数建立的查找表的字段一般都不是model对应的字段，因此需要定义一个新的结构体去接收和存储查询结果。字段名遵循蛇形命名方法，同时使用Table方法指定表。</p>\n<h4 id=\"having语句\"><a href=\"#having语句\" class=\"headerlink\" title=\"having语句\"></a>having语句</h4><p>分组或聚集之后的查询表需要进行选择操作时，不能使用where语句，需要使用having语句，比如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res := db.Table(<span class=\"string\">&quot;user&quot;</span>).Select(<span class=\"string\">&quot;count(*) as `count`,name,age&quot;</span>).Group(<span class=\"string\">&quot;id,name,age&quot;</span>).Having(<span class=\"string\">&quot;count(*) &gt;?&quot;</span>, <span class=\"number\">0</span>).Find(&amp;tempArr)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h3><h4 id=\"给定数据更新：\"><a href=\"#给定数据更新：\" class=\"headerlink\" title=\"给定数据更新：\"></a>给定数据更新：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用model指定操作的表名</span></span><br><span class=\"line\">db.Model(&amp;User&#123;&#125;).Where(<span class=\"string\">&quot;name=?&quot;</span>, <span class=\"string\">&quot;Veni&quot;</span>).Update(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"comment\">//使用table指定操作的表名</span></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;user&quot;</span>).Where(<span class=\"string\">&quot;name=?&quot;</span>, <span class=\"string\">&quot;Veni&quot;</span>).Update(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里推荐使用Table指定表名，因为使用Table比较接近于数据库查询语言DML的写法。</p>\n<h4 id=\"SQL表达式更新：\"><a href=\"#SQL表达式更新：\" class=\"headerlink\" title=\"SQL表达式更新：\"></a>SQL表达式更新：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.Table(<span class=\"string\">&quot;user&quot;</span>).Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;Moss&quot;</span>).Update(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age * 2 + ?&quot;</span>, <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>这里使用了<code>gorm.Expr()</code>方法，这个方法是表达式更新的写法，表达式为<code>age=age*2+1</code>，这个写法比较灵活，可以指定多个参数或不指定参数。</p>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><h4 id=\"物理删除\"><a href=\"#物理删除\" class=\"headerlink\" title=\"物理删除\"></a>物理删除</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//直接删除，后面接的都是主键的值</span></span><br><span class=\"line\">db.Delete(&amp;User&#123;&#125;,<span class=\"number\">1</span>)<span class=\"comment\">//删除主键为1的记录</span></span><br><span class=\"line\">db.Delete(&amp;User&#123;&#125;,[]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;)<span class=\"comment\">//删除主键为1和2的记录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Where条件语句删除</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ?&quot;</span>,<span class=\"string\">&quot;Moss&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//简洁的条件删除</span></span><br><span class=\"line\">db.Delete(&amp;User&#123;&#125;,<span class=\"string\">&quot;Name = ?&quot;</span>,<span class=\"string\">&quot;Moss&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"软删除\"><a href=\"#软删除\" class=\"headerlink\" title=\"软删除\"></a>软删除</h4><p>gorm提供了goem.DeleteAt用于帮助用户实现软删。定义方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Id      <span class=\"type\">int</span></span><br><span class=\"line\">    Name    <span class=\"type\">string</span></span><br><span class=\"line\">    age     <span class=\"type\">int</span></span><br><span class=\"line\">    Deleted gorm.DeleteAt</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拥有软删除能力的Model调用Delete的时候，记录不会从数据库中真正删除，但是gorm会将DeleteAt设置为当前时间，并且无法正常查询。使用Unscoped可以查询到软删的数据。</p>\n<h2 id=\"GORM的事务\"><a href=\"#GORM的事务\" class=\"headerlink\" title=\"GORM的事务\"></a>GORM的事务</h2><p>数据库的事务是指一组数据库操作（如插入、更新、删除等）被视为一个不可分割的工作单元，并且要么全部成功执行，要么全部回滚（撤销）。事务可以确保数据库的一致性和完整性，同时提供了并发控制和故障恢复的机制。GORM提供了Begin、Commit、Rollback等方法用于事务。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tx:=db.Begin() <span class=\"comment\">//开始事务</span></span><br><span class=\"line\"><span class=\"comment\">//在事务中执行db操作需要全部换成tx</span></span><br><span class=\"line\">res=tx.Create(&amp;User&#123;Name:<span class=\"string\">&quot;name&quot;</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> res.Error!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//遇到错误时回滚</span></span><br><span class=\"line\">    tx.Rollback()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tx.Commit()<span class=\"comment\">///提交事务</span></span><br></pre></td></tr></table></figure>\n\n<p>Transaction方法自动提交事务：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err = db.Transaction(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(tx *gorm.DB)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = tx.Create(&amp;User&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;M&quot;</span>, <span class=\"number\">18</span>&#125;).Error; err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = tx.Create(&amp;User&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;Name&quot;</span>, <span class=\"number\">11</span>&#125;).Error; err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        tx.Rollback()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐使用Transaction方法提交事务，这样可以防止忘记提交的情况。</p>\n<h2 id=\"GORM-Hook\"><a href=\"#GORM-Hook\" class=\"headerlink\" title=\"GORM Hook\"></a>GORM Hook</h2><p>Gorm提供了CRUD的Hook（钩子函数）能力，在创建，查询，更新，删除等操作前后自动调用的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(u *User)</span></span> BeforeCreate (tx *gorm.DB)(err <span class=\"type\">error</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> u.Age&lt;<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;Age cannot be negative&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//同理也可以创建AfterCreate的Hook。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GORM生态\"><a href=\"#GORM生态\" class=\"headerlink\" title=\"GORM生态\"></a>GORM生态</h2><p>GORM框架有着极其丰富的生态，以下是一些常见的GORM框架的工具及其仓库地址。在熟练使用GORM原生框架之后，可以尝试使用下面的工具提高开发效率或者系统性能。</p>\n<table>\n<thead>\n<tr>\n<th>工具名</th>\n<th>地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GORM 代码生成工具</td>\n<td><a href=\"https://github.com/go-gorm/gen\">https://github.com/go-gorm/gen</a></td>\n</tr>\n<tr>\n<td>GORM 分片库方案</td>\n<td><a href=\"https://github.com/go-gorm/sharding\">https://github.com/go-gorm/sharding</a></td>\n</tr>\n<tr>\n<td>GORM 手动索引</td>\n<td><a href=\"https://github.com/go-gorm/hints\">https://github.com/go-gorm/hints</a></td>\n</tr>\n<tr>\n<td>GORM 乐观锁</td>\n<td><a href=\"https://github.com/go-gorm/optimisticlock\">https://github.com/go-gorm/optimisticlock</a></td>\n</tr>\n<tr>\n<td>GORM 读写分离</td>\n<td><a href=\"https://github.com/go-gorm/dbresolver\">https://github.com/go-gorm/dbresolver</a></td>\n</tr>\n<tr>\n<td>GORM OpenTelemetry 扩展</td>\n<td><a href=\"https://github.com/go-gorm/opentelemetry\">https://github.com/go-gorm/opentelemetry</a></td>\n</tr>\n</tbody></table>\n","categories":[{"name":"go","slug":"go","permalink":"https://veni222987.github.io/categories/go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://veni222987.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"grom","slug":"grom","permalink":"https://veni222987.github.io/tags/grom/"}]},{"title":"【再学网络】http原理与实践","date":"2023-08-07T06:27:51.000Z","path":"2023/08/07/【再学网络】http原理与实践/","text":"HTTP（Hypertext Transfer Protocol），又叫超文本传输协议，是一种用于在客户端和服务器之间传输超文本的协议。它是互联网上应用最广泛的一种协议，用于在 Web 浏览器和 Web 服务器之间进行通信。 【再学网络】HTTP原理与实践为什么需要协议HTTP是位于OSI参考模型和TCP&#x2F;IP模型中的应用层的一个工作协议，使用HTTP协议是用户和开发者的双重需要。 从用户的角度看，需要HTTP的原因有： 访问和浏览网页：HTTP 协议是 Web 浏览器和 Web 服务器之间进行通信的基础。 下载和上传文件：HTTP 协议也被用于文件传输，用户可以通过 HTTP 请求下载文件，或通过 HTTP 请求上传文件。 与 Web 应用交互：现代的 Web 应用通常是基于 HTTP 协议构建的，用户可以通过 HTTP 请求与 Web 应用进行交互。 从开发者的角度看，原因有： 通信协议的标准化：HTTP 协议定义了客户端和服务器之间通信的规范和约定，使得开发者能够按照统一的标准进行开发。 简单和易于开发：HTTP 协议采用简单的文本格式，易于理解和调试。 跨平台和互操作性：HTTP 协议是一种跨平台的协议，不依赖于具体的操作系统和开发技术。 可扩展和定制化：HTTP 协议支持自定义的头部字段，开发者可以利用这一特性传递额外的信息和参数。 HTTP协议原理HTTP协议内容 一个HTTP请求包含请求行、请求头和请求体，如上图中的第一段报文，请求行中的方法名为POST，请求体为邀请小姐姐看电影的话。而一个http响应包含状态行、响应头和响应体三部分，比如上文中的第二段报文。 HTTP请求流程一个HTTP请求是以客户端的应用层的封装开始，到服务端的应用层的解封装结束。一个HTTP响应则相反，从服务端的封装开始，客户端的解封装结束。一个HTTP请求需要经过中间件，路由和编码解码等层级才能达到服务器。举个简单的例子，一个请求的请求路由是&#x2F;hello，那么在route层就会对其做一次检验，只有正确的路由才会放行；假设middleware层有一个登录验证的中间件，那么这一层就会把携带不正确身份信息的请求过滤掉。 中间件HTTP 中间件提供了一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Auth 中间件验证用户的身份，如果用户未通过身份验证，中间件将会把用户导向登录页面，反之，当用户通过了身份验证，中间件将会通过此请求并接着往下执行。当然，除了身份验证之外，中间件也可以被用来运行各式各样的任务，如：CORS 中间件负责替所有即将离开程序的响应加入适当的标头；而日志中间件则可以记录所有传入应用程序的请求。 路由当服务器收到 HTTP 请求时，它会根据请求的 URL 和方法进行路由匹配。如果请求的 URL 和方法与某个路由规则匹配，服务器将调用与之关联的处理程序来处理请求，并生成相应的响应。例如，在一个 Web 应用中，可以定义一个路由规则将 GET 请求的 “&#x2F;users” 路径与一个处理函数关联起来。当用户在浏览器中访问 “&#x2F;users” 路径时，服务器将调用该处理函数来处理请求，并返回用户列表。 路由一般会组织成树的结构，也组织成映射结构。一般来说，树状结构可以加快路由匹配速度。 路由参数和请求参数的区别 路由参数是指实际的请求路由随着不同的参数值而改变的路由，比如不同的用户登录某个博客网站，博客网站为他们分配了不同的路由，比如/blog/123,/blog/456，匹配模式为：/blog/:id。 HTTP实战下面我们将以Go语言为例，使用Gin框架，将HTTP应用在实战项目中。 什么是curl首先来了解一个工具——curl。curl全称是Client URL，是一个命令行工具和库，用于发送HTTP、HTTPS，FTP等协议的请求，并且获取响应数据。 curl的原理类似于一个命令行式的浏览器，虽然不具备渲染和展现网页的能力，但是具备调试API，下载文件，网络监测等能力。 curl的简单使用 -X用于指定发送请求时使用的方法 -H用于指定发送请求的请求头 -d或者--data用于指定的数据，可以是文件，JSON，表单等等。 其他发送请求的工具除了使用CLI的形式发送HTTP请求，还可以使用GUI工具发送。这里推荐使用Postman和APIFox。Postman比较成熟稳定，APIFox偶尔有bug，但具有Postman的功能并且还有写文档和Mock的能力，可以自行取舍。 请求方式GET请求GET请求用于从服务器获取数据。下面以一个简单的获取账户密码的例子来说明GET请求的实现： 首先定义一个实体User，它仅有两个字段： 1234type User struct &#123; Name string Password string&#125; 然后我们测试通过GET传递用户名为参数获取密码： 123456func GetUserInfo(c *gin.Context) &#123; name := c.Query(&quot;Name&quot;) //此处仅作演示，实际开发中不会把密码返回，而是把密码加密存到数据库中 user := models.User&#123;name, &quot;123456&quot;&#125; c.JSON(200, user)&#125; 测试一下： POST请求POST请求用于向服务端推送数据，一般而言，数据写在请求体body中。下面是一个简单的处理POST请求的demo： 123456789101112func SetUserInfo(c *gin.Context) &#123; data, err := io.ReadAll(c.Request.Body) if err != nil &#123; c.JSON(500, err) return &#125; println(&quot;Request body:&quot;, string(data)) //将数据进行处理 c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;OK&quot;, &#125;)&#125; 这次使用APIFox代替curl发送请求，这里有几个需要注意的点： 请求类型要改成POST请求，相当于指定-X POST。 请求的信息要写在Body中，不要写在Params中。这一步相当于-d &lt;json数据&gt;。 后端接收到请求并且打印，输出结果如下： PUT请求以下是一个PUT请求示例： 1234567891011121314151617181920func updateHandler(c *gin.Context) &#123; // 从 URL 参数中获取 id id := c.Query(&quot;id&quot;) // 解析请求中的 JSON 数据 var requestData map[string]interface&#123;&#125; if err := c.ShouldBindJSON(&amp;requestData); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; // 在这里进行更新操作，例如更新数据库记录等 // 返回成功响应 c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;Resource updated successfully&quot;, &quot;id&quot;: id, &quot;data&quot;: requestData, &#125;)&#125; APIFox发送请求以及响应，设置请求同时要设置Params和Body。 DELETE请求下面是一个DELETE请求示例： 123456789101112func deleteHandler(c *gin.Context) &#123; // 从 URL 参数中获取 id id := c.Query(&quot;id&quot;) // 在这里进行删除操作，例如从数据库中删除记录等 // 返回成功响应 c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;Resource deleted successfully&quot;, &quot;id&quot;: id, &#125;)&#125; APIFox请求和响应结果： 比较当涉及HTTP请求时，GET、POST、PUT和DELETE是最常见的几种方法，用于在客户端和服务器之间传递数据和执行操作。以下是它们之间的比较： 维度 GET请求 POST请求 PUT请求 DELETE请求 用途 获取数据，如网页、图片等 提交数据，如表单数据 更新资源，替换操作 删除资源 幂等性 幂等操作，不改变状态 非幂等操作，可能改变状态 幂等操作，相同更新 幂等操作，不改变状态 数据传递 通过URL查询参数传递 通过请求体传递数据 通过请求体传递完整资源 通常通过URL标识资源 安全性 相对较安全，不改变状态 相对较安全，可能改变状态 相对较安全，需要授权 相对较安全，需要授权 总结不同的HTTP请求方法在执行操作和传递数据时有不同的语义和适用场景。选择正确的方法取决于业务要执行的操作以及与服务器交互的目的。如希望深入了解HTTP请求方法的内部工作原理和细节，可以研究相关的HTTP协议规范，如RFC 7231。","content":"<p>HTTP（Hypertext Transfer Protocol），又叫超文本传输协议，是一种用于在客户端和服务器之间传输超文本的协议。它是互联网上应用最广泛的一种协议，用于在 Web 浏览器和 Web 服务器之间进行通信。<span id=\"more\"></span></p>\n<h1 id=\"【再学网络】HTTP原理与实践\"><a href=\"#【再学网络】HTTP原理与实践\" class=\"headerlink\" title=\"【再学网络】HTTP原理与实践\"></a>【再学网络】HTTP原理与实践</h1><h2 id=\"为什么需要协议\"><a href=\"#为什么需要协议\" class=\"headerlink\" title=\"为什么需要协议\"></a>为什么需要协议</h2><p>HTTP是位于OSI参考模型和TCP&#x2F;IP模型中的应用层的一个工作协议，使用HTTP协议是用户和开发者的双重需要。</p>\n<p>从用户的角度看，需要HTTP的原因有：</p>\n<ul>\n<li>访问和浏览网页：HTTP 协议是 Web 浏览器和 Web 服务器之间进行通信的基础。</li>\n<li>下载和上传文件：HTTP 协议也被用于文件传输，用户可以通过 HTTP 请求下载文件，或通过 HTTP 请求上传文件。</li>\n<li>与 Web 应用交互：现代的 Web 应用通常是基于 HTTP 协议构建的，用户可以通过 HTTP 请求与 Web 应用进行交互。</li>\n</ul>\n<p>从开发者的角度看，原因有：</p>\n<ul>\n<li>通信协议的标准化：HTTP 协议定义了客户端和服务器之间通信的规范和约定，使得开发者能够按照统一的标准进行开发。</li>\n<li>简单和易于开发：HTTP 协议采用简单的文本格式，易于理解和调试。</li>\n<li>跨平台和互操作性：HTTP 协议是一种跨平台的协议，不依赖于具体的操作系统和开发技术。</li>\n<li>可扩展和定制化：HTTP 协议支持自定义的头部字段，开发者可以利用这一特性传递额外的信息和参数。</li>\n</ul>\n<h2 id=\"HTTP协议原理\"><a href=\"#HTTP协议原理\" class=\"headerlink\" title=\"HTTP协议原理\"></a>HTTP协议原理</h2><h3 id=\"HTTP协议内容\"><a href=\"#HTTP协议内容\" class=\"headerlink\" title=\"HTTP协议内容\"></a>HTTP协议内容</h3><p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071512719.webp\" alt=\"image-20230807151153388\"></p>\n<p>一个HTTP请求包含请求行、请求头和请求体，如上图中的第一段报文，请求行中的方法名为POST，请求体为邀请小姐姐看电影的话。而一个http响应包含状态行、响应头和响应体三部分，比如上文中的第二段报文。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071529415.webp\" alt=\"image-20230807152944203\"></p>\n<h3 id=\"HTTP请求流程\"><a href=\"#HTTP请求流程\" class=\"headerlink\" title=\"HTTP请求流程\"></a>HTTP请求流程</h3><p>一个HTTP请求是以客户端的应用层的封装开始，到服务端的应用层的解封装结束。一个HTTP响应则相反，从服务端的封装开始，客户端的解封装结束。一个HTTP请求需要经过中间件，路由和编码解码等层级才能达到服务器。举个简单的例子，一个请求的请求路由是&#x2F;hello，那么在route层就会对其做一次检验，只有正确的路由才会放行；假设middleware层有一个登录验证的中间件，那么这一层就会把携带不正确身份信息的请求过滤掉。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071539103.webp\" alt=\" HTTP层次结构图 \"></p>\n<h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><p>HTTP 中间件提供了一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Auth 中间件验证用户的身份，如果用户未通过身份验证，中间件将会把用户导向登录页面，反之，当用户通过了身份验证，中间件将会通过此请求并接着往下执行。当然，除了身份验证之外，中间件也可以被用来运行各式各样的任务，如：CORS 中间件负责替所有即将离开程序的响应加入适当的标头；而日志中间件则可以记录所有传入应用程序的请求。</p>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>当服务器收到 HTTP 请求时，它会根据请求的 URL 和方法进行路由匹配。如果请求的 URL 和方法与某个路由规则匹配，服务器将调用与之关联的处理程序来处理请求，并生成相应的响应。例如，在一个 Web 应用中，可以定义一个路由规则将 GET 请求的 “&#x2F;users” 路径与一个处理函数关联起来。当用户在浏览器中访问 “&#x2F;users” 路径时，服务器将调用该处理函数来处理请求，并返回用户列表。</p>\n<p>路由一般会组织成树的结构，也组织成映射结构。一般来说，树状结构可以加快路由匹配速度。</p>\n<h4 id=\"路由参数和请求参数的区别\"><a href=\"#路由参数和请求参数的区别\" class=\"headerlink\" title=\"路由参数和请求参数的区别\"></a>路由参数和请求参数的区别</h4><ul>\n<li>路由参数是指实际的请求路由随着不同的参数值而改变的路由，比如不同的用户登录某个博客网站，博客网站为他们分配了不同的路由，比如<code>/blog/123,/blog/456</code>，匹配模式为：<code>/blog/:id</code>。</li>\n</ul>\n<h2 id=\"HTTP实战\"><a href=\"#HTTP实战\" class=\"headerlink\" title=\"HTTP实战\"></a>HTTP实战</h2><p>下面我们将以Go语言为例，使用Gin框架，将HTTP应用在实战项目中。</p>\n<h3 id=\"什么是curl\"><a href=\"#什么是curl\" class=\"headerlink\" title=\"什么是curl\"></a>什么是curl</h3><p>首先来了解一个工具——curl。curl全称是Client URL，是一个命令行工具和库，用于发送HTTP、HTTPS，FTP等协议的请求，并且获取响应数据。</p>\n<p>curl的原理类似于一个命令行式的浏览器，虽然不具备渲染和展现网页的能力，但是具备调试API，下载文件，网络监测等能力。</p>\n<h4 id=\"curl的简单使用\"><a href=\"#curl的简单使用\" class=\"headerlink\" title=\"curl的简单使用\"></a>curl的简单使用</h4><ul>\n<li><code>-X</code>用于指定发送请求时使用的方法</li>\n<li><code>-H</code>用于指定发送请求的请求头</li>\n<li><code>-d</code>或者<code>--data</code>用于指定的数据，可以是文件，JSON，表单等等。</li>\n</ul>\n<h4 id=\"其他发送请求的工具\"><a href=\"#其他发送请求的工具\" class=\"headerlink\" title=\"其他发送请求的工具\"></a>其他发送请求的工具</h4><p>除了使用CLI的形式发送HTTP请求，还可以使用GUI工具发送。这里推荐使用Postman和APIFox。Postman比较成熟稳定，APIFox偶尔有bug，但具有Postman的功能并且还有写文档和Mock的能力，可以自行取舍。</p>\n<h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a>请求方式</h3><h4 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h4><p>GET请求用于从服务器获取数据。下面以一个简单的获取账户密码的例子来说明GET请求的实现：</p>\n<p>首先定义一个实体User，它仅有两个字段：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName     <span class=\"type\">string</span></span><br><span class=\"line\">\tPassword <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们测试通过GET传递用户名为参数获取密码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetUserInfo</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\tname := c.Query(<span class=\"string\">&quot;Name&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//此处仅作演示，实际开发中不会把密码返回，而是把密码加密存到数据库中</span></span><br><span class=\"line\">\tuser := models.User&#123;name, <span class=\"string\">&quot;123456&quot;</span>&#125;</span><br><span class=\"line\">\tc.JSON(<span class=\"number\">200</span>, user)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试一下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308081136485.webp\" alt=\"image-20230808113646280\"></p>\n<h4 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h4><p>POST请求用于向服务端推送数据，一般而言，数据写在请求体body中。下面是一个简单的处理POST请求的demo：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetUserInfo</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\tdata, err := io.ReadAll(c.Request.Body)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.JSON(<span class=\"number\">500</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Request body:&quot;</span>, <span class=\"type\">string</span>(data))</span><br><span class=\"line\">    <span class=\"comment\">//将数据进行处理</span></span><br><span class=\"line\">\tc.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次使用APIFox代替curl发送请求，这里有几个需要注意的点：</p>\n<ul>\n<li>请求类型要改成POST请求，相当于指定<code>-X POST</code>。</li>\n<li>请求的信息要写在Body中，不要写在Params中。这一步相当于<code>-d &lt;json数据&gt;</code>。</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191710697.webp\" alt=\"image-20230819171001584\"></p>\n<p>后端接收到请求并且打印，输出结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/image-20230819170901529.webp\" alt=\"image-20230819170459017\"></p>\n<h4 id=\"PUT请求\"><a href=\"#PUT请求\" class=\"headerlink\" title=\"PUT请求\"></a>PUT请求</h4><p>以下是一个PUT请求示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateHandler</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 从 URL 参数中获取 id</span></span><br><span class=\"line\">\tid := c.Query(<span class=\"string\">&quot;id&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 解析请求中的 JSON 数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> requestData <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := c.ShouldBindJSON(&amp;requestData); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.JSON(http.StatusBadRequest, gin.H&#123;<span class=\"string\">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在这里进行更新操作，例如更新数据库记录等</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 返回成功响应</span></span><br><span class=\"line\">\tc.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;Resource updated successfully&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;id&quot;</span>:      id,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;data&quot;</span>:    requestData,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>APIFox发送请求以及响应，设置请求同时要设置Params和Body。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191745903.webp\" alt=\"image-20230819174558791\"></p>\n<h4 id=\"DELETE请求\"><a href=\"#DELETE请求\" class=\"headerlink\" title=\"DELETE请求\"></a>DELETE请求</h4><p>下面是一个DELETE请求示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deleteHandler</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 从 URL 参数中获取 id</span></span><br><span class=\"line\">\tid := c.Query(<span class=\"string\">&quot;id&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在这里进行删除操作，例如从数据库中删除记录等</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 返回成功响应</span></span><br><span class=\"line\">\tc.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;Resource deleted successfully&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;id&quot;</span>:      id,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>APIFox请求和响应结果：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308191742816.webp\" alt=\"image-20230819174237717\"></p>\n<h4 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h4><p>当涉及HTTP请求时，GET、POST、PUT和DELETE是最常见的几种方法，用于在客户端和服务器之间传递数据和执行操作。以下是它们之间的比较：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>GET请求</th>\n<th>POST请求</th>\n<th>PUT请求</th>\n<th>DELETE请求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用途</td>\n<td>获取数据，如网页、图片等</td>\n<td>提交数据，如表单数据</td>\n<td>更新资源，替换操作</td>\n<td>删除资源</td>\n</tr>\n<tr>\n<td>幂等性</td>\n<td>幂等操作，不改变状态</td>\n<td>非幂等操作，可能改变状态</td>\n<td>幂等操作，相同更新</td>\n<td>幂等操作，不改变状态</td>\n</tr>\n<tr>\n<td>数据传递</td>\n<td>通过URL查询参数传递</td>\n<td>通过请求体传递数据</td>\n<td>通过请求体传递完整资源</td>\n<td>通常通过URL标识资源</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>相对较安全，不改变状态</td>\n<td>相对较安全，可能改变状态</td>\n<td>相对较安全，需要授权</td>\n<td>相对较安全，需要授权</td>\n</tr>\n</tbody></table>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同的HTTP请求方法在执行操作和传递数据时有不同的语义和适用场景。选择正确的方法取决于业务要执行的操作以及与服务器交互的目的。如希望深入了解HTTP请求方法的内部工作原理和细节，可以研究相关的HTTP协议规范，如RFC 7231。</p>\n","categories":[{"name":"notes","slug":"notes","permalink":"https://veni222987.github.io/categories/notes/"}],"tags":[{"name":"http","slug":"http","permalink":"https://veni222987.github.io/tags/http/"}]},{"title":"Gin框架入门级教程与实践","date":"2023-08-05T14:40:28.000Z","path":"2023/08/05/Gin框架入门级教程与实践/","text":"Gin是一个用Go语言编写的高性能Web框架，它简洁、快速，并具有良好的路由和中间件支持。 Gin框架入门级教程与实践为什么使用Gin我们使用Gin的原因很直接也很简单，那就是Gin很强大也很简单。Gin框架具有如下的有点： 高性能：Gin框架使用了基于Radix树的路由匹配算法，使得路由查找非常快速。同时，Gin框架基于HTTP标准库进行开发，具有低内存占用和高并发处理能力。 简单易用：Gin框架提供了简洁的API和易于理解的代码结构，使得开发者能够快速上手并编写清晰、可维护的代码。 路由和中间件支持：Gin框架提供了灵活的路由定义方式，支持参数路由、分组路由等。同时，Gin框架内置了丰富的中间件支持，如日志、认证、CORS等，可以方便地实现各种功能和扩展需求。 JSON解析和输出：Gin框架内置了强大的JSON解析和输出功能，可以方便地处理请求数据和生成响应。同时，Gin框架还支持其他格式的数据解析和输出，如XML、YAML等。 插件生态丰富：Gin框架有着活跃的社区和丰富的插件生态，可以方便地集成其他常用库和组件，如数据库ORM、缓存库、验证库等。 这些看一下就好，以后会体会到Go的高并发和JSON解析等强大功能的。 Gin框架的入门下载Gin依赖执行以下命令，下载和安装Gin依赖： 1go get -u github.com/gin-gonic/gin 以下指令会把Gin安装在GOPATH里面的src文件夹中。 第一个Gin应用我们先写一个Gin应用，打开Gin的世界。新建一个main.go文件，敲进去这样的代码： 12345678910111213package mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123; r := gin.Default() r.GET(&quot;/hello&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Veni&quot;, &#125;) &#125;) r.Run(&quot;:8888&quot;)&#125; 然后运行一下： 1go run main.go 打开浏览器，输入：localhost:8888/hello，结果返回为&quot;message&quot;:&quot;Veni&quot;，第一个Gin应用完美运行。 代码解析package和import就不说了，从main函数开始。 1r := gin.Default() 这一段代码用来创建一个默认的Gin引擎的实例并赋值给r，该实例已经配置了一些常用的中间件和默认的设置，比如默认使用Logger中间件用于记录请求日志，默认使用Recovery中间件用于恢复panic。还有默认的错误信息处理，默认请求路由器等等。 12345r.GET(&quot;/hello&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Veni&quot;, &#125;) &#125;) r.GET()用于创建一个GET请求的处理函数，请求的路由是”&#x2F;hello”，然后绑定了一个处理函数func。func函数的参数是c *gin.Context，这是Gin框架里面的上下文对象，它封装了每个http请求的信息和操作方法，用于处理请求和响应。为什么要使用指针*呢？因为这里面需要对这个上下文进行修改，因此采用指针传递才能在函数中修改变量的值。Gin.Context有许多用法，比如： c.Request：获取原始的 http.Request 对象。 c.Writer：获取原始的 http.ResponseWriter 对象。 c.Param(key)：获取路由参数值。 c.Query(key)：获取查询参数值。 c.PostForm(key)：获取表单参数值。 c.JSON(code int, obj interface&#123;&#125;)：以 JSON 格式返回数据。 c.HTML(code int, name string, data interface&#123;&#125;)：渲染 HTML 模板并返回。 c.Set(key string, value interface&#123;&#125;)：设置上下文的键值对。 c.Get(key string) interface&#123;&#125;：获取上下文中的值。 所以，上面的c.JSON的作用就是以JSON格式返回数据，函数的第一个参数是整形返回码，interface可以是任意类型的对象。 gin.H{}是Gin框架中用来创建JSON或HTML相应的方式，可以创建一个 map [string] interface类型的对象。使用方法如下： 123456data := gin.H&#123; &quot;message&quot;: &quot;Hello, World!&quot;, &quot;count&quot;: 10, &quot;success&quot;: true, &#125;c.JSON(200, data) 在实际开发中，一般的返回JSON都命名成data，符合前后端开发的习惯。 Gin项目结构Gin的项目结构可以是因人而异的。Go语言相互调用包的过程很简单，公有变量和私有变量只需要使用大小写区分。受到MVC架构的影响，我一般将项目组织成如下的结构： 123456789101112131415161718- main.go - router.go- config.yaml- controller/ - user.go- model/ - user.go- middleware/ - authMiddleware.go- service/ - database.go - redis.go- test/ - config.yaml - main_test.go - user_test.go- utils/ - time.go main文件是程序的入口，用于完成初始化，启动Gin等操作；router用于配置路由信息，包括对应路由的处理函数。 controller目录为控制器层，用于处理路由对应的请求。 model目录是模型层，对应着数据库的一个关系或者自建的实体模型。 middleware是中间件层，用于完成权限认证等操作。 service层存放的是业务逻辑的相关代码，以及调用其他服务或API的代码，可以将DB和Redis等操作代码也放在这一文件夹中。 test是测试目录，用于完成单元测试等工作。 在项目的实际开发中，推荐使用的命名方法是：公有类型名和方法名使用大驼峰，私有类型和方法、目录和文件名使用小驼峰。 Gin项目结构逐层解析现在你已经能够启动Gin框架的hello world，并且也了解了Gin的项目结构。下面我们将逐个实现上述结构，让萌新也可以拥有一个完整的项目框架经验。 package mainmain.go前文中我们直接在main函数处理了一个GET请求，但是实际开发中是绝对不会把处理函数写在main函数里面的。main函数主要做两件事情：初始化环境和启动Gin。所以，一个简单的main.go文件如下： 123456789101112func main() &#123; //初始化引擎 r := gin.Default() //初始化路由器 InitRouter(r) //初始化数据库 service.InitDatabase() //初始化Redis service.InitRedis() //启动Gin r.Run(&quot;:8888&quot;)&#125; router.go初始化引擎一句之前已经解析过了，下面讲讲InitRouter(r)。这个函数我们写在router.go这个文件中，用于处理路由和相关请求。比如下面的这个文件： 12345678func InitRouter(r *gin.Engine) &#123; //静态文件路径 r.Static(&quot;/static&quot;, &quot;./public&quot;) //注册路由组 router := r.Group(&quot;/api&quot;) //在路由组下注册路由 router.POST(&quot;/user/login/&quot;, controller.Login)&#125; 函数的参数需要带指针*，不然在主函数中调用是不会改变r的值的。 r.Static用于注册静态文件的路径，比如某些HTML以及图片等，将其指向本地的public文件夹。 使用r.Group注册路由组，使用路由组可以统一注册中间件，同时也符合树形结构路由的要求。 router.POST则指定了一个路径下的POST请求及其处理函数（controller.Login）。此时的路径必须加上路由组的路径，即完整的路径为：/api/user/login/。 config.yaml该文件用于处理所有重要的配置，比如数据库，Redis等等。使用yaml记录配置十分简洁，可以将字段一一对应到某个go语言的结构体中，内容如下： 1234567891011121314151617database: driver: host: port: username: password: database:redis: addr: password: DB:OSS: endPoint: accessKey: accessSecret: 每一个层级对应一个结构体，最小的层级对应结构体的一个字段。比如，用来存储database配置的两个结构体如下： 123456789101112type DatabaseConfig struct &#123; Driver string `yaml:&quot;driver&quot;` Host string `yaml:&quot;host&quot;` Port int `yaml:&quot;port&quot;` Username string `yaml:&quot;username&quot;` Password string `yaml:&quot;password&quot;` Database string `yaml:&quot;database&quot;`&#125;var config struct &#123; Database DatabaseConfig `yaml:&quot;database&quot;`&#125; package service在主函数里面有一个初始化数据库的函数我们没有说，现在我们来讲一讲这个service.InitDatabase()。这里需要一点gorm的基础，可以去看我的博客另一篇介绍gorm的文章。具体实现代码如下： 12345678910111213141516171819202122232425var Db *gorm.DBfunc InitDatabase() &#123; //读取配置文件 configFile, err := os.ReadFile(&quot;config.yaml&quot;) if err != nil &#123; log.Fatal(err) &#125; //反序列化configFile到config（即上面的var config struct&#123;&#125;变量） err = yaml.Unmarshal(configFile, &amp;config) if err != nil &#123; log.Fatal(err) &#125; //拼接字符串 dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;, config.Database.Username, config.Database.Password, config.Database.Host, config.Database.Port, config.Database.Database, ) Db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) if err != nil &#123; log.Fatal(err) &#125;&#125; DSN(Database Source Name)为数据库资源名称，用于gorm打开数据库并建立连接。后面对数据库的所有操作都可以通过Db这个变量来完成。 package model这个目录存储了主要的结构体，比如model/user.go： 12345678910111213141516type User struct &#123; Id int64 `gorm:&quot;id&quot; json:&quot;id&quot;` // 用户id Name string `gorm:&quot;name&quot; json:&quot;name&quot;` // 用户名称 FollowCount int `gorm:&quot;follow_count&quot; json:&quot;follow_count&quot;` // 关注总数 FollowerCount int `gorm:&quot;follower_count&quot; json:&quot;follower_count&quot;` // 粉丝总数 Avatar string `gorm:&quot;avatar&quot; json:&quot;avatar&quot;` // 用户头像 BackgroundImage string `gorm:&quot;background_image&quot; json:&quot;background_image&quot;` // 用户个人页顶部大图 Signature string `gorm:&quot;signature&quot; json:&quot;signature&quot;` // 个人简介 TotalFavorited int `gorm:&quot;total_favorited&quot; json:&quot;total_favorited&quot;` // 获赞数量 WorkCount int `gorm:&quot;work_count&quot; json:&quot;work_count&quot;` // 作品数 FavoriteCount int `gorm:&quot;favorite_count&quot; json:&quot;favorite_count&quot;` // 喜欢数&#125;//绑定数据库表名，如不指定，则默认为蛇形复数func (*User) TableName() string &#123; return &quot;user&quot;&#125; 使用gorm可以指定某一个属性对应的数据库表的字段，使用json则可以指定当该结构体序列化为json的时候的字段名。 package controller下面是一个控制器的实例，用于处理路由器中已经指定的路由及其处理函数。这里以login为例，函数的具体实现如下，该函数写于controller/user.go文件中 1234567891011121314151617181920212223242526// 登录功能func Login(ctx *gin.Context) &#123; DB := service.Db //获取参数 name := ctx.Query(&quot;username&quot;) password := ctx.Query(&quot;password&quot;) //判断用户是否存在 account := model.Account&#123;&#125; DB.Table(&quot;account&quot;).Where(&quot;username = ?&quot;, name).Find(&amp;account) if len(account.Username) == 0 &#123; ctx.JSON(http.StatusUnprocessableEntity, gin.H&#123;&quot;code&quot;: 422, &quot;msg&quot;: &quot;用户不存在&quot;&#125;) return &#125; //判断密码是否正确 if err := bcrypt.CompareHashAndPassword([]byte(account.Password), []byte(password)); err != nil &#123; ctx.JSON(http.StatusBadRequest, gin.H&#123;&quot;code&quot;: 400, &quot;msg&quot;: &quot;密码错误&quot;&#125;) return &#125; //...... //返回结果 ctx.JSON(200, gin.H&#123; &quot;status_code&quot;: 0, &quot;status_msg&quot;: &quot;string&quot;, &#125;)&#125; package middleware这个包用来存放中间件的相关代码，简单的token验证中间件的实现方法如下： 12345678910111213141516func QueryAuthMiddleWare() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; token := ctx.Query(&quot;token&quot;) if service.IsTokenExist(token) &#123; //fmt.Println(&quot;鉴权成功，token有效\\n&quot;) service.RedisClient.Set(token, service.RedisClient.Get(token).Result, 86400000000000) ctx.Next() &#125; else &#123; fmt.Println(&quot;无效的token&quot;) ctx.AbortWithStatusJSON(401, gin.H&#123; &quot;error&quot;: &quot;无效的Token&quot;, &#125;) return &#125; &#125;&#125; 这里假设处理函数面对的HTTP请求把token放在了Query的位置，则通过ctx.Query(“token”)即可获取到这个token值。这里使用Redis查询是否存在该token从而完成权限鉴定功能，具体实现在函数service.IsTokenExist(token)中，这里就不给出详细代码了，可以自行到github仓库里面看。 package utils这里存放一些代码中可能会使用到的工具函数，比如日期，时间转换等等。下面是一个日期转换的工具： 1234567891011121314151617181920212223242526type CustomTime struct &#123; time.Time&#125;func (ct *CustomTime) UnmarshalJSON(b []byte) (err error) &#123; s := string(b) if s == &quot;null&quot; &#123; ct.Time = time.Time&#123;&#125; return &#125; s = s[1 : len(s)-1] t, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, s) if err != nil &#123; return err &#125; ct.Time = t return&#125;func (ct *CustomTime) MarshalJSON() ([]byte, error) &#123; if ct.IsZero() &#123; return []byte(&quot;null&quot;), nil &#125; return []byte(fmt.Sprintf(&quot;\\&quot;%s\\&quot;&quot;, ct.Format(&quot;2006-01-02 15:04:05&quot;))), nil&#125; 这个函数可以把日期序列化为YYYY-MM-DD hh-mm-ss的形式。 package test单元测试这个包里面的函数用于开展单元测试，单元测试是软件开发中的一种测试方法，旨在验证代码中的最小可测试单元（通常是函数、方法或类）是否按预期工作。 对于需要测试的代码文件创建一个名为*_test.go的文件。 测试代码写成函数形式：func TestXxx(t *testing.T) 初始化逻辑放在TestMain(m *testing.M)函数中，并且文件取名为main_test.go 测试文件在test目录下，一般需要包含如下文件：config.yaml，main_test.go，*_test.go（*代表任意匹配），config.yaml里面的配置填写测试环境配置，比如测试数据库。main_test.go完成对测试环境的初始化工作，比如： 1234567//main_test.gofunc TestMain(m *testing.M) &#123; service.InitRedis() service.InitDatabase() code := m.Run() os.Exit(code)&#125; 然后就可以一次写各个函数的单元测试函数了，下面是一个处理gin框架下的POST请求的一个单元测试函数： 1234567891011121314151617//user_test.gofunc TestLogin(t *testing.T) &#123; router := gin.New() router.POST(&quot;/douyin/user/login&quot;, controller.Login) // 创建一个模拟的HTTP请求 req, _ := http.NewRequest(&quot;POST&quot;, &quot;/douyin/user/login?username=Veni&amp;password=asdfghjkl&quot;, nil) resp := httptest.NewRecorder() // 将请求发送到路由引擎处理 router.ServeHTTP(resp, req) // 验证响应 if resp.Code != 200 &#123; t.Errorf(&quot;Expected status code 200, but got %d&quot;, resp.Code) &#125;&#125; 启动测试由于本项目将main_test.go文件放在了test包中，那么就不能直接运行go test指令来启动测试了，取而代之的是go test .&#x2F;test，此时test目录相当于一个项目的根目录，会运行main_test.go之后自动扫描其他的test文件中的测试函数，一次运行的结果如下： 这里返回了422编码，表明用户不存在，因为测试数据库中并没有这个用户记录。 总结以上就是本次Gin框架的基础教程了，部分代码截自我的第一个go项目，大家可以到仓库里面看具体代码，如果对大家有帮助，不妨在github点个star或者给这篇文章点个赞。","content":"<p>Gin是一个用Go语言编写的高性能Web框架，它简洁、快速，并具有良好的路由和中间件支持。<span id=\"more\"></span></p>\n<h1 id=\"Gin框架入门级教程与实践\"><a href=\"#Gin框架入门级教程与实践\" class=\"headerlink\" title=\"Gin框架入门级教程与实践\"></a>Gin框架入门级教程与实践</h1><h2 id=\"为什么使用Gin\"><a href=\"#为什么使用Gin\" class=\"headerlink\" title=\"为什么使用Gin\"></a>为什么使用Gin</h2><p>我们使用Gin的原因很直接也很简单，那就是Gin很强大也很简单。Gin框架具有如下的有点：</p>\n<ul>\n<li><strong>高性能</strong>：Gin框架使用了基于Radix树的路由匹配算法，使得路由查找非常快速。同时，Gin框架基于HTTP标准库进行开发，具有低内存占用和高并发处理能力。</li>\n<li><strong>简单易用</strong>：Gin框架提供了简洁的API和易于理解的代码结构，使得开发者能够快速上手并编写清晰、可维护的代码。</li>\n<li><strong>路由和中间件支持</strong>：Gin框架提供了灵活的路由定义方式，支持参数路由、分组路由等。同时，Gin框架内置了丰富的中间件支持，如日志、认证、CORS等，可以方便地实现各种功能和扩展需求。</li>\n<li><strong>JSON解析和输出</strong>：Gin框架内置了强大的JSON解析和输出功能，可以方便地处理请求数据和生成响应。同时，Gin框架还支持其他格式的数据解析和输出，如XML、YAML等。</li>\n<li><strong>插件生态丰富</strong>：Gin框架有着活跃的社区和丰富的插件生态，可以方便地集成其他常用库和组件，如数据库ORM、缓存库、验证库等。</li>\n</ul>\n<p>这些看一下就好，以后会体会到Go的高并发和JSON解析等强大功能的。</p>\n<h2 id=\"Gin框架的入门\"><a href=\"#Gin框架的入门\" class=\"headerlink\" title=\"Gin框架的入门\"></a>Gin框架的入门</h2><h3 id=\"下载Gin依赖\"><a href=\"#下载Gin依赖\" class=\"headerlink\" title=\"下载Gin依赖\"></a>下载Gin依赖</h3><p>执行以下命令，下载和安装Gin依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>\n\n<p>以下指令会把Gin安装在GOPATH里面的src文件夹中。</p>\n<h3 id=\"第一个Gin应用\"><a href=\"#第一个Gin应用\" class=\"headerlink\" title=\"第一个Gin应用\"></a>第一个Gin应用</h3><p>我们先写一个Gin应用，打开Gin的世界。新建一个main.go文件，敲进去这样的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    r := gin.Default()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;Veni&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:8888&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后运行一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go</span><br></pre></td></tr></table></figure>\n\n<p>打开浏览器，输入：<code>localhost:8888/hello</code>，结果返回为<code>&quot;message&quot;:&quot;Veni&quot;</code>，第一个Gin应用完美运行。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308071127195.webp\" alt=\"image-20230807112709050\"></p>\n<h4 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h4><p>package和import就不说了，从main函数开始。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r := gin.Default()</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码用来创建一个默认的Gin引擎的实例并赋值给r，该实例已经配置了一些常用的中间件和默认的设置，比如默认使用Logger中间件用于记录请求日志，默认使用Recovery中间件用于恢复panic。还有默认的错误信息处理，默认请求路由器等等。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;Veni&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>r.GET()用于创建一个GET请求的处理函数，请求的路由是”&#x2F;hello”，然后绑定了一个处理函数func。func函数的参数是<code>c *gin.Context</code>，这是Gin框架里面的上下文对象，它封装了每个http请求的信息和操作方法，用于处理请求和响应。为什么要使用指针<code>*</code>呢？因为这里面需要对这个上下文进行修改，因此采用指针传递才能在函数中修改变量的值。Gin.Context有许多用法，比如：</p>\n<ul>\n<li><code>c.Request</code>：获取原始的 http.Request 对象。</li>\n<li><code>c.Writer</code>：获取原始的 http.ResponseWriter 对象。</li>\n<li><code>c.Param(key)</code>：获取路由参数值。</li>\n<li><code>c.Query(key)</code>：获取查询参数值。</li>\n<li><code>c.PostForm(key)</code>：获取表单参数值。</li>\n<li><code>c.JSON(code int, obj interface&#123;&#125;)</code>：以 JSON 格式返回数据。</li>\n<li><code>c.HTML(code int, name string, data interface&#123;&#125;)</code>：渲染 HTML 模板并返回。</li>\n<li><code>c.Set(key string, value interface&#123;&#125;)</code>：设置上下文的键值对。</li>\n<li><code>c.Get(key string) interface&#123;&#125;</code>：获取上下文中的值。</li>\n</ul>\n<p>所以，上面的c.JSON的作用就是以JSON格式返回数据，函数的第一个参数是整形返回码，interface可以是任意类型的对象。</p>\n<p>gin.H{}是Gin框架中用来创建JSON或HTML相应的方式，可以创建一个 map [string] interface类型的对象。使用方法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data := gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;Hello, World!&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;count&quot;</span>:   <span class=\"number\">10</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;success&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">c.JSON(<span class=\"number\">200</span>, data)</span><br></pre></td></tr></table></figure>\n\n<p>在实际开发中，一般的返回JSON都命名成data，符合前后端开发的习惯。</p>\n<h3 id=\"Gin项目结构\"><a href=\"#Gin项目结构\" class=\"headerlink\" title=\"Gin项目结构\"></a>Gin项目结构</h3><p>Gin的项目结构可以是因人而异的。Go语言相互调用包的过程很简单，公有变量和私有变量只需要使用大小写区分。受到MVC架构的影响，我一般将项目组织成如下的结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- main.go  </span><br><span class=\"line\">- router.go</span><br><span class=\"line\">- config.yaml</span><br><span class=\"line\">- controller/</span><br><span class=\"line\">  - user.go</span><br><span class=\"line\">- model/</span><br><span class=\"line\">  - user.go</span><br><span class=\"line\">- middleware/</span><br><span class=\"line\">  - authMiddleware.go</span><br><span class=\"line\">- service/</span><br><span class=\"line\">  - database.go</span><br><span class=\"line\">  - redis.go</span><br><span class=\"line\">- test/</span><br><span class=\"line\">  - config.yaml</span><br><span class=\"line\">  - main_test.go</span><br><span class=\"line\">  - user_test.go</span><br><span class=\"line\">- utils/</span><br><span class=\"line\">  - time.go</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>main文件是程序的入口，用于完成初始化，启动Gin等操作；router用于配置路由信息，包括对应路由的处理函数。</li>\n<li>controller目录为控制器层，用于处理路由对应的请求。</li>\n<li>model目录是模型层，对应着数据库的一个关系或者自建的实体模型。</li>\n<li>middleware是中间件层，用于完成权限认证等操作。</li>\n<li>service层存放的是业务逻辑的相关代码，以及调用其他服务或API的代码，可以将DB和Redis等操作代码也放在这一文件夹中。</li>\n<li>test是测试目录，用于完成单元测试等工作。</li>\n</ul>\n<p>在项目的实际开发中，推荐使用的命名方法是：公有类型名和方法名使用大驼峰，私有类型和方法、目录和文件名使用小驼峰。</p>\n<h2 id=\"Gin项目结构逐层解析\"><a href=\"#Gin项目结构逐层解析\" class=\"headerlink\" title=\"Gin项目结构逐层解析\"></a>Gin项目结构逐层解析</h2><p>现在你已经能够启动Gin框架的hello world，并且也了解了Gin的项目结构。下面我们将逐个实现上述结构，让萌新也可以拥有一个完整的项目框架经验。</p>\n<h3 id=\"package-main\"><a href=\"#package-main\" class=\"headerlink\" title=\"package main\"></a>package main</h3><h4 id=\"main-go\"><a href=\"#main-go\" class=\"headerlink\" title=\"main.go\"></a>main.go</h4><p>前文中我们直接在main函数处理了一个GET请求，但是实际开发中是绝对不会把处理函数写在main函数里面的。main函数主要做两件事情：初始化环境和启动Gin。所以，一个简单的main.go文件如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化引擎</span></span><br><span class=\"line\">\tr := gin.Default()</span><br><span class=\"line\">\t<span class=\"comment\">//初始化路由器</span></span><br><span class=\"line\">\tInitRouter(r)</span><br><span class=\"line\">    <span class=\"comment\">//初始化数据库</span></span><br><span class=\"line\">\tservice.InitDatabase()</span><br><span class=\"line\">    <span class=\"comment\">//初始化Redis</span></span><br><span class=\"line\">\tservice.InitRedis()</span><br><span class=\"line\">\t<span class=\"comment\">//启动Gin</span></span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:8888&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"router-go\"><a href=\"#router-go\" class=\"headerlink\" title=\"router.go\"></a>router.go</h4><p>初始化引擎一句之前已经解析过了，下面讲讲InitRouter(r)。这个函数我们写在router.go这个文件中，用于处理路由和相关请求。比如下面的这个文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitRouter</span><span class=\"params\">(r *gin.Engine)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态文件路径</span></span><br><span class=\"line\">    r.Static(<span class=\"string\">&quot;/static&quot;</span>, <span class=\"string\">&quot;./public&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//注册路由组</span></span><br><span class=\"line\">    router := r.Group(<span class=\"string\">&quot;/api&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//在路由组下注册路由</span></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/user/login/&quot;</span>, controller.Login)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数的参数需要带指针*，不然在主函数中调用是不会改变r的值的。</li>\n<li>r.Static用于注册静态文件的路径，比如某些HTML以及图片等，将其指向本地的public文件夹。</li>\n<li>使用r.Group注册路由组，使用路由组可以统一注册中间件，同时也符合树形结构路由的要求。</li>\n<li>router.POST则指定了一个路径下的POST请求及其处理函数（controller.Login）。此时的路径必须加上路由组的路径，即完整的路径为：<code>/api/user/login/</code>。</li>\n</ul>\n<h4 id=\"config-yaml\"><a href=\"#config-yaml\" class=\"headerlink\" title=\"config.yaml\"></a>config.yaml</h4><p>该文件用于处理所有重要的配置，比如数据库，Redis等等。使用yaml记录配置十分简洁，可以将字段一一对应到某个go语言的结构体中，内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">database:</span></span><br><span class=\"line\">  <span class=\"attr\">driver:</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span></span><br><span class=\"line\">  <span class=\"attr\">password:</span></span><br><span class=\"line\">  <span class=\"attr\">database:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">redis:</span></span><br><span class=\"line\">  <span class=\"attr\">addr:</span></span><br><span class=\"line\">  <span class=\"attr\">password:</span></span><br><span class=\"line\">  <span class=\"attr\">DB:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">OSS:</span></span><br><span class=\"line\">  <span class=\"attr\">endPoint:</span></span><br><span class=\"line\">  <span class=\"attr\">accessKey:</span></span><br><span class=\"line\">  <span class=\"attr\">accessSecret:</span></span><br></pre></td></tr></table></figure>\n\n<p>每一个层级对应一个结构体，最小的层级对应结构体的一个字段。比如，用来存储database配置的两个结构体如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> DatabaseConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tDriver   <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;driver&quot;`</span></span><br><span class=\"line\">\tHost     <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;host&quot;`</span></span><br><span class=\"line\">\tPort     <span class=\"type\">int</span>    <span class=\"string\">`yaml:&quot;port&quot;`</span></span><br><span class=\"line\">\tUsername <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;username&quot;`</span></span><br><span class=\"line\">\tPassword <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;password&quot;`</span></span><br><span class=\"line\">\tDatabase <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;database&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tDatabase DatabaseConfig <span class=\"string\">`yaml:&quot;database&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"package-service\"><a href=\"#package-service\" class=\"headerlink\" title=\"package service\"></a>package service</h3><p>在主函数里面有一个初始化数据库的函数我们没有说，现在我们来讲一讲这个<code>service.InitDatabase()</code>。这里需要一点gorm的基础，可以去看<a href=\"https://veni222987.github.io/2023/08/10/%EF%BC%88%E5%AE%8C%EF%BC%89GORM%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/\">我的博客另一篇介绍gorm的文章</a>。具体实现代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Db *gorm.DB</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitDatabase</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取配置文件</span></span><br><span class=\"line\">\tconfigFile, err := os.ReadFile(<span class=\"string\">&quot;config.yaml&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//反序列化configFile到config（即上面的var config struct&#123;&#125;变量）</span></span><br><span class=\"line\">\terr = yaml.Unmarshal(configFile, &amp;config)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//拼接字符串</span></span><br><span class=\"line\">\tdsn := fmt.Sprintf(<span class=\"string\">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class=\"line\">\t\tconfig.Database.Username,</span><br><span class=\"line\">\t\tconfig.Database.Password,</span><br><span class=\"line\">\t\tconfig.Database.Host,</span><br><span class=\"line\">\t\tconfig.Database.Port,</span><br><span class=\"line\">\t\tconfig.Database.Database,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tDb, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DSN(Database Source Name)为数据库资源名称，用于gorm打开数据库并建立连接。后面对数据库的所有操作都可以通过Db这个变量来完成。</p>\n<h3 id=\"package-model\"><a href=\"#package-model\" class=\"headerlink\" title=\"package model\"></a>package model</h3><p>这个目录存储了主要的结构体，比如<code>model/user.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tId              <span class=\"type\">int64</span>  <span class=\"string\">`gorm:&quot;id&quot; json:&quot;id&quot;`</span>                             <span class=\"comment\">// 用户id</span></span><br><span class=\"line\">\tName            <span class=\"type\">string</span> <span class=\"string\">`gorm:&quot;name&quot; json:&quot;name&quot;`</span>                         <span class=\"comment\">// 用户名称</span></span><br><span class=\"line\">\tFollowCount     <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;follow_count&quot; json:&quot;follow_count&quot;`</span>         <span class=\"comment\">// 关注总数</span></span><br><span class=\"line\">\tFollowerCount   <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;follower_count&quot; json:&quot;follower_count&quot;`</span>     <span class=\"comment\">// 粉丝总数</span></span><br><span class=\"line\">\tAvatar          <span class=\"type\">string</span> <span class=\"string\">`gorm:&quot;avatar&quot; json:&quot;avatar&quot;`</span>                     <span class=\"comment\">// 用户头像</span></span><br><span class=\"line\">\tBackgroundImage <span class=\"type\">string</span> <span class=\"string\">`gorm:&quot;background_image&quot; json:&quot;background_image&quot;`</span> <span class=\"comment\">// 用户个人页顶部大图</span></span><br><span class=\"line\">\tSignature       <span class=\"type\">string</span> <span class=\"string\">`gorm:&quot;signature&quot; json:&quot;signature&quot;`</span>               <span class=\"comment\">// 个人简介</span></span><br><span class=\"line\">\tTotalFavorited  <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;total_favorited&quot; json:&quot;total_favorited&quot;`</span>   <span class=\"comment\">// 获赞数量</span></span><br><span class=\"line\">\tWorkCount       <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;work_count&quot; json:&quot;work_count&quot;`</span>             <span class=\"comment\">// 作品数</span></span><br><span class=\"line\">\tFavoriteCount   <span class=\"type\">int</span>    <span class=\"string\">`gorm:&quot;favorite_count&quot; json:&quot;favorite_count&quot;`</span>     <span class=\"comment\">// 喜欢数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//绑定数据库表名，如不指定，则默认为蛇形复数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*User)</span></span> TableName() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;user&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用gorm可以指定某一个属性对应的数据库表的字段，使用json则可以指定当该结构体序列化为json的时候的字段名。</p>\n<h3 id=\"package-controller\"><a href=\"#package-controller\" class=\"headerlink\" title=\"package controller\"></a>package controller</h3><p>下面是一个控制器的实例，用于处理路由器中已经指定的路由及其处理函数。这里以login为例，函数的具体实现如下，该函数写于<code>controller/user.go</code>文件中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 登录功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Login</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\tDB := service.Db</span><br><span class=\"line\">\t<span class=\"comment\">//获取参数</span></span><br><span class=\"line\">\tname := ctx.Query(<span class=\"string\">&quot;username&quot;</span>)</span><br><span class=\"line\">\tpassword := ctx.Query(<span class=\"string\">&quot;password&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//判断用户是否存在</span></span><br><span class=\"line\">\taccount := model.Account&#123;&#125;</span><br><span class=\"line\">\tDB.Table(<span class=\"string\">&quot;account&quot;</span>).Where(<span class=\"string\">&quot;username = ?&quot;</span>, name).Find(&amp;account)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(account.Username) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusUnprocessableEntity, gin.H&#123;<span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">422</span>, <span class=\"string\">&quot;msg&quot;</span>: <span class=\"string\">&quot;用户不存在&quot;</span>&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//判断密码是否正确</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := bcrypt.CompareHashAndPassword([]<span class=\"type\">byte</span>(account.Password), []<span class=\"type\">byte</span>(password)); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusBadRequest, gin.H&#123;<span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">400</span>, <span class=\"string\">&quot;msg&quot;</span>: <span class=\"string\">&quot;密码错误&quot;</span>&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回结果</span></span><br><span class=\"line\">\tctx.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;status_code&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;status_msg&quot;</span>:  <span class=\"string\">&quot;string&quot;</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"package-middleware\"><a href=\"#package-middleware\" class=\"headerlink\" title=\"package middleware\"></a>package middleware</h3><p>这个包用来存放中间件的相关代码，简单的token验证中间件的实现方法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QueryAuthMiddleWare</span><span class=\"params\">()</span></span> gin.HandlerFunc &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\ttoken := ctx.Query(<span class=\"string\">&quot;token&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> service.IsTokenExist(token) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//fmt.Println(&quot;鉴权成功，token有效\\n&quot;)</span></span><br><span class=\"line\">\t\t\tservice.RedisClient.Set(token, service.RedisClient.Get(token).Result, <span class=\"number\">86400000000000</span>)</span><br><span class=\"line\">\t\t\tctx.Next()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;无效的token&quot;</span>)</span><br><span class=\"line\">\t\t\tctx.AbortWithStatusJSON(<span class=\"number\">401</span>, gin.H&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;error&quot;</span>: <span class=\"string\">&quot;无效的Token&quot;</span>,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里假设处理函数面对的HTTP请求把token放在了Query的位置，则通过ctx.Query(“token”)即可获取到这个token值。这里使用Redis查询是否存在该token从而完成权限鉴定功能，具体实现在函数<code>service.IsTokenExist(token)</code>中，这里就不给出详细代码了，可以自行到github仓库里面看。</p>\n<h3 id=\"package-utils\"><a href=\"#package-utils\" class=\"headerlink\" title=\"package utils\"></a>package utils</h3><p>这里存放一些代码中可能会使用到的工具函数，比如日期，时间转换等等。下面是一个日期转换的工具：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CustomTime <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttime.Time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ct *CustomTime)</span></span> UnmarshalJSON(b []<span class=\"type\">byte</span>) (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\ts := <span class=\"type\">string</span>(b)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s == <span class=\"string\">&quot;null&quot;</span> &#123;</span><br><span class=\"line\">\t\tct.Time = time.Time&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ts = s[<span class=\"number\">1</span> : <span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\tt, err := time.Parse(<span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>, s)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tct.Time = t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ct *CustomTime)</span></span> MarshalJSON() ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ct.IsZero() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">byte</span>(<span class=\"string\">&quot;null&quot;</span>), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> []<span class=\"type\">byte</span>(fmt.Sprintf(<span class=\"string\">&quot;\\&quot;%s\\&quot;&quot;</span>, ct.Format(<span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>))), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数可以把日期序列化为<code>YYYY-MM-DD hh-mm-ss</code>的形式。</p>\n<h3 id=\"package-test\"><a href=\"#package-test\" class=\"headerlink\" title=\"package test\"></a>package test</h3><h4 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h4><p>这个包里面的函数用于开展单元测试，单元测试是软件开发中的一种测试方法，旨在验证代码中的最小可测试单元（通常是函数、方法或类）是否按预期工作。</p>\n<ul>\n<li>对于需要测试的代码文件创建一个名为<code>*_test.go</code>的文件。</li>\n<li>测试代码写成函数形式：<code>func TestXxx(t *testing.T)</code></li>\n<li>初始化逻辑放在<code>TestMain(m *testing.M)</code>函数中，并且文件取名为main_test.go</li>\n</ul>\n<h4 id=\"测试文件\"><a href=\"#测试文件\" class=\"headerlink\" title=\"测试文件\"></a>测试文件</h4><p>在test目录下，一般需要包含如下文件：config.yaml，main_test.go，*_test.go（*代表任意匹配），config.yaml里面的配置填写测试环境配置，比如测试数据库。main_test.go完成对测试环境的初始化工作，比如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main_test.go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">\tservice.InitRedis()</span><br><span class=\"line\">\tservice.InitDatabase()</span><br><span class=\"line\">\tcode := m.Run()</span><br><span class=\"line\">\tos.Exit(code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以一次写各个函数的单元测试函数了，下面是一个处理gin框架下的POST请求的一个单元测试函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//user_test.go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestLogin</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\trouter := gin.New()</span><br><span class=\"line\">\trouter.POST(<span class=\"string\">&quot;/douyin/user/login&quot;</span>, controller.Login)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个模拟的HTTP请求</span></span><br><span class=\"line\">\treq, _ := http.NewRequest(<span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;/douyin/user/login?username=Veni&amp;password=asdfghjkl&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tresp := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将请求发送到路由引擎处理</span></span><br><span class=\"line\">\trouter.ServeHTTP(resp, req)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 验证响应</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> resp.Code != <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">\t\tt.Errorf(<span class=\"string\">&quot;Expected status code 200, but got %d&quot;</span>, resp.Code)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h4><p>由于本项目将<code>main_test.go</code>文件放在了test包中，那么就不能直接运行go test指令来启动测试了，取而代之的是go test .&#x2F;test，此时test目录相当于一个项目的根目录，会运行<code>main_test.go</code>之后自动扫描其他的test文件中的测试函数，一次运行的结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308241826655.webp\" alt=\"image-20230824182624455\"></p>\n<p>这里返回了422编码，表明用户不存在，因为测试数据库中并没有这个用户记录。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是本次Gin框架的基础教程了，部分代码截自<a href=\"https://github.com/Veni222987/DoushengABCD.git\">我的第一个go项目</a>，大家可以到仓库里面看具体代码，如果对大家有帮助，不妨在github点个star或者给这篇文章点个赞。</p>\n","categories":[{"name":"go","slug":"go","permalink":"https://veni222987.github.io/categories/go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://veni222987.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"go","slug":"go","permalink":"https://veni222987.github.io/tags/go/"}]},{"title":"【Exp】Git的正确使用姿势与最佳实践","date":"2023-07-31T12:21:47.000Z","path":"2023/07/31/【Exp】Git的正确使用姿势与最佳实践/","text":"先问一下屏幕前的你，是不是还在使用压缩包传代码？是不是还在重命名一个“_备份”文件来保存修改，又或者说，对git的使用只停留在IDE的GUI上。当然作为一个合格的大一新生，这些事情估计都是常态。那么话不多说，我们直接开始——Git的正确使用姿势和最佳实践。 什么是git先来看看百度百科的介绍： Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 Wiki讲得更清晰一点： Git (&#x2F;ɡɪt&#x2F;) is a distributed version control system that tracks changes in any set of computer files, usually used for coordinating work among programmers who are collaboratively developing source code during software development. Its goals include speed, data integrity, and support for distributed, non-linear workflows (thousands of parallel branches running on different computers). 简单点说，就是一套开源的分布式版本控制系统。有了它，把代码改崩了也不害怕。 git下载安装windows操作系统打开git官网，找到右边的Download for Windows，进去之后选择对应的版本即可。下载之后打开下载器，一定安装git bash，一直点next，最后就安装完成了，当然也可以进行个性化安装。我的建议是一开始直接next到底即可，反正你自己也不知道哪个有没有用，等自己用熟悉了git之后，重装系统或者换电脑的时候你就信手拈来了。 Linux操作系统（以Debian为例）更新软件库： 1sudo apt update 下载git： 1sudo apt install git 检查是否安装成功在windows系统下，右键打开GitBash(Windows下安装的时候推荐安装GitBash)，就是一个特殊的shell，输入指令： 1git --version 有出现版本号就代表安装成功。在Linux操作系统下同理： git配置个人信息配置在git安装完成之后，需要先进行一些基本的配置操作，个人信息配置主要包括用户名，账号邮箱，账号密码三部分。 配置方法如下： 12345git config --global user.name &quot;Veni&quot;git config --global user.email &quot;123456789@qq.com&quot;git config --global user.password &quot;123456&quot; 把email和密码换成自己github注册的时候使用的邮箱和密码，这样做有两个原因： 如果正确设置了账号密码，每次clone和pull自己的私有分支的时候就不用再输入一次，没设置好的话操作远程分支会很麻烦。 设置好了邮箱，github上面的contributions才能正确统计，如果没设置，哪怕你干了活人家github也不知道是你干的，就不会帮你统计提交了。 另外，设置用户名主要是为了仓库管理员可以清楚地看到每个人修改了什么，发生错误的时候可以正常回退，然后抓出来问一顿，bug说不定就解决了。 代理配置有些小朋友总是说github同步代码速度慢，这里有两种方法，一种是使用魔法（施法工具得自己找），另一种是使用国内的gitee。当使用魔法的时候，就需要对git的代理进行设置。 首先看看自己的代理ip和端口号，一般长这样： 然后设置全局的http和https代理： 123git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy https://127.0.0.1:7890 把–global去掉之后就是只设置当前仓库的代理，原理是只修改当前仓库.git&#x2F;config文件里面的配置，而使用全局设置之后就是直接修改git安装目录下的.gitconfig文件。 当你当前仓库使用了代理之后，那么你就必须一直开着魔法工具才能正常使用，否则会报错。 查看配置想要看自己设置有没有打错，可以自行查看一下，命令： 1git config --global --list 出来的结果长这样： 如果检查完毕之后没什么问题，那就可以愉快地使用了。 使用SSH连接除了配置HTTP代理之外，我们还可以采用另外一种方式连接，即SSH连接。 首先，你需要将检查自己的电脑是否有SSH密钥，打开用户的home目录，里面有一个.ssh隐藏文件夹，打开之后，如果有类似xxx.pub(一般是id_rsa.pub)这样的文件，表明自己的电脑已经有一对密钥对了，其中的pub表示的是公钥，顾名思义就是给别人用来加密的。如果没有，那就执行下面的指令，生成一对密钥： 1ssh-keygen -t rsa 如不想定义，直接一路回车即可。之后打开.ssh文件夹，你就会看到.pub文件了。 下一步是将ssh的公钥放到github上面。 打开github-&gt;Setting-&gt;SSH and GPG keys，将刚才的pub文件里面的公钥粘贴进去就好了。之后就可以使用ssh连接了。 git分区先来了解一下Git的分区，不然下面的指令有可能会看不懂。首先来看一下Git的架构图： 在这个架构图中，工作区、暂存区和本地仓库（或者说提交区）是最重要的三个部分。由于Git是一个分布式的版本控制系统，它不需要一个集中的版本号，所以没有远程仓库其实也可以工作。 工作区是.git文件夹及其子文件夹的所有文件的区域，可以理解为工作区就是一个目录里面的所有文件组成的分区，没有被索引的文件都在工作区总。add指令可以将工作区中的内容添加到暂存区，暂存区里面的文件都是被tracked的文件，也就是说，任何一次commit都会对暂存区的文件做一次快照。经过commit之后，暂存区的修改就会被提交到本地仓库，本地仓库中的记录就是一个个版本，可以被回退或者创建分支。 远程仓库是一个可以实现多机共同协作的地方，每个人都可以把本地仓库里面的commit推送到远程仓库，别人也可以从远程仓库中拉取最新的代码。常见的远程仓库网站有：Github、Gitee等等，甚至也可以自己在服务器上搭建一个git仓库。 git使用这里用git的常用命令组织文章结构，这样写的好处是应用性较强。我推荐看看廖雪峰的git教程，他使用一个仓库管理的实例和故事性的结构讲述git，我认为十分通俗易懂。 git init在项目的根目录下创建一个git仓库，git会对整个目录范围内的代码进行管理。比如，我在桌面创建一个example目录，然后打开目录，右键Open Git Bash here，输入指令git init即可初始化一个git仓库。初始化完成之后，可以打开.git隐藏文件夹，里面就有一些文件是记录当前仓库的信息的，比如config记录当前仓库设置，HEAD记录代码提交。 这个文件里面的东西不需要自己写！！！ 这个文件里面的东西不需要自己写！！！ 这个文件里面的东西不需要自己写！！！ 重要的事情说三遍，不要自己修改把仓库玩坏了，一般来说是不用打开.git目录的，处于学习的目的可以进去研究一下。 git addgit add指令的作用是将文件或者目录添加到暂存区，包括新增的，删除的，修改的。这里以刚刚创建的example文件夹为例，我创建了一个hello_world.txt文件，里面写上hello world。然后保存退出。使用git add指令将其添加到暂存区： 1git add . .表示当前目录，它会自动把当前目录的所有文件及其子目录里面的文件都加入暂存区，执行结果如下： 是的，你没有看错，它什么也没有发生。 git commit刚才使用的git add指令只是将其添加到git暂存区，而不是提交修改到仓库。也就是说，你自己git add多少次都没有影响仓库里面的东西，那么要提交的话就需要使用git commit指令。 git commit指令将暂存区提交到了仓库，仓库会为当前修改创建一个节点，每一次的commit都是仓库版本回退的节点，那些add但是没有commit的修改是不能回退的。使用方法： 1git commit -m&quot;hello world&quot; -m后面的双引号就是本次提交的消息，一般用来记录修改了什么，执行结果如下： 接下来我们修改一下hello_world.txt里面的内容，再提交一次，修改的内容为： 12hello world!hello git! 然后执行 1git commit -m&quot;hello git&quot; 结果如下： 那么接下来我们看一下自己的这两次修改：打开.git&#x2F;log&#x2F;HEAD，里面有我们的修改记录： 当然这些东西直接使用git log指令也可以直接看到： commit后面的十六进制数字串就是版本号，后面是修改人的名字和邮箱，修改日期以及修改评语等。后面可以根据这个版本号直接回退到彼时的仓库状态。 git reset如果再某一次的修改中，代码直接崩掉无法运作了，就可以使用git reset指令，坐上时光机回到过去。 使用的时候它也会提醒你”Unstaged changes after reset:”，这个时候是仓库工作区（也就是代码内容）并没有回退成功的，只是撤销了最后一次提交，并且将HEAD指针移动到上一次更改，这个时候你可以加上--hard指令强制整个仓库（包括工作区）回退到指定的版本号。但是有一点需要注意，这个时光机是不能带着未来的东西回去的。也就是说，你后面写的代码都会被丢失，使用reset –hard指令之后，整个仓库都会回到过去的一个commit的状态。你可以打开文件看看是不是回去了。 此外，如果只是要回退一个版本号，那么不需要查版本号，只需要： 1git reset --hard HEAD^ HEAD^代替了上一个版本号。 git stash暂存用于当前某一件事情做了一半的情况下，需要切换到另外一个分支处理另一个事情的时候把当前的工作区保存起来。例如，当前你正在开发一个新功能，但是突然leader说原来的版本有一个bug需要切换到另外一个分支解决，这个时候直接checkout是不会成功的，因为当前工作区发生了改变，会提示： 1234error: Your local changes to the following files would be overwritten by checkout:**************Please commit your changes or stash them before you switch branches.Aborting 如何存储？ 使用git stash可以简单粗暴地存储当前的工作区，但是推荐使用git stash save &quot;msg&quot;的方式，可以对存储内容进行描述，使用git stash list可以查看曾经存储的进度： 12PS M:\\MyProjects\\ILOVEJava&gt; git stash list stash@&#123;0&#125;: On newb: 添加测试 On ***表示再某个分支，一般情况下，从stash中恢复的时候推荐从原来stash的分支恢复，避免发生冲突。 如何恢复 使用git stash pop可以快速恢复暂存区的最新内容，git stash pop stash@&#123;1&#125;可以恢复到指定内容。 git push上面讲的都是在本地仓库使用Git的操作，接下来我们来用一下远程仓库，这里以Github为例。 首先，新建一个空仓库，建完之后长这样： 如果使用了模板创建的话，仓库在创建之初就会有一些文件，比如README.md，.gitignore等等。 将本地仓库与远程仓库进行关联： 每一个仓库都会有一个个人地址，将地址copy下来之后，在控制台输入 1git remote add origin https://github.com/Veni222987/example.git 然后使用git remote指令可以查看所有远程仓库。 将本地仓库上面的东西上传到远程仓库： 使用git push指令可以将本地仓库上面的东西推送到远程仓库中，比如： 1git push origin main 执行结果长这样： 之后到github上面就可以看到东西已经提交上去了。 细心的朋友可能会发现，这次提交的东西怎么是hello world呢？后来不是写了个hello git吗？这是因为，我们在上一步的时候把版本回退到了第一个版本，也就是整个仓库都是第一次提交的状态，那么push上去自然也就是那个时候的状态了。 git pullgit pull指令用于把远程仓库上的代码拉取到本地仓库，执行pull指令需要注意： git pull指令相当于git fetch和git merge指令，会把远程分支和本地分支进行合并，如果远程分支包含本地分支的修改，即远程分支比本地分支先进，就会更新本地分支。 首先，在txt文件中加一行hello remote1，然后commit的消息为”add remote1”，再在txt文件中加一行hello remote2，然后commit消息”add remote2”，此时的文件应该是： 123hello worldhello remote1hello remote2 将add remote2的commit推送给到远程仓库： 1git push origin main 然后版本回退到remote1： 1git reset --hard HEAD^ 此时仓库的状态是远程分支领先当前分支一个commit，使用pull可以将远程仓库的更新拉下来并且自动更新本地工作区： 1git pull origin main 下图展示了一个单分支模型的pull过程： 当远程仓库和本地仓库处在两个不同的分支时，在merge的时候就可能会出现冲突： 在刚才的修改基础上，我们再退回去： 1git reset --hard HEAD^ 然后添加一行：hello remote3，即文件变成了： 123hello worldhello remote1hello remote3 commit当前修改: 1git commit -m&quot;add remote3&quot; 这个时候，本地分支比远程分支领先1个commit，落后1个commit，而且修改的是同一个文件的同一行，会引发合并冲突： 此时需要我们手动合并冲突。出现合并冲突窗口后，不要急着关闭bash窗口，查看所有的CONFICT所在的文件，打开之后找到带有分隔符（&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;以及&gt;&gt;&gt;）的代码段或文本段： 选择一种方案保留，（推荐使用vscode打开，可以一键选择），我这里选择了保留当前更改，然后回到git bash，此时的仓库处于MERGING状态，需要手动修改完所有冲突文件之后再commit一次才能退出该状态，然后将此修改推送到远程仓库，此时两个仓库又处于同步状态了。 本次合并的示意图如下： --- title: 合并分支示意图 --- gitGraph commit id: \"init\" commit id: \"add remote1\" branch origin_main checkout origin_main commit id: \"add remote2\" checkout main commit id: \"add remote3\" merge origin_main commit id: \"merge confict\" 如果将本地分支push到远程分支，则会将远程分支的HEAD指针指向merge conflict： git checkoutgit checkout用于切换仓库的工作状态，比如切换到指定分支或指定提交。常见的用法如下： 1git checkout &lt;branch_name&gt; 上述指令用于切换到指定分支。一般来说，在实际开发中，一个仓库会有不同的分支，不同的人管理不同的分支。使用git chekout -b &lt;branch_name&gt;可以以当前分支为基础创建并切换到新的分支；使用git branch -a显示所有分支。 当在不同分支工作的时候，可以相互合并分支的代码，比如本地main分支合并远程dev分支（默认为origin&#x2F;dev），则可以在main分支下使用以下指令： 1git pull origin dev 前面我们说过，git pull相当于git fetch+git merge，git fetch指令就是将远程分支中的内容取到本地，而git merge则用于合并。一般情况下，git会使用自带的合并策略自动完成合并，出现冲突则需要手动处理并重新提交。 如果是本地分支合并另一个分支的代码，则无需使用pull指令，而是直接使用git merge。比如主分支合并本地dev分支，在main分支下执行： 1git merge dev 总结git还有其他的用法，比如git checkout，git merge等等，实际上掌握了上面的常用指令之后就可以满足日常的合作开发需求了。学习git的最佳实践就是反复练习使用上面的指令，最终能够达到还没执行指令就知道会发生什么的境界，那就代表自己是真的理解了。","content":"<p>先问一下屏幕前的你，是不是还在使用压缩包传代码？是不是还在重命名一个“_备份”文件来保存修改，又或者说，对git的使用只停留在IDE的GUI上。当然作为一个合格的大一新生，这些事情估计都是常态。那么话不多说，我们直接开始——Git的正确使用姿势和最佳实践。<span id=\"more\"></span></p>\n<h1 id=\"什么是git\"><a href=\"#什么是git\" class=\"headerlink\" title=\"什么是git\"></a>什么是git</h1><p>先来看看百度百科的介绍：</p>\n<p>Git（读音为&#x2F;gɪt&#x2F;）是一个<strong>开源</strong>的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>\n<p>Wiki讲得更清晰一点：</p>\n<p><strong>Git</strong> (<a href=\"https://en.wikipedia.org/wiki/Help:IPA/English\">&#x2F;ɡɪt&#x2F;</a>) is a <a href=\"https://en.wikipedia.org/wiki/Distributed_version_control\">distributed version control</a> system that tracks changes in any set of <a href=\"https://en.wikipedia.org/wiki/Computer_file\">computer files</a>, usually used for coordinating work among programmers who are collaboratively developing <a href=\"https://en.wikipedia.org/wiki/Source_code\">source code</a> during <a href=\"https://en.wikipedia.org/wiki/Software_development\">software development</a>. Its goals include speed, <a href=\"https://en.wikipedia.org/wiki/Data_integrity\">data integrity</a>, and support for <a href=\"https://en.wikipedia.org/wiki/Distributed_computing\">distributed</a>, non-linear workflows (thousands of parallel <a href=\"https://en.wikipedia.org/wiki/Branching_(version_control)\">branches</a> running on different computers).</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021410465.webp\" alt=\"image-20230802141015329\"></p>\n<p>简单点说，就是一套开源的分布式版本控制系统。有了它，把代码改崩了也不害怕。</p>\n<h1 id=\"git下载安装\"><a href=\"#git下载安装\" class=\"headerlink\" title=\"git下载安装\"></a>git下载安装</h1><h2 id=\"windows操作系统\"><a href=\"#windows操作系统\" class=\"headerlink\" title=\"windows操作系统\"></a>windows操作系统</h2><p>打开<a href=\"https://git-scm.com/\">git官网</a>，找到右边的Download for Windows，进去之后选择对应的版本即可。下载之后打开下载器，一定安装git bash，一直点next，最后就安装完成了，当然也可以进行个性化安装。我的建议是一开始直接next到底即可，反正你自己也不知道哪个有没有用，等自己用熟悉了git之后，重装系统或者换电脑的时候你就信手拈来了。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021513783.webp\" alt=\"image-20230802151343476\"></p>\n<h2 id=\"Linux操作系统（以Debian为例）\"><a href=\"#Linux操作系统（以Debian为例）\" class=\"headerlink\" title=\"Linux操作系统（以Debian为例）\"></a>Linux操作系统（以Debian为例）</h2><p>更新软件库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<p>下载git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检查是否安装成功\"><a href=\"#检查是否安装成功\" class=\"headerlink\" title=\"检查是否安装成功\"></a>检查是否安装成功</h2><p>在windows系统下，右键打开GitBash(Windows下安装的时候推荐安装GitBash)，就是一个特殊的shell，输入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021523361.webp\" alt=\"image-20230802152339257\"></p>\n<p>有出现版本号就代表安装成功。在Linux操作系统下同理：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308021525433.webp\" alt=\"image-20230802152509361\"></p>\n<h1 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h1><h2 id=\"个人信息配置\"><a href=\"#个人信息配置\" class=\"headerlink\" title=\"个人信息配置\"></a>个人信息配置</h2><p>在git安装完成之后，需要先进行一些基本的配置操作，个人信息配置主要包括用户名，账号邮箱，账号密码三部分。</p>\n<p>配置方法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;Veni&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;123456789@qq.com&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.password <span class=\"string\">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>把email和密码换成自己github注册的时候使用的邮箱和密码，这样做有两个原因：</p>\n<ul>\n<li>如果正确设置了账号密码，每次clone和pull自己的私有分支的时候就不用再输入一次，没设置好的话操作远程分支会很麻烦。</li>\n<li>设置好了邮箱，github上面的contributions才能正确统计，如果没设置，哪怕你干了活人家github也不知道是你干的，就不会帮你统计提交了。</li>\n</ul>\n<p>另外，设置用户名主要是为了仓库管理员可以清楚地看到每个人修改了什么，发生错误的时候可以正常回退，然后抓出来问一顿，bug说不定就解决了。</p>\n<h2 id=\"代理配置\"><a href=\"#代理配置\" class=\"headerlink\" title=\"代理配置\"></a>代理配置</h2><p>有些小朋友总是说github同步代码速度慢，这里有两种方法，一种是使用魔法（施法工具得自己找），另一种是使用国内的gitee。当使用魔法的时候，就需要对git的代理进行设置。</p>\n<ul>\n<li>首先看看自己的代理ip和端口号，一般长这样：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308030945337.webp\" alt=\"image-20230803094551162\"></p>\n<ul>\n<li>然后设置全局的http和https代理：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy http://127.0.0.1:7890</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure>\n\n<p>把–global去掉之后就是只设置当前仓库的代理，原理是只修改当前仓库.git&#x2F;config文件里面的配置，而使用全局设置之后就是直接修改git安装目录下的.gitconfig文件。</p>\n<ul>\n<li>当你当前仓库使用了代理之后，那么你就必须一直开着魔法工具才能正常使用，否则会报错。</li>\n</ul>\n<h2 id=\"查看配置\"><a href=\"#查看配置\" class=\"headerlink\" title=\"查看配置\"></a>查看配置</h2><p>想要看自己设置有没有打错，可以自行查看一下，命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --list</span><br></pre></td></tr></table></figure>\n\n<p>出来的结果长这样：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308030954198.webp\" alt=\"image-20230803095444121\"></p>\n<p>如果检查完毕之后没什么问题，那就可以愉快地使用了。</p>\n<h2 id=\"使用SSH连接\"><a href=\"#使用SSH连接\" class=\"headerlink\" title=\"使用SSH连接\"></a>使用SSH连接</h2><p>除了配置HTTP代理之外，我们还可以采用另外一种方式连接，即SSH连接。</p>\n<p>首先，你需要将检查自己的电脑是否有SSH密钥，打开用户的home目录，里面有一个.ssh隐藏文件夹，打开之后，如果有类似xxx.pub(一般是id_rsa.pub)这样的文件，表明自己的电脑已经有一对密钥对了，其中的pub表示的是公钥，顾名思义就是给别人用来加密的。如果没有，那就执行下面的指令，生成一对密钥：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n<p>如不想定义，直接一路回车即可。之后打开.ssh文件夹，你就会看到.pub文件了。</p>\n<p>下一步是将ssh的公钥放到github上面。</p>\n<p>打开github-&gt;Setting-&gt;SSH and GPG keys，将刚才的pub文件里面的公钥粘贴进去就好了。之后就可以使用ssh连接了。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/image-20240315113906350.png\" alt=\"image-20240315113906350\"></p>\n<h1 id=\"git分区\"><a href=\"#git分区\" class=\"headerlink\" title=\"git分区\"></a>git分区</h1><p>先来了解一下Git的分区，不然下面的指令有可能会看不懂。首先来看一下Git的架构图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3670077-b97c6a8e14d1dafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp\"></p>\n<p>在这个架构图中，工作区、暂存区和本地仓库（或者说提交区）是最重要的三个部分。由于Git是一个分布式的版本控制系统，它不需要一个集中的版本号，所以没有远程仓库其实也可以工作。</p>\n<p>工作区是.git文件夹及其子文件夹的所有文件的区域，可以理解为工作区就是一个目录里面的所有文件组成的分区，没有被索引的文件都在工作区总。add指令可以将工作区中的内容添加到暂存区，暂存区里面的文件都是被tracked的文件，也就是说，任何一次commit都会对暂存区的文件做一次快照。经过commit之后，暂存区的修改就会被提交到本地仓库，本地仓库中的记录就是一个个版本，可以被回退或者创建分支。</p>\n<p>远程仓库是一个可以实现多机共同协作的地方，每个人都可以把本地仓库里面的commit推送到远程仓库，别人也可以从远程仓库中拉取最新的代码。常见的远程仓库网站有：Github、Gitee等等，甚至也可以自己在服务器上搭建一个git仓库。</p>\n<h1 id=\"git使用\"><a href=\"#git使用\" class=\"headerlink\" title=\"git使用\"></a>git使用</h1><p>这里用git的常用命令组织文章结构，这样写的好处是应用性较强。我推荐看看<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的git教程</a>，他使用一个仓库管理的实例和故事性的结构讲述git，我认为十分通俗易懂。</p>\n<h2 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h2><p>在项目的根目录下创建一个git仓库，git会对整个目录范围内的代码进行管理。比如，我在桌面创建一个example目录，然后打开目录，右键Open Git Bash here，输入指令<code>git init</code>即可初始化一个git仓库。初始化完成之后，可以打开.git隐藏文件夹，里面就有一些文件是记录当前仓库的信息的，比如config记录当前仓库设置，HEAD记录代码提交。</p>\n<p>这个文件里面的东西不需要自己写！！！</p>\n<p>这个文件里面的东西不需要自己写！！！</p>\n<p>这个文件里面的东西不需要自己写！！！</p>\n<p>重要的事情说三遍，不要自己修改把仓库玩坏了，一般来说是不用打开.git目录的，处于学习的目的可以进去研究一下。</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p><code>git add</code>指令的作用是将文件或者目录添加到暂存区，包括新增的，删除的，修改的。这里以刚刚创建的example文件夹为例，我创建了一个hello_world.txt文件，里面写上hello world。然后保存退出。使用git add指令将其添加到暂存区：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>.表示当前目录，它会自动把当前目录的所有文件及其子目录里面的文件都加入暂存区，执行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031017260.webp\" alt=\"image-20230803101729190\"></p>\n<p>是的，你没有看错，它什么也没有发生。</p>\n<h2 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h2><p>刚才使用的<code>git add</code>指令只是将其添加到git暂存区，而不是提交修改到仓库。也就是说，你自己<code>git add</code>多少次都没有影响仓库里面的东西，那么要提交的话就需要使用<code>git commit</code>指令。</p>\n<p><code>git commit</code>指令将暂存区提交到了仓库，仓库会为当前修改创建一个节点，每一次的commit都是仓库版本回退的节点，那些add但是没有commit的修改是不能回退的。使用方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m<span class=\"string\">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>-m后面的双引号就是本次提交的消息，一般用来记录修改了什么，执行结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031025317.webp\" alt=\"image-20230803102546243\"></p>\n<p>接下来我们修改一下hello_world.txt里面的内容，再提交一次，修改的内容为：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello world!</span><br><span class=\"line\">hello git!</span><br></pre></td></tr></table></figure>\n\n<p>然后执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m<span class=\"string\">&quot;hello git&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031029096.webp\" alt=\"image-20230803102954025\"></p>\n<p>那么接下来我们看一下自己的这两次修改：打开.git&#x2F;log&#x2F;HEAD，里面有我们的修改记录：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031031132.webp\" alt=\"image-20230803103148007\"></p>\n<p>当然这些东西直接使用<code>git log</code>指令也可以直接看到：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031247530.webp\" alt=\"image-20230803124739397\"></p>\n<p>commit后面的十六进制数字串就是版本号，后面是修改人的名字和邮箱，修改日期以及修改评语等。后面可以根据这个版本号直接回退到彼时的仓库状态。</p>\n<h2 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h2><p>如果再某一次的修改中，代码直接崩掉无法运作了，就可以使用<code>git reset</code>指令，坐上时光机回到过去。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031257570.webp\" alt=\"image-20230803125719486\"></p>\n<p>使用的时候它也会提醒你”Unstaged changes after reset:”，这个时候是仓库工作区（也就是代码内容）并没有回退成功的，只是撤销了最后一次提交，并且将HEAD指针移动到上一次更改，这个时候你可以加上<code>--hard</code>指令强制整个仓库（包括工作区）回退到指定的版本号。但是有一点需要注意，这个时光机是不能带着未来的东西回去的。也就是说，你后面写的代码都会被丢失，使用reset –hard指令之后，整个仓库都会回到过去的一个commit的状态。你可以打开文件看看是不是回去了。</p>\n<p>此外，如果只是要回退一个版本号，那么不需要查版本号，只需要：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n\n<p>HEAD^代替了上一个版本号。</p>\n<h2 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h2><p>暂存用于当前某一件事情做了一半的情况下，需要切换到另外一个分支处理另一个事情的时候把当前的工作区保存起来。例如，当前你正在开发一个新功能，但是突然leader说原来的版本有一个bug需要切换到另外一个分支解决，这个时候直接checkout是不会成功的，因为当前工作区发生了改变，会提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class=\"line\">**************</span><br><span class=\"line\">Please commit your changes or stash them before you switch branches.</span><br><span class=\"line\">Aborting</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如何存储？</li>\n</ul>\n<p>使用<code>git stash</code>可以简单粗暴地存储当前的工作区，但是推荐使用<code>git stash save &quot;msg&quot;</code>的方式，可以对存储内容进行描述，使用<code>git stash list</code>可以查看曾经存储的进度：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS M:\\MyProjects\\ILOVEJava&gt; git stash list </span><br><span class=\"line\">stash@&#123;0&#125;: On newb: 添加测试</span><br></pre></td></tr></table></figure>\n\n<p>On ***表示再某个分支，一般情况下，从stash中恢复的时候推荐从原来stash的分支恢复，避免发生冲突。</p>\n<ul>\n<li>如何恢复</li>\n</ul>\n<p>使用<code>git stash pop</code>可以快速恢复暂存区的最新内容，<code>git stash pop stash@&#123;1&#125;</code>可以恢复到指定内容。</p>\n<h2 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h2><p>上面讲的都是在本地仓库使用Git的操作，接下来我们来用一下远程仓库，这里以Github为例。</p>\n<ul>\n<li>首先，新建一个空仓库，建完之后长这样：</li>\n</ul>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031326922.webp\" alt=\"image-20230803132631654\"></p>\n<p>如果使用了模板创建的话，仓库在创建之初就会有一些文件，比如README.md，.gitignore等等。</p>\n<ul>\n<li>将本地仓库与远程仓库进行关联：</li>\n</ul>\n<p>每一个仓库都会有一个个人地址，将地址copy下来之后，在控制台输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/Veni222987/example.git</span><br></pre></td></tr></table></figure>\n\n<p>然后使用<code>git remote</code>指令可以查看所有远程仓库。</p>\n<ul>\n<li>将本地仓库上面的东西上传到远程仓库：</li>\n</ul>\n<p>使用<code>git push</code>指令可以将本地仓库上面的东西推送到远程仓库中，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<p>执行结果长这样：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031336488.webp\" alt=\"image-20230803133602402\"></p>\n<p>之后到github上面就可以看到东西已经提交上去了。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308031346455.webp\" alt=\"image-20230803134614334\"></p>\n<p>细心的朋友可能会发现，这次提交的东西怎么是hello world呢？后来不是写了个hello git吗？这是因为，我们在上一步的时候把版本回退到了第一个版本，也就是整个仓库都是第一次提交的状态，那么push上去自然也就是那个时候的状态了。</p>\n<h2 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h2><p><code>git pull</code>指令用于把远程仓库上的代码拉取到本地仓库，执行pull指令需要注意：</p>\n<ul>\n<li><code>git pull</code>指令相当于<code>git fetch</code>和<code>git merge</code>指令，会把远程分支和本地分支进行合并，如果远程分支包含本地分支的修改，即远程分支比本地分支先进，就会更新本地分支。</li>\n</ul>\n<p>首先，在txt文件中加一行hello remote1，然后commit的消息为”add remote1”，再在txt文件中加一行hello remote2，然后commit消息”add remote2”，此时的文件应该是：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello world</span><br><span class=\"line\">hello remote1</span><br><span class=\"line\">hello remote2</span><br></pre></td></tr></table></figure>\n\n<p>将add remote2的commit推送给到远程仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<p>然后版本回退到remote1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n\n<p>此时仓库的状态是远程分支领先当前分支一个commit，使用pull可以将远程仓库的更新拉下来并且自动更新本地工作区：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin main</span><br></pre></td></tr></table></figure>\n\n<p>下图展示了一个单分支模型的pull过程：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040925411.webp\" alt=\"image-20230804092501173\"></p>\n<ul>\n<li>当远程仓库和本地仓库处在两个不同的分支时，在merge的时候就可能会出现冲突：</li>\n</ul>\n<p>在刚才的修改基础上，我们再退回去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n\n<p>然后添加一行：hello remote3，即文件变成了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello world</span><br><span class=\"line\">hello remote1</span><br><span class=\"line\">hello remote3</span><br></pre></td></tr></table></figure>\n\n<p>commit当前修改:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m<span class=\"string\">&quot;add remote3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候，本地分支比远程分支领先1个commit，落后1个commit，而且修改的是同一个文件的同一行，会引发合并冲突：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040948792.webp\" alt=\"image-20230804094839690\"></p>\n<p>此时需要我们手动合并冲突。出现合并冲突窗口后，不要急着关闭bash窗口，查看所有的CONFICT所在的文件，打开之后找到带有分隔符（&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;以及&gt;&gt;&gt;）的代码段或文本段：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040950461.webp\" alt=\"image-20230804095051321\"></p>\n<p>选择一种方案保留，（推荐使用vscode打开，可以一键选择），我这里选择了保留当前更改，然后回到git bash，此时的仓库处于MERGING状态，需要手动修改完所有冲突文件之后再commit一次才能退出该状态，然后将此修改推送到远程仓库，此时两个仓库又处于同步状态了。</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040954824.webp\" alt=\"image-20230804095453725\"></p>\n<p>本次合并的示意图如下：</p>\n<pre class=\"mermaid\">---\ntitle: 合并分支示意图\n---\ngitGraph\n   commit id: \"init\"\n   commit id: \"add remote1\"\n\n   branch origin_main\n   checkout origin_main\n   commit id: \"add remote2\"\n   checkout main\n\n   commit id: \"add remote3\"\n   merge origin_main\n   commit id: \"merge confict\"</pre>\n\n<p>如果将本地分支push到远程分支，则会将远程分支的HEAD指针指向merge conflict：</p>\n<p><img src=\"https://vblog-1315512378.cos.ap-guangzhou.myqcloud.com/imgs/vblog/202308040959347.webp\" alt=\"image-20230804095928183\"></p>\n<h2 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h2><p>git checkout用于切换仓库的工作状态，比如切换到指定分支或指定提交。常见的用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述指令用于切换到指定分支。一般来说，在实际开发中，一个仓库会有不同的分支，不同的人管理不同的分支。使用<code>git chekout -b &lt;branch_name&gt;</code>可以以当前分支为基础创建并切换到新的分支；使用<code>git branch -a</code>显示所有分支。</p>\n<p>当在不同分支工作的时候，可以相互合并分支的代码，比如本地main分支合并远程dev分支（默认为origin&#x2F;dev），则可以在main分支下使用以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin dev</span><br></pre></td></tr></table></figure>\n\n<p>前面我们说过，<code>git pull</code>相当于<code>git fetch+git merge</code>，<code>git fetch</code>指令就是将远程分支中的内容取到本地，而git merge则用于合并。一般情况下，git会使用自带的合并策略自动完成合并，出现冲突则需要手动处理并重新提交。</p>\n<p>如果是本地分支合并另一个分支的代码，则无需使用pull指令，而是直接使用<code>git merge</code>。比如主分支合并本地dev分支，在main分支下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>git还有其他的用法，比如<code>git checkout</code>，<code>git merge</code>等等，实际上掌握了上面的常用指令之后就可以满足日常的合作开发需求了。学习git的最佳实践就是反复练习使用上面的指令，最终能够达到还没执行指令就知道会发生什么的境界，那就代表自己是真的理解了。</p>\n","categories":[{"name":"tools","slug":"tools","permalink":"https://veni222987.github.io/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://veni222987.github.io/tags/git/"}]}]